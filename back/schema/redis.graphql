
input redisRedisSpecTLSSecretItemsItem {
  key: String!
  mode: Int
  path: String!
}
input redisRedisSpecTLSSecret {
  defaultMode: Int
  items: [redisRedisSpecTLSSecretItemsItem]
  optional: Boolean
  secretName: String
}
input redisRedisSpecTLS {
  ca: String
  cert: String
  key: String
  secret: redisRedisSpecTLSSecret!
}
input redisRedisSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchExpressionsItem {
  key: String!
  operator: String!
  values: [String]
}
input redisRedisSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreference {
  matchExpressions: [redisRedisSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchExpressionsItem]
  matchFields: [redisRedisSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchExpressionsItem]
}
input redisRedisSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem {
  preference: redisRedisSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreference!
  weight: Int!
}
input redisRedisSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  nodeSelectorTerms: [redisRedisSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreference!]
}
input redisRedisSpecAffinityNodeAffinity {
  preferredDuringSchedulingIgnoredDuringExecution: [redisRedisSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem]
  requiredDuringSchedulingIgnoredDuringExecution: redisRedisSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
}
input redisRedisSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem {
  key: String!
  operator: String!
  values: [String]
}
input redisRedisSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector {
  matchExpressions: [redisRedisSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem]
  matchLabels: JSONObject
}
input redisRedisSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm {
  labelSelector: redisRedisSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector
  namespaceSelector: redisRedisSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector
  namespaces: [String]
  topologyKey: String!
}
input redisRedisSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem {
  podAffinityTerm: redisRedisSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm!
  weight: Int!
}
input redisRedisSpecAffinityPodAffinity {
  preferredDuringSchedulingIgnoredDuringExecution: [redisRedisSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem]
  requiredDuringSchedulingIgnoredDuringExecution: [redisRedisSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm]
}
input redisRedisSpecAffinityPodAntiAffinity {
  preferredDuringSchedulingIgnoredDuringExecution: [redisRedisSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem]
  requiredDuringSchedulingIgnoredDuringExecution: [redisRedisSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm]
}
input redisRedisSpecAffinity {
  nodeAffinity: redisRedisSpecAffinityNodeAffinity
  podAffinity: redisRedisSpecAffinityPodAffinity
  podAntiAffinity: redisRedisSpecAffinityPodAntiAffinity
}
input redisRedisSpecKubernetesConfigImagePullSecretsItem {
  name: String
}
input redisRedisSpecKubernetesConfigRedisSecret {
  key: String
  name: String
}
input redisRedisSpecKubernetesConfigUpdateStrategyRollingUpdate {
  partition: Int
}
input redisRedisSpecKubernetesConfigUpdateStrategy {
  rollingUpdate: redisRedisSpecKubernetesConfigUpdateStrategyRollingUpdate
  type: String
}
input redisRedisSpecKubernetesConfig {
  image: String!
  imagePullPolicy: String
  imagePullSecrets: [redisRedisSpecKubernetesConfigImagePullSecretsItem]
  redisSecret: redisRedisSpecKubernetesConfigRedisSecret
  resources: JSONObject
  updateStrategy: redisRedisSpecKubernetesConfigUpdateStrategy
}
input redisRedisSpecLivenessProbe {
  failureThreshold: Int
  initialDelaySeconds: Int
  periodSeconds: Int
  successThreshold: Int
  timeoutSeconds: Int
}
input redisRedisSpecRedisConfig {
  additionalRedisConfig: String
}
input redisRedisSpecRedisExporterEnvItemValueFromConfigMapKeyRef {
  key: String!
  name: String
  optional: Boolean
}
input redisRedisSpecRedisExporterEnvItemValueFromFieldRef {
  apiVersion: String
  fieldPath: String!
}
input redisRedisSpecRedisExporterEnvItemValueFromResourceFieldRef {
  containerName: String
  divisor: JSONObject
  resource: String!
}
input redisRedisSpecRedisExporterEnvItemValueFromSecretKeyRef {
  key: String!
  name: String
  optional: Boolean
}
input redisRedisSpecRedisExporterEnvItemValueFrom {
  configMapKeyRef: redisRedisSpecRedisExporterEnvItemValueFromConfigMapKeyRef
  fieldRef: redisRedisSpecRedisExporterEnvItemValueFromFieldRef
  resourceFieldRef: redisRedisSpecRedisExporterEnvItemValueFromResourceFieldRef
  secretKeyRef: redisRedisSpecRedisExporterEnvItemValueFromSecretKeyRef
}
input redisRedisSpecRedisExporterEnvItem {
  name: String!
  value: String
  valueFrom: redisRedisSpecRedisExporterEnvItemValueFrom
}
input redisRedisSpecRedisExporter {
  enabled: Boolean
  env: [redisRedisSpecRedisExporterEnvItem]
  image: String!
  imagePullPolicy: String
  resources: JSONObject
}
input redisRedisSpecSecurityContextSeLinuxOptions {
  level: String
  role: String
  type: String
  user: String
}
input redisRedisSpecSecurityContextSeccompProfile {
  localhostProfile: String
  type: String!
}
input redisRedisSpecSecurityContextSysctlsItem {
  name: String!
  value: String!
}
input redisRedisSpecSecurityContextWindowsOptions {
  gmsaCredentialSpec: String
  gmsaCredentialSpecName: String
  hostProcess: Boolean
  runAsUserName: String
}
input redisRedisSpecSecurityContext {
  fsGroup: Int
  fsGroupChangePolicy: String
  runAsGroup: Int
  runAsNonRoot: Boolean
  runAsUser: Int
  seLinuxOptions: redisRedisSpecSecurityContextSeLinuxOptions
  seccompProfile: redisRedisSpecSecurityContextSeccompProfile
  supplementalGroups: [Int]
  sysctls: [redisRedisSpecSecurityContextSysctlsItem]
  windowsOptions: redisRedisSpecSecurityContextWindowsOptions
}
input redisRedisSpecSidecarsItem {
  env: [redisRedisSpecRedisExporterEnvItem]
  image: String!
  imagePullPolicy: String
  name: String!
  resources: JSONObject
}
input redisRedisSpecStorageVolumeClaimTemplateSpecDataSource {
  apiGroup: String
  kind: String!
  name: String!
}
input redisRedisSpecStorageVolumeClaimTemplateSpec {
  accessModes: [String]
  dataSource: redisRedisSpecStorageVolumeClaimTemplateSpecDataSource
  dataSourceRef: redisRedisSpecStorageVolumeClaimTemplateSpecDataSource
  resources: JSONObject
  selector: redisRedisSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector
  storageClassName: String
  volumeMode: String
  volumeName: String
}
input redisRedisSpecStorageVolumeClaimTemplateStatusConditionsItem {
  lastProbeTime: String
  lastTransitionTime: String
  message: String
  reason: String
  status: String!
  type: String!
}
input redisRedisSpecStorageVolumeClaimTemplateStatus {
  accessModes: [String]
  allocatedResources: JSONObject
  capacity: JSONObject
  conditions: [redisRedisSpecStorageVolumeClaimTemplateStatusConditionsItem]
  phase: String
  resizeStatus: String
}
input redisRedisSpecStorageVolumeClaimTemplate {
  apiVersion: String
  kind: String
  metadata: JSONObject
  spec: redisRedisSpecStorageVolumeClaimTemplateSpec
  status: redisRedisSpecStorageVolumeClaimTemplateStatus
}
input redisRedisSpecStorage {
  volumeClaimTemplate: redisRedisSpecStorageVolumeClaimTemplate
}
input redisRedisSpecTolerationsItem {
  effect: String
  key: String
  operator: String
  tolerationSeconds: Int
  value: String
}
input redisRedisSpec {
  TLS: redisRedisSpecTLS
  affinity: redisRedisSpecAffinity
  kubernetesConfig: redisRedisSpecKubernetesConfig!
  livenessProbe: redisRedisSpecLivenessProbe
  nodeSelector: JSONObject
  priorityClassName: String
  readinessProbe: redisRedisSpecLivenessProbe
  redisConfig: redisRedisSpecRedisConfig
  redisExporter: redisRedisSpecRedisExporter
  securityContext: redisRedisSpecSecurityContext
  serviceAccountName: String
  sidecars: [redisRedisSpecSidecarsItem]
  storage: redisRedisSpecStorage
  tolerations: [redisRedisSpecTolerationsItem]
}
type redisRedisTLSSecretItemsItem {
  key: String!
  mode: Int
  path: String!
}
type redisRedisTLSSecret {
  defaultMode: Int
  items: [redisRedisTLSSecretItemsItem]
  optional: Boolean
  secretName: String
}
type redisRedisTLS {
  ca: String
  cert: String
  key: String
  secret: redisRedisTLSSecret!
}
type redisRedisAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchExpressionsItem {
  key: String!
  operator: String!
  values: [String]
}
type redisRedisAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreference {
  matchExpressions: [redisRedisAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchExpressionsItem]
  matchFields: [redisRedisAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchExpressionsItem]
}
type redisRedisAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem {
  preference: redisRedisAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreference!
  weight: Int!
}
type redisRedisAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  nodeSelectorTerms: [redisRedisAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreference!]
}
type redisRedisAffinityNodeAffinity {
  preferredDuringSchedulingIgnoredDuringExecution: [redisRedisAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem]
  requiredDuringSchedulingIgnoredDuringExecution: redisRedisAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
}
type redisRedisAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem {
  key: String!
  operator: String!
  values: [String]
}
type redisRedisAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector {
  matchExpressions: [redisRedisAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem]
  matchLabels: JSONObject
}
type redisRedisAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm {
  labelSelector: redisRedisAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector
  namespaceSelector: redisRedisAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector
  namespaces: [String]
  topologyKey: String!
}
type redisRedisAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem {
  podAffinityTerm: redisRedisAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm!
  weight: Int!
}
type redisRedisAffinityPodAffinity {
  preferredDuringSchedulingIgnoredDuringExecution: [redisRedisAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem]
  requiredDuringSchedulingIgnoredDuringExecution: [redisRedisAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm]
}
type redisRedisAffinityPodAntiAffinity {
  preferredDuringSchedulingIgnoredDuringExecution: [redisRedisAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem]
  requiredDuringSchedulingIgnoredDuringExecution: [redisRedisAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm]
}
type redisRedisAffinity {
  nodeAffinity: redisRedisAffinityNodeAffinity
  podAffinity: redisRedisAffinityPodAffinity
  podAntiAffinity: redisRedisAffinityPodAntiAffinity
}
type redisRedisKubernetesConfigImagePullSecretsItem {
  name: String
}
type redisRedisKubernetesConfigRedisSecret {
  key: String
  name: String
}
type redisRedisKubernetesConfigUpdateStrategyRollingUpdate {
  partition: Int
}
type redisRedisKubernetesConfigUpdateStrategy {
  rollingUpdate: redisRedisKubernetesConfigUpdateStrategyRollingUpdate
  type: String
}
type redisRedisKubernetesConfig {
  image: String!
  imagePullPolicy: String
  imagePullSecrets: [redisRedisKubernetesConfigImagePullSecretsItem]
  redisSecret: redisRedisKubernetesConfigRedisSecret
  resources: JSONObject
  updateStrategy: redisRedisKubernetesConfigUpdateStrategy
}
type redisRedisLivenessProbe {
  failureThreshold: Int
  initialDelaySeconds: Int
  periodSeconds: Int
  successThreshold: Int
  timeoutSeconds: Int
}
type redisRedisRedisConfig {
  additionalRedisConfig: String
}
type redisRedisRedisExporterEnvItemValueFromConfigMapKeyRef {
  key: String!
  name: String
  optional: Boolean
}
type redisRedisRedisExporterEnvItemValueFromFieldRef {
  apiVersion: String
  fieldPath: String!
}
type redisRedisRedisExporterEnvItemValueFromResourceFieldRef {
  containerName: String
  divisor: JSONObject
  resource: String!
}
type redisRedisRedisExporterEnvItemValueFromSecretKeyRef {
  key: String!
  name: String
  optional: Boolean
}
type redisRedisRedisExporterEnvItemValueFrom {
  configMapKeyRef: redisRedisRedisExporterEnvItemValueFromConfigMapKeyRef
  fieldRef: redisRedisRedisExporterEnvItemValueFromFieldRef
  resourceFieldRef: redisRedisRedisExporterEnvItemValueFromResourceFieldRef
  secretKeyRef: redisRedisRedisExporterEnvItemValueFromSecretKeyRef
}
type redisRedisRedisExporterEnvItem {
  name: String!
  value: String
  valueFrom: redisRedisRedisExporterEnvItemValueFrom
}
type redisRedisRedisExporter {
  enabled: Boolean
  env: [redisRedisRedisExporterEnvItem]
  image: String!
  imagePullPolicy: String
  resources: JSONObject
}
type redisRedisSecurityContextSeLinuxOptions {
  level: String
  role: String
  type: String
  user: String
}
type redisRedisSecurityContextSeccompProfile {
  localhostProfile: String
  type: String!
}
type redisRedisSecurityContextSysctlsItem {
  name: String!
  value: String!
}
type redisRedisSecurityContextWindowsOptions {
  gmsaCredentialSpec: String
  gmsaCredentialSpecName: String
  hostProcess: Boolean
  runAsUserName: String
}
type redisRedisSecurityContext {
  fsGroup: Int
  fsGroupChangePolicy: String
  runAsGroup: Int
  runAsNonRoot: Boolean
  runAsUser: Int
  seLinuxOptions: redisRedisSecurityContextSeLinuxOptions
  seccompProfile: redisRedisSecurityContextSeccompProfile
  supplementalGroups: [Int]
  sysctls: [redisRedisSecurityContextSysctlsItem]
  windowsOptions: redisRedisSecurityContextWindowsOptions
}
type redisRedisSidecarsItem {
  env: [redisRedisRedisExporterEnvItem]
  image: String!
  imagePullPolicy: String
  name: String!
  resources: JSONObject
}
type redisRedisStorageVolumeClaimTemplateSpecDataSource {
  apiGroup: String
  kind: String!
  name: String!
}
type redisRedisStorageVolumeClaimTemplateSpec {
  accessModes: [String]
  dataSource: redisRedisStorageVolumeClaimTemplateSpecDataSource
  dataSourceRef: redisRedisStorageVolumeClaimTemplateSpecDataSource
  resources: JSONObject
  selector: redisRedisAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector
  storageClassName: String
  volumeMode: String
  volumeName: String
}
type redisRedisStorageVolumeClaimTemplateStatusConditionsItem {
  lastProbeTime: String
  lastTransitionTime: String
  message: String
  reason: String
  status: String!
  type: String!
}
type redisRedisStorageVolumeClaimTemplateStatus {
  accessModes: [String]
  allocatedResources: JSONObject
  capacity: JSONObject
  conditions: [redisRedisStorageVolumeClaimTemplateStatusConditionsItem]
  phase: String
  resizeStatus: String
}
type redisRedisStorageVolumeClaimTemplate {
  apiVersion: String
  kind: String
  metadata: JSONObject
  spec: redisRedisStorageVolumeClaimTemplateSpec
  status: redisRedisStorageVolumeClaimTemplateStatus
}
type redisRedisStorage {
  volumeClaimTemplate: redisRedisStorageVolumeClaimTemplate
}
type redisRedisTolerationsItem {
  effect: String
  key: String
  operator: String
  tolerationSeconds: Int
  value: String
}
type redisRedis {
  metadata: metadata
  TLS: redisRedisTLS
  affinity: redisRedisAffinity
  kubernetesConfig: redisRedisKubernetesConfig!
  livenessProbe: redisRedisLivenessProbe
  nodeSelector: JSONObject
  priorityClassName: String
  readinessProbe: redisRedisLivenessProbe
  redisConfig: redisRedisRedisConfig
  redisExporter: redisRedisRedisExporter
  securityContext: redisRedisSecurityContext
  serviceAccountName: String
  sidecars: [redisRedisSidecarsItem]
  storage: redisRedisStorage
  tolerations: [redisRedisTolerationsItem]
}
input redisRedisClusterSpecRedisFollowerPdb {
  enabled: Boolean
  maxUnavailable: Int
  minAvailable: Int
}
input redisRedisClusterSpecRedisFollower {
  affinity: redisRedisSpecAffinity
  livenessProbe: redisRedisSpecLivenessProbe
  pdb: redisRedisClusterSpecRedisFollowerPdb
  readinessProbe: redisRedisSpecLivenessProbe
  redisConfig: redisRedisSpecRedisConfig
  replicas: Int
}
input redisRedisClusterSpec {
  TLS: redisRedisSpecTLS
  clusterSize: Int!
  clusterVersion: String
  kubernetesConfig: redisRedisSpecKubernetesConfig!
  nodeSelector: JSONObject
  persistenceEnabled: Boolean
  priorityClassName: String
  redisExporter: redisRedisSpecRedisExporter
  redisFollower: redisRedisClusterSpecRedisFollower
  redisLeader: redisRedisClusterSpecRedisFollower
  resources: JSONObject
  securityContext: redisRedisSpecSecurityContext
  serviceAccountName: String
  sidecars: [redisRedisSpecSidecarsItem]
  storage: redisRedisSpecStorage
  tolerations: [redisRedisSpecTolerationsItem]
}
type redisRedisClusterRedisFollowerPdb {
  enabled: Boolean
  maxUnavailable: Int
  minAvailable: Int
}
type redisRedisClusterRedisFollower {
  affinity: redisRedisAffinity
  livenessProbe: redisRedisLivenessProbe
  pdb: redisRedisClusterRedisFollowerPdb
  readinessProbe: redisRedisLivenessProbe
  redisConfig: redisRedisRedisConfig
  replicas: Int
}
type redisRedisCluster {
  metadata: metadata
  TLS: redisRedisTLS
  clusterSize: Int!
  clusterVersion: String
  kubernetesConfig: redisRedisKubernetesConfig!
  nodeSelector: JSONObject
  persistenceEnabled: Boolean
  priorityClassName: String
  redisExporter: redisRedisRedisExporter
  redisFollower: redisRedisClusterRedisFollower
  redisLeader: redisRedisClusterRedisFollower
  resources: JSONObject
  securityContext: redisRedisSecurityContext
  serviceAccountName: String
  sidecars: [redisRedisSidecarsItem]
  storage: redisRedisStorage
  tolerations: [redisRedisTolerationsItem]
}
input redisRedisReplicationSpecKubernetesConfigService {
  annotations: JSONObject
  serviceType: String
}
input redisRedisReplicationSpecKubernetesConfig {
  image: String!
  imagePullPolicy: String
  imagePullSecrets: [redisRedisSpecKubernetesConfigImagePullSecretsItem]
  redisSecret: redisRedisSpecKubernetesConfigRedisSecret
  resources: JSONObject
  service: redisRedisReplicationSpecKubernetesConfigService
  updateStrategy: redisRedisSpecKubernetesConfigUpdateStrategy
}
input redisRedisReplicationSpecStorageVolumeMountMountPathItem {
  mountPath: String!
  mountPropagation: String
  name: String!
  readOnly: Boolean
  subPath: String
  subPathExpr: String
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemAwsElasticBlockStore {
  fsType: String
  partition: Int
  readOnly: Boolean
  volumeID: String!
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemAzureDisk {
  cachingMode: String
  diskName: String!
  diskURI: String!
  fsType: String
  kind: String
  readOnly: Boolean
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemAzureFile {
  readOnly: Boolean
  secretName: String!
  shareName: String!
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemCephfs {
  monitors: [String]!
  path: String
  readOnly: Boolean
  secretFile: String
  secretRef: redisRedisSpecKubernetesConfigImagePullSecretsItem
  user: String
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemCinder {
  fsType: String
  readOnly: Boolean
  secretRef: redisRedisSpecKubernetesConfigImagePullSecretsItem
  volumeID: String!
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemConfigMap {
  defaultMode: Int
  items: [redisRedisSpecTLSSecretItemsItem]
  name: String
  optional: Boolean
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemCsi {
  driver: String!
  fsType: String
  nodePublishSecretRef: redisRedisSpecKubernetesConfigImagePullSecretsItem
  readOnly: Boolean
  volumeAttributes: JSONObject
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemDownwardAPIItemsItem {
  fieldRef: redisRedisSpecRedisExporterEnvItemValueFromFieldRef
  mode: Int
  path: String!
  resourceFieldRef: redisRedisSpecRedisExporterEnvItemValueFromResourceFieldRef
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemDownwardAPI {
  defaultMode: Int
  items: [redisRedisReplicationSpecStorageVolumeMountVolumeItemDownwardAPIItemsItem]
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemEmptyDir {
  medium: String
  sizeLimit: JSONObject
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemEphemeralVolumeClaimTemplate {
  metadata: JSONObject
  spec: redisRedisSpecStorageVolumeClaimTemplateSpec!
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemEphemeral {
  volumeClaimTemplate: redisRedisReplicationSpecStorageVolumeMountVolumeItemEphemeralVolumeClaimTemplate
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemFc {
  fsType: String
  lun: Int
  readOnly: Boolean
  targetWWNs: [String]
  wwids: [String]
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemFlexVolume {
  driver: String!
  fsType: String
  options: JSONObject
  readOnly: Boolean
  secretRef: redisRedisSpecKubernetesConfigImagePullSecretsItem
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemFlocker {
  datasetName: String
  datasetUUID: String
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemGcePersistentDisk {
  fsType: String
  partition: Int
  pdName: String!
  readOnly: Boolean
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemGitRepo {
  directory: String
  repository: String!
  revision: String
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemGlusterfs {
  endpoints: String!
  path: String!
  readOnly: Boolean
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemHostPath {
  path: String!
  type: String
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemIscsi {
  chapAuthDiscovery: Boolean
  chapAuthSession: Boolean
  fsType: String
  initiatorName: String
  iqn: String!
  iscsiInterface: String
  lun: Int!
  portals: [String]
  readOnly: Boolean
  secretRef: redisRedisSpecKubernetesConfigImagePullSecretsItem
  targetPortal: String!
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemNfs {
  path: String!
  readOnly: Boolean
  server: String!
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemPersistentVolumeClaim {
  claimName: String!
  readOnly: Boolean
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemPhotonPersistentDisk {
  fsType: String
  pdID: String!
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemPortworxVolume {
  fsType: String
  readOnly: Boolean
  volumeID: String!
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemProjectedSourcesItemConfigMap {
  items: [redisRedisSpecTLSSecretItemsItem]
  name: String
  optional: Boolean
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemProjectedSourcesItemDownwardAPI {
  items: [redisRedisReplicationSpecStorageVolumeMountVolumeItemDownwardAPIItemsItem]
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemProjectedSourcesItemSecret {
  items: [redisRedisSpecTLSSecretItemsItem]
  name: String
  optional: Boolean
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemProjectedSourcesItemServiceAccountToken {
  audience: String
  expirationSeconds: Int
  path: String!
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemProjectedSourcesItem {
  configMap: redisRedisReplicationSpecStorageVolumeMountVolumeItemProjectedSourcesItemConfigMap
  downwardAPI: redisRedisReplicationSpecStorageVolumeMountVolumeItemProjectedSourcesItemDownwardAPI
  secret: redisRedisReplicationSpecStorageVolumeMountVolumeItemProjectedSourcesItemSecret
  serviceAccountToken: redisRedisReplicationSpecStorageVolumeMountVolumeItemProjectedSourcesItemServiceAccountToken
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemProjected {
  defaultMode: Int
  sources: [redisRedisReplicationSpecStorageVolumeMountVolumeItemProjectedSourcesItem]
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemQuobyte {
  group: String
  readOnly: Boolean
  registry: String!
  tenant: String
  user: String
  volume: String!
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemRbd {
  fsType: String
  image: String!
  keyring: String
  monitors: [String]!
  pool: String
  readOnly: Boolean
  secretRef: redisRedisSpecKubernetesConfigImagePullSecretsItem
  user: String
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemScaleIO {
  fsType: String
  gateway: String!
  protectionDomain: String
  readOnly: Boolean
  secretRef: redisRedisSpecKubernetesConfigImagePullSecretsItem!
  sslEnabled: Boolean
  storageMode: String
  storagePool: String
  system: String!
  volumeName: String
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemStorageos {
  fsType: String
  readOnly: Boolean
  secretRef: redisRedisSpecKubernetesConfigImagePullSecretsItem
  volumeName: String
  volumeNamespace: String
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItemVsphereVolume {
  fsType: String
  storagePolicyID: String
  storagePolicyName: String
  volumePath: String!
}
input redisRedisReplicationSpecStorageVolumeMountVolumeItem {
  awsElasticBlockStore: redisRedisReplicationSpecStorageVolumeMountVolumeItemAwsElasticBlockStore
  azureDisk: redisRedisReplicationSpecStorageVolumeMountVolumeItemAzureDisk
  azureFile: redisRedisReplicationSpecStorageVolumeMountVolumeItemAzureFile
  cephfs: redisRedisReplicationSpecStorageVolumeMountVolumeItemCephfs
  cinder: redisRedisReplicationSpecStorageVolumeMountVolumeItemCinder
  configMap: redisRedisReplicationSpecStorageVolumeMountVolumeItemConfigMap
  csi: redisRedisReplicationSpecStorageVolumeMountVolumeItemCsi
  downwardAPI: redisRedisReplicationSpecStorageVolumeMountVolumeItemDownwardAPI
  emptyDir: redisRedisReplicationSpecStorageVolumeMountVolumeItemEmptyDir
  ephemeral: redisRedisReplicationSpecStorageVolumeMountVolumeItemEphemeral
  fc: redisRedisReplicationSpecStorageVolumeMountVolumeItemFc
  flexVolume: redisRedisReplicationSpecStorageVolumeMountVolumeItemFlexVolume
  flocker: redisRedisReplicationSpecStorageVolumeMountVolumeItemFlocker
  gcePersistentDisk: redisRedisReplicationSpecStorageVolumeMountVolumeItemGcePersistentDisk
  gitRepo: redisRedisReplicationSpecStorageVolumeMountVolumeItemGitRepo
  glusterfs: redisRedisReplicationSpecStorageVolumeMountVolumeItemGlusterfs
  hostPath: redisRedisReplicationSpecStorageVolumeMountVolumeItemHostPath
  iscsi: redisRedisReplicationSpecStorageVolumeMountVolumeItemIscsi
  name: String!
  nfs: redisRedisReplicationSpecStorageVolumeMountVolumeItemNfs
  persistentVolumeClaim: redisRedisReplicationSpecStorageVolumeMountVolumeItemPersistentVolumeClaim
  photonPersistentDisk: redisRedisReplicationSpecStorageVolumeMountVolumeItemPhotonPersistentDisk
  portworxVolume: redisRedisReplicationSpecStorageVolumeMountVolumeItemPortworxVolume
  projected: redisRedisReplicationSpecStorageVolumeMountVolumeItemProjected
  quobyte: redisRedisReplicationSpecStorageVolumeMountVolumeItemQuobyte
  rbd: redisRedisReplicationSpecStorageVolumeMountVolumeItemRbd
  scaleIO: redisRedisReplicationSpecStorageVolumeMountVolumeItemScaleIO
  secret: redisRedisSpecTLSSecret
  storageos: redisRedisReplicationSpecStorageVolumeMountVolumeItemStorageos
  vsphereVolume: redisRedisReplicationSpecStorageVolumeMountVolumeItemVsphereVolume
}
input redisRedisReplicationSpecStorageVolumeMount {
  mountPath: [redisRedisReplicationSpecStorageVolumeMountMountPathItem]
  volume: [redisRedisReplicationSpecStorageVolumeMountVolumeItem]
}
input redisRedisReplicationSpecStorage {
  volumeClaimTemplate: redisRedisSpecStorageVolumeClaimTemplate
  volumeMount: redisRedisReplicationSpecStorageVolumeMount
}
input redisRedisReplicationSpec {
  TLS: redisRedisSpecTLS
  affinity: redisRedisSpecAffinity
  clusterSize: Int!
  kubernetesConfig: redisRedisReplicationSpecKubernetesConfig!
  livenessProbe: redisRedisSpecLivenessProbe
  nodeSelector: JSONObject
  priorityClassName: String
  readinessProbe: redisRedisSpecLivenessProbe
  redisConfig: redisRedisSpecRedisConfig
  redisExporter: redisRedisSpecRedisExporter
  securityContext: redisRedisSpecSecurityContext
  serviceAccountName: String
  sidecars: [redisRedisSpecSidecarsItem]
  storage: redisRedisReplicationSpecStorage
  tolerations: [redisRedisSpecTolerationsItem]
}
type redisRedisReplicationKubernetesConfigService {
  annotations: JSONObject
  serviceType: String
}
type redisRedisReplicationKubernetesConfig {
  image: String!
  imagePullPolicy: String
  imagePullSecrets: [redisRedisKubernetesConfigImagePullSecretsItem]
  redisSecret: redisRedisKubernetesConfigRedisSecret
  resources: JSONObject
  service: redisRedisReplicationKubernetesConfigService
  updateStrategy: redisRedisKubernetesConfigUpdateStrategy
}
type redisRedisReplicationStorageVolumeMountMountPathItem {
  mountPath: String!
  mountPropagation: String
  name: String!
  readOnly: Boolean
  subPath: String
  subPathExpr: String
}
type redisRedisReplicationStorageVolumeMountVolumeItemAwsElasticBlockStore {
  fsType: String
  partition: Int
  readOnly: Boolean
  volumeID: String!
}
type redisRedisReplicationStorageVolumeMountVolumeItemAzureDisk {
  cachingMode: String
  diskName: String!
  diskURI: String!
  fsType: String
  kind: String
  readOnly: Boolean
}
type redisRedisReplicationStorageVolumeMountVolumeItemAzureFile {
  readOnly: Boolean
  secretName: String!
  shareName: String!
}
type redisRedisReplicationStorageVolumeMountVolumeItemCephfs {
  monitors: [String]!
  path: String
  readOnly: Boolean
  secretFile: String
  secretRef: redisRedisKubernetesConfigImagePullSecretsItem
  user: String
}
type redisRedisReplicationStorageVolumeMountVolumeItemCinder {
  fsType: String
  readOnly: Boolean
  secretRef: redisRedisKubernetesConfigImagePullSecretsItem
  volumeID: String!
}
type redisRedisReplicationStorageVolumeMountVolumeItemConfigMap {
  defaultMode: Int
  items: [redisRedisTLSSecretItemsItem]
  name: String
  optional: Boolean
}
type redisRedisReplicationStorageVolumeMountVolumeItemCsi {
  driver: String!
  fsType: String
  nodePublishSecretRef: redisRedisKubernetesConfigImagePullSecretsItem
  readOnly: Boolean
  volumeAttributes: JSONObject
}
type redisRedisReplicationStorageVolumeMountVolumeItemDownwardAPIItemsItem {
  fieldRef: redisRedisRedisExporterEnvItemValueFromFieldRef
  mode: Int
  path: String!
  resourceFieldRef: redisRedisRedisExporterEnvItemValueFromResourceFieldRef
}
type redisRedisReplicationStorageVolumeMountVolumeItemDownwardAPI {
  defaultMode: Int
  items: [redisRedisReplicationStorageVolumeMountVolumeItemDownwardAPIItemsItem]
}
type redisRedisReplicationStorageVolumeMountVolumeItemEmptyDir {
  medium: String
  sizeLimit: JSONObject
}
type redisRedisReplicationStorageVolumeMountVolumeItemEphemeralVolumeClaimTemplate {
  metadata: JSONObject
  spec: redisRedisStorageVolumeClaimTemplateSpec!
}
type redisRedisReplicationStorageVolumeMountVolumeItemEphemeral {
  volumeClaimTemplate: redisRedisReplicationStorageVolumeMountVolumeItemEphemeralVolumeClaimTemplate
}
type redisRedisReplicationStorageVolumeMountVolumeItemFc {
  fsType: String
  lun: Int
  readOnly: Boolean
  targetWWNs: [String]
  wwids: [String]
}
type redisRedisReplicationStorageVolumeMountVolumeItemFlexVolume {
  driver: String!
  fsType: String
  options: JSONObject
  readOnly: Boolean
  secretRef: redisRedisKubernetesConfigImagePullSecretsItem
}
type redisRedisReplicationStorageVolumeMountVolumeItemFlocker {
  datasetName: String
  datasetUUID: String
}
type redisRedisReplicationStorageVolumeMountVolumeItemGcePersistentDisk {
  fsType: String
  partition: Int
  pdName: String!
  readOnly: Boolean
}
type redisRedisReplicationStorageVolumeMountVolumeItemGitRepo {
  directory: String
  repository: String!
  revision: String
}
type redisRedisReplicationStorageVolumeMountVolumeItemGlusterfs {
  endpoints: String!
  path: String!
  readOnly: Boolean
}
type redisRedisReplicationStorageVolumeMountVolumeItemHostPath {
  path: String!
  type: String
}
type redisRedisReplicationStorageVolumeMountVolumeItemIscsi {
  chapAuthDiscovery: Boolean
  chapAuthSession: Boolean
  fsType: String
  initiatorName: String
  iqn: String!
  iscsiInterface: String
  lun: Int!
  portals: [String]
  readOnly: Boolean
  secretRef: redisRedisKubernetesConfigImagePullSecretsItem
  targetPortal: String!
}
type redisRedisReplicationStorageVolumeMountVolumeItemNfs {
  path: String!
  readOnly: Boolean
  server: String!
}
type redisRedisReplicationStorageVolumeMountVolumeItemPersistentVolumeClaim {
  claimName: String!
  readOnly: Boolean
}
type redisRedisReplicationStorageVolumeMountVolumeItemPhotonPersistentDisk {
  fsType: String
  pdID: String!
}
type redisRedisReplicationStorageVolumeMountVolumeItemPortworxVolume {
  fsType: String
  readOnly: Boolean
  volumeID: String!
}
type redisRedisReplicationStorageVolumeMountVolumeItemProjectedSourcesItemConfigMap {
  items: [redisRedisTLSSecretItemsItem]
  name: String
  optional: Boolean
}
type redisRedisReplicationStorageVolumeMountVolumeItemProjectedSourcesItemDownwardAPI {
  items: [redisRedisReplicationStorageVolumeMountVolumeItemDownwardAPIItemsItem]
}
type redisRedisReplicationStorageVolumeMountVolumeItemProjectedSourcesItemSecret {
  items: [redisRedisTLSSecretItemsItem]
  name: String
  optional: Boolean
}
type redisRedisReplicationStorageVolumeMountVolumeItemProjectedSourcesItemServiceAccountToken {
  audience: String
  expirationSeconds: Int
  path: String!
}
type redisRedisReplicationStorageVolumeMountVolumeItemProjectedSourcesItem {
  configMap: redisRedisReplicationStorageVolumeMountVolumeItemProjectedSourcesItemConfigMap
  downwardAPI: redisRedisReplicationStorageVolumeMountVolumeItemProjectedSourcesItemDownwardAPI
  secret: redisRedisReplicationStorageVolumeMountVolumeItemProjectedSourcesItemSecret
  serviceAccountToken: redisRedisReplicationStorageVolumeMountVolumeItemProjectedSourcesItemServiceAccountToken
}
type redisRedisReplicationStorageVolumeMountVolumeItemProjected {
  defaultMode: Int
  sources: [redisRedisReplicationStorageVolumeMountVolumeItemProjectedSourcesItem]
}
type redisRedisReplicationStorageVolumeMountVolumeItemQuobyte {
  group: String
  readOnly: Boolean
  registry: String!
  tenant: String
  user: String
  volume: String!
}
type redisRedisReplicationStorageVolumeMountVolumeItemRbd {
  fsType: String
  image: String!
  keyring: String
  monitors: [String]!
  pool: String
  readOnly: Boolean
  secretRef: redisRedisKubernetesConfigImagePullSecretsItem
  user: String
}
type redisRedisReplicationStorageVolumeMountVolumeItemScaleIO {
  fsType: String
  gateway: String!
  protectionDomain: String
  readOnly: Boolean
  secretRef: redisRedisKubernetesConfigImagePullSecretsItem!
  sslEnabled: Boolean
  storageMode: String
  storagePool: String
  system: String!
  volumeName: String
}
type redisRedisReplicationStorageVolumeMountVolumeItemStorageos {
  fsType: String
  readOnly: Boolean
  secretRef: redisRedisKubernetesConfigImagePullSecretsItem
  volumeName: String
  volumeNamespace: String
}
type redisRedisReplicationStorageVolumeMountVolumeItemVsphereVolume {
  fsType: String
  storagePolicyID: String
  storagePolicyName: String
  volumePath: String!
}
type redisRedisReplicationStorageVolumeMountVolumeItem {
  awsElasticBlockStore: redisRedisReplicationStorageVolumeMountVolumeItemAwsElasticBlockStore
  azureDisk: redisRedisReplicationStorageVolumeMountVolumeItemAzureDisk
  azureFile: redisRedisReplicationStorageVolumeMountVolumeItemAzureFile
  cephfs: redisRedisReplicationStorageVolumeMountVolumeItemCephfs
  cinder: redisRedisReplicationStorageVolumeMountVolumeItemCinder
  configMap: redisRedisReplicationStorageVolumeMountVolumeItemConfigMap
  csi: redisRedisReplicationStorageVolumeMountVolumeItemCsi
  downwardAPI: redisRedisReplicationStorageVolumeMountVolumeItemDownwardAPI
  emptyDir: redisRedisReplicationStorageVolumeMountVolumeItemEmptyDir
  ephemeral: redisRedisReplicationStorageVolumeMountVolumeItemEphemeral
  fc: redisRedisReplicationStorageVolumeMountVolumeItemFc
  flexVolume: redisRedisReplicationStorageVolumeMountVolumeItemFlexVolume
  flocker: redisRedisReplicationStorageVolumeMountVolumeItemFlocker
  gcePersistentDisk: redisRedisReplicationStorageVolumeMountVolumeItemGcePersistentDisk
  gitRepo: redisRedisReplicationStorageVolumeMountVolumeItemGitRepo
  glusterfs: redisRedisReplicationStorageVolumeMountVolumeItemGlusterfs
  hostPath: redisRedisReplicationStorageVolumeMountVolumeItemHostPath
  iscsi: redisRedisReplicationStorageVolumeMountVolumeItemIscsi
  name: String!
  nfs: redisRedisReplicationStorageVolumeMountVolumeItemNfs
  persistentVolumeClaim: redisRedisReplicationStorageVolumeMountVolumeItemPersistentVolumeClaim
  photonPersistentDisk: redisRedisReplicationStorageVolumeMountVolumeItemPhotonPersistentDisk
  portworxVolume: redisRedisReplicationStorageVolumeMountVolumeItemPortworxVolume
  projected: redisRedisReplicationStorageVolumeMountVolumeItemProjected
  quobyte: redisRedisReplicationStorageVolumeMountVolumeItemQuobyte
  rbd: redisRedisReplicationStorageVolumeMountVolumeItemRbd
  scaleIO: redisRedisReplicationStorageVolumeMountVolumeItemScaleIO
  secret: redisRedisTLSSecret
  storageos: redisRedisReplicationStorageVolumeMountVolumeItemStorageos
  vsphereVolume: redisRedisReplicationStorageVolumeMountVolumeItemVsphereVolume
}
type redisRedisReplicationStorageVolumeMount {
  mountPath: [redisRedisReplicationStorageVolumeMountMountPathItem]
  volume: [redisRedisReplicationStorageVolumeMountVolumeItem]
}
type redisRedisReplicationStorage {
  volumeClaimTemplate: redisRedisStorageVolumeClaimTemplate
  volumeMount: redisRedisReplicationStorageVolumeMount
}
type redisRedisReplication {
  metadata: metadata
  TLS: redisRedisTLS
  affinity: redisRedisAffinity
  clusterSize: Int!
  kubernetesConfig: redisRedisReplicationKubernetesConfig!
  livenessProbe: redisRedisLivenessProbe
  nodeSelector: JSONObject
  priorityClassName: String
  readinessProbe: redisRedisLivenessProbe
  redisConfig: redisRedisRedisConfig
  redisExporter: redisRedisRedisExporter
  securityContext: redisRedisSecurityContext
  serviceAccountName: String
  sidecars: [redisRedisSidecarsItem]
  storage: redisRedisReplicationStorage
  tolerations: [redisRedisTolerationsItem]
}
input redisRedisSentinelSpecRedisSentinelConfig {
  additionalSentinelConfig: String
  downAfterMilliseconds: String
  failoverTimeout: String
  masterGroupName: String
  parallelSyncs: String
  quorum: String
  redisPort: String
  redisReplicationName: String!
}
input redisRedisSentinelSpec {
  TLS: redisRedisSpecTLS
  affinity: redisRedisSpecAffinity
  clusterSize: Int!
  kubernetesConfig: redisRedisReplicationSpecKubernetesConfig!
  livenessProbe: redisRedisSpecLivenessProbe
  nodeSelector: JSONObject
  pdb: redisRedisClusterSpecRedisFollowerPdb
  priorityClassName: String
  readinessProbe: redisRedisSpecLivenessProbe
  redisSentinelConfig: redisRedisSentinelSpecRedisSentinelConfig
  securityContext: redisRedisSpecSecurityContext
  serviceAccountName: String
  sidecars: [redisRedisSpecSidecarsItem]
  tolerations: [redisRedisSpecTolerationsItem]
}
type redisRedisSentinelRedisSentinelConfig {
  additionalSentinelConfig: String
  downAfterMilliseconds: String
  failoverTimeout: String
  masterGroupName: String
  parallelSyncs: String
  quorum: String
  redisPort: String
  redisReplicationName: String!
}
type redisRedisSentinel {
  metadata: metadata
  TLS: redisRedisTLS
  affinity: redisRedisAffinity
  clusterSize: Int!
  kubernetesConfig: redisRedisReplicationKubernetesConfig!
  livenessProbe: redisRedisLivenessProbe
  nodeSelector: JSONObject
  pdb: redisRedisClusterRedisFollowerPdb
  priorityClassName: String
  readinessProbe: redisRedisLivenessProbe
  redisSentinelConfig: redisRedisSentinelRedisSentinelConfig
  securityContext: redisRedisSecurityContext
  serviceAccountName: String
  sidecars: [redisRedisSidecarsItem]
  tolerations: [redisRedisTolerationsItem]
}
type Query {
  redisRedis(namespace: String!, name: String!): redisRedis
  redisRedisCluster(namespace: String!, name: String!): redisRedisCluster
  redisRedisReplication(namespace: String!, name: String!): redisRedisReplication
  redisRedisSentinel(namespace: String!, name: String!): redisRedisSentinel
}
type Mutation {
  createRedisRedis(namespace: String!, name: String!, spec: redisRedisSpec!): redisRedis
  patchRedisRedis(namespace: String!, name: String!, spec: redisRedisSpec!): redisRedis
  deleteRedisRedis(namespace: String!, name: String!): redisRedis
  createRedisRedisCluster(namespace: String!, name: String!, spec: redisRedisClusterSpec!): redisRedisCluster
  patchRedisRedisCluster(namespace: String!, name: String!, spec: redisRedisClusterSpec!): redisRedisCluster
  deleteRedisRedisCluster(namespace: String!, name: String!): redisRedisCluster
  createRedisRedisReplication(namespace: String!, name: String!, spec: redisRedisReplicationSpec!): redisRedisReplication
  patchRedisRedisReplication(namespace: String!, name: String!, spec: redisRedisReplicationSpec!): redisRedisReplication
  deleteRedisRedisReplication(namespace: String!, name: String!): redisRedisReplication
  createRedisRedisSentinel(namespace: String!, name: String!, spec: redisRedisSentinelSpec!): redisRedisSentinel
  patchRedisRedisSentinel(namespace: String!, name: String!, spec: redisRedisSentinelSpec!): redisRedisSentinel
  deleteRedisRedisSentinel(namespace: String!, name: String!): redisRedisSentinel
}