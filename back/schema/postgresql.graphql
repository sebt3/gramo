
type postgresqlBackupStatusAzureCredentialsConnectionString {
  key: String!
  name: String!
}
type postgresqlBackupStatusAzureCredentials {
  connectionString: postgresqlBackupStatusAzureCredentialsConnectionString
  inheritFromAzureAD: Boolean
  storageAccount: postgresqlBackupStatusAzureCredentialsConnectionString
  storageKey: postgresqlBackupStatusAzureCredentialsConnectionString
  storageSasToken: postgresqlBackupStatusAzureCredentialsConnectionString
}
type postgresqlBackupStatusGoogleCredentials {
  applicationCredentials: postgresqlBackupStatusAzureCredentialsConnectionString
  gkeEnvironment: Boolean
}
type postgresqlBackupStatusInstanceID {
  ContainerID: String
  podName: String
}
type postgresqlBackupStatusS3Credentials {
  accessKeyId: postgresqlBackupStatusAzureCredentialsConnectionString
  inheritFromIAMRole: Boolean
  region: postgresqlBackupStatusAzureCredentialsConnectionString
  secretAccessKey: postgresqlBackupStatusAzureCredentialsConnectionString
  sessionToken: postgresqlBackupStatusAzureCredentialsConnectionString
}
type postgresqlBackupStatus {
  azureCredentials: postgresqlBackupStatusAzureCredentials
  backupId: String
  backupName: String
  beginLSN: String
  beginWal: String
  commandError: String
  commandOutput: String
  destinationPath: String
  encryption: String
  endLSN: String
  endWal: String
  endpointCA: postgresqlBackupStatusAzureCredentialsConnectionString
  endpointURL: String
  error: String
  googleCredentials: postgresqlBackupStatusGoogleCredentials
  instanceID: postgresqlBackupStatusInstanceID
  phase: String
  s3Credentials: postgresqlBackupStatusS3Credentials
  serverName: String
  startedAt: String
  stoppedAt: String
}
input postgresqlBackupSpecCluster {
  name: String!
}
input postgresqlBackupSpec {
  cluster: postgresqlBackupSpecCluster
  target: String
}
type postgresqlBackupCluster {
  name: String!
}
type postgresqlBackup {
  metadata: metadata
  cluster: postgresqlBackupCluster
  target: String
  status: postgresqlBackupStatus
}
type postgresqlClusterStatusCertificates {
  clientCASecret: String
  expirations: JSONObject
  replicationTLSSecret: String
  serverAltDNSNames: [String]
  serverCASecret: String
  serverTLSSecret: String
}
type postgresqlClusterStatusConditionsItem {
  lastTransitionTime: String!
  message: String!
  observedGeneration: Int
  reason: String!
  status: String!
  type: String!
}
type postgresqlClusterStatusPoolerIntegrationsPgBouncerIntegration {
  secrets: [String]
}
type postgresqlClusterStatusPoolerIntegrations {
  pgBouncerIntegration: postgresqlClusterStatusPoolerIntegrationsPgBouncerIntegration
}
type postgresqlClusterStatusSecretsResourceVersion {
  applicationSecretVersion: String
  barmanEndpointCA: String
  caSecretVersion: String
  clientCaSecretVersion: String
  managedRoleSecretVersion: JSONObject
  metrics: JSONObject
  replicationSecretVersion: String
  serverCaSecretVersion: String
  serverSecretVersion: String
  superuserSecretVersion: String
}
type postgresqlClusterStatusTopology {
  instances: JSONObject
  nodesUsed: Int
  successfullyExtracted: Boolean
}
type postgresqlClusterStatus {
  azurePVCUpdateEnabled: Boolean
  certificates: postgresqlClusterStatusCertificates
  cloudNativePGCommitHash: String
  cloudNativePGOperatorHash: String
  conditions: [postgresqlClusterStatusConditionsItem]
  configMapResourceVersion: JSONObject
  currentPrimary: String
  currentPrimaryFailingSinceTimestamp: String
  currentPrimaryTimestamp: String
  danglingPVC: [String]
  firstRecoverabilityPoint: String
  healthyPVC: [String]
  initializingPVC: [String]
  instanceNames: [String]
  instances: Int
  instancesReportedState: JSONObject
  instancesStatus: JSONObject
  jobCount: Int
  lastFailedBackup: String
  lastSuccessfulBackup: String
  latestGeneratedNode: Int
  managedRolesStatus: JSONObject
  onlineUpdateEnabled: Boolean
  phase: String
  phaseReason: String
  poolerIntegrations: postgresqlClusterStatusPoolerIntegrations
  pvcCount: Int
  readService: String
  readyInstances: Int
  resizingPVC: [String]
  secretsResourceVersion: postgresqlClusterStatusSecretsResourceVersion
  targetPrimary: String
  targetPrimaryTimestamp: String
  timelineID: Int
  topology: postgresqlClusterStatusTopology
  unusablePVC: [String]
  writeService: String
}
input postgresqlClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem {
  key: String!
  operator: String!
  values: [String]
}
input postgresqlClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector {
  matchExpressions: [postgresqlClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem]
  matchLabels: JSONObject
}
input postgresqlClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm {
  labelSelector: postgresqlClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector
  namespaceSelector: postgresqlClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector
  namespaces: [String]
  topologyKey: String!
}
input postgresqlClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem {
  podAffinityTerm: postgresqlClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm!
  weight: Int!
}
input postgresqlClusterSpecAffinityAdditionalPodAffinity {
  preferredDuringSchedulingIgnoredDuringExecution: [postgresqlClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem]
  requiredDuringSchedulingIgnoredDuringExecution: [postgresqlClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm]
}
input postgresqlClusterSpecAffinityAdditionalPodAntiAffinity {
  preferredDuringSchedulingIgnoredDuringExecution: [postgresqlClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem]
  requiredDuringSchedulingIgnoredDuringExecution: [postgresqlClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm]
}
input postgresqlClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchExpressionsItem {
  key: String!
  operator: String!
  values: [String]
}
input postgresqlClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreference {
  matchExpressions: [postgresqlClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchExpressionsItem]
  matchFields: [postgresqlClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchExpressionsItem]
}
input postgresqlClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem {
  preference: postgresqlClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreference!
  weight: Int!
}
input postgresqlClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  nodeSelectorTerms: [postgresqlClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreference!]
}
input postgresqlClusterSpecAffinityNodeAffinity {
  preferredDuringSchedulingIgnoredDuringExecution: [postgresqlClusterSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem]
  requiredDuringSchedulingIgnoredDuringExecution: postgresqlClusterSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
}
input postgresqlClusterSpecAffinityTolerationsItem {
  effect: String
  key: String
  operator: String
  tolerationSeconds: Int
  value: String
}
input postgresqlClusterSpecAffinity {
  additionalPodAffinity: postgresqlClusterSpecAffinityAdditionalPodAffinity
  additionalPodAntiAffinity: postgresqlClusterSpecAffinityAdditionalPodAntiAffinity
  enablePodAntiAffinity: Boolean
  nodeAffinity: postgresqlClusterSpecAffinityNodeAffinity
  nodeSelector: JSONObject
  podAntiAffinityType: String
  tolerations: [postgresqlClusterSpecAffinityTolerationsItem]
  topologyKey: String
}
input postgresqlClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString {
  key: String!
  name: String!
}
input postgresqlClusterSpecBackupBarmanObjectStoreAzureCredentials {
  connectionString: postgresqlClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString
  inheritFromAzureAD: Boolean
  storageAccount: postgresqlClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString
  storageKey: postgresqlClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString
  storageSasToken: postgresqlClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString
}
input postgresqlClusterSpecBackupBarmanObjectStoreData {
  compression: String
  encryption: String
  immediateCheckpoint: Boolean
  jobs: Int
}
input postgresqlClusterSpecBackupBarmanObjectStoreGoogleCredentials {
  applicationCredentials: postgresqlClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString
  gkeEnvironment: Boolean
}
input postgresqlClusterSpecBackupBarmanObjectStoreS3Credentials {
  accessKeyId: postgresqlClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString
  inheritFromIAMRole: Boolean
  region: postgresqlClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString
  secretAccessKey: postgresqlClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString
  sessionToken: postgresqlClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString
}
input postgresqlClusterSpecBackupBarmanObjectStoreWal {
  compression: String
  encryption: String
  maxParallel: Int
}
input postgresqlClusterSpecBackupBarmanObjectStore {
  azureCredentials: postgresqlClusterSpecBackupBarmanObjectStoreAzureCredentials
  data: postgresqlClusterSpecBackupBarmanObjectStoreData
  destinationPath: String!
  endpointCA: postgresqlClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString
  endpointURL: String
  googleCredentials: postgresqlClusterSpecBackupBarmanObjectStoreGoogleCredentials
  historyTags: JSONObject
  s3Credentials: postgresqlClusterSpecBackupBarmanObjectStoreS3Credentials
  serverName: String
  tags: JSONObject
  wal: postgresqlClusterSpecBackupBarmanObjectStoreWal
}
input postgresqlClusterSpecBackup {
  barmanObjectStore: postgresqlClusterSpecBackupBarmanObjectStore
  retentionPolicy: String
  target: String
}
input postgresqlClusterSpecBootstrapInitdbImportSource {
  externalCluster: String!
}
input postgresqlClusterSpecBootstrapInitdbImport {
  databases: [String]!
  postImportApplicationSQL: [String]
  roles: [String]
  schemaOnly: Boolean
  source: postgresqlClusterSpecBootstrapInitdbImportSource!
  type: String!
}
input postgresqlClusterSpecBootstrapInitdbPostInitApplicationSQLRefs {
  configMapRefs: [postgresqlClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString]
  secretRefs: [postgresqlClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString]
}
input postgresqlClusterSpecBootstrapInitdb {
  dataChecksums: Boolean
  database: String
  encoding: String
  import: postgresqlClusterSpecBootstrapInitdbImport
  localeCType: String
  localeCollate: String
  options: [String]
  owner: String
  postInitApplicationSQL: [String]
  postInitApplicationSQLRefs: postgresqlClusterSpecBootstrapInitdbPostInitApplicationSQLRefs
  postInitSQL: [String]
  postInitTemplateSQL: [String]
  secret: postgresqlBackupSpecCluster
  walSegmentSize: Int
}
input postgresqlClusterSpecBootstrapPg_basebackup {
  database: String
  owner: String
  secret: postgresqlBackupSpecCluster
  source: String!
}
input postgresqlClusterSpecBootstrapRecoveryBackup {
  endpointCA: postgresqlClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString
  name: String!
}
input postgresqlClusterSpecBootstrapRecoveryRecoveryTarget {
  backupID: String
  exclusive: Boolean
  targetImmediate: Boolean
  targetLSN: String
  targetName: String
  targetTLI: String
  targetTime: String
  targetXID: String
}
input postgresqlClusterSpecBootstrapRecoveryVolumeSnapshotsStorage {
  apiGroup: String
  kind: String!
  name: String!
}
input postgresqlClusterSpecBootstrapRecoveryVolumeSnapshots {
  storage: postgresqlClusterSpecBootstrapRecoveryVolumeSnapshotsStorage!
  walStorage: postgresqlClusterSpecBootstrapRecoveryVolumeSnapshotsStorage
}
input postgresqlClusterSpecBootstrapRecovery {
  backup: postgresqlClusterSpecBootstrapRecoveryBackup
  database: String
  owner: String
  recoveryTarget: postgresqlClusterSpecBootstrapRecoveryRecoveryTarget
  secret: postgresqlBackupSpecCluster
  source: String
  volumeSnapshots: postgresqlClusterSpecBootstrapRecoveryVolumeSnapshots
}
input postgresqlClusterSpecBootstrap {
  initdb: postgresqlClusterSpecBootstrapInitdb
  pg_basebackup: postgresqlClusterSpecBootstrapPg_basebackup
  recovery: postgresqlClusterSpecBootstrapRecovery
}
input postgresqlClusterSpecCertificates {
  clientCASecret: String
  replicationTLSSecret: String
  serverAltDNSNames: [String]
  serverCASecret: String
  serverTLSSecret: String
}
input postgresqlClusterSpecEnvItemValueFromConfigMapKeyRef {
  key: String!
  name: String
  optional: Boolean
}
input postgresqlClusterSpecEnvItemValueFromFieldRef {
  apiVersion: String
  fieldPath: String!
}
input postgresqlClusterSpecEnvItemValueFromResourceFieldRef {
  containerName: String
  divisor: JSONObject
  resource: String!
}
input postgresqlClusterSpecEnvItemValueFromSecretKeyRef {
  key: String!
  name: String
  optional: Boolean
}
input postgresqlClusterSpecEnvItemValueFrom {
  configMapKeyRef: postgresqlClusterSpecEnvItemValueFromConfigMapKeyRef
  fieldRef: postgresqlClusterSpecEnvItemValueFromFieldRef
  resourceFieldRef: postgresqlClusterSpecEnvItemValueFromResourceFieldRef
  secretKeyRef: postgresqlClusterSpecEnvItemValueFromSecretKeyRef
}
input postgresqlClusterSpecEnvItem {
  name: String!
  value: String
  valueFrom: postgresqlClusterSpecEnvItemValueFrom
}
input postgresqlClusterSpecEnvFromItemConfigMapRef {
  name: String
  optional: Boolean
}
input postgresqlClusterSpecEnvFromItemSecretRef {
  name: String
  optional: Boolean
}
input postgresqlClusterSpecEnvFromItem {
  configMapRef: postgresqlClusterSpecEnvFromItemConfigMapRef
  prefix: String
  secretRef: postgresqlClusterSpecEnvFromItemSecretRef
}
input postgresqlClusterSpecExternalClustersItem {
  barmanObjectStore: postgresqlClusterSpecBackupBarmanObjectStore
  connectionParameters: JSONObject
  name: String!
  password: postgresqlClusterSpecEnvItemValueFromSecretKeyRef
  sslCert: postgresqlClusterSpecEnvItemValueFromSecretKeyRef
  sslKey: postgresqlClusterSpecEnvItemValueFromSecretKeyRef
  sslRootCert: postgresqlClusterSpecEnvItemValueFromSecretKeyRef
}
input postgresqlClusterSpecManagedRolesItem {
  bypassrls: Boolean
  comment: String
  connectionLimit: Int
  createdb: Boolean
  createrole: Boolean
  disablePassword: Boolean
  ensure: String
  inRoles: [String]
  inherit: Boolean
  login: Boolean
  name: String!
  passwordSecret: postgresqlBackupSpecCluster
  replication: Boolean
  superuser: Boolean
  validUntil: String
}
input postgresqlClusterSpecManaged {
  roles: [postgresqlClusterSpecManagedRolesItem]
}
input postgresqlClusterSpecMonitoring {
  customQueriesConfigMap: [postgresqlClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString]
  customQueriesSecret: [postgresqlClusterSpecBackupBarmanObjectStoreAzureCredentialsConnectionString]
  disableDefaultQueries: Boolean
  enablePodMonitor: Boolean
}
input postgresqlClusterSpecNodeMaintenanceWindow {
  inProgress: Boolean!
  reusePVC: Boolean
}
input postgresqlClusterSpecPostgresqlLdapBindAsAuth {
  prefix: String
  suffix: String
}
input postgresqlClusterSpecPostgresqlLdapBindSearchAuth {
  baseDN: String
  bindDN: String
  bindPassword: postgresqlClusterSpecEnvItemValueFromSecretKeyRef
  searchAttribute: String
  searchFilter: String
}
input postgresqlClusterSpecPostgresqlLdap {
  bindAsAuth: postgresqlClusterSpecPostgresqlLdapBindAsAuth
  bindSearchAuth: postgresqlClusterSpecPostgresqlLdapBindSearchAuth
  port: Int
  scheme: String
  server: String
  tls: Boolean
}
input postgresqlClusterSpecPostgresqlSyncReplicaElectionConstraint {
  enabled: Boolean!
  nodeLabelsAntiAffinity: [String]
}
input postgresqlClusterSpecPostgresql {
  ldap: postgresqlClusterSpecPostgresqlLdap
  parameters: JSONObject
  pg_hba: [String]
  promotionTimeout: Int
  shared_preload_libraries: [String]
  syncReplicaElectionConstraint: postgresqlClusterSpecPostgresqlSyncReplicaElectionConstraint
}
input postgresqlClusterSpecProjectedVolumeTemplateSourcesItemConfigMapItemsItem {
  key: String!
  mode: Int
  path: String!
}
input postgresqlClusterSpecProjectedVolumeTemplateSourcesItemConfigMap {
  items: [postgresqlClusterSpecProjectedVolumeTemplateSourcesItemConfigMapItemsItem]
  name: String
  optional: Boolean
}
input postgresqlClusterSpecProjectedVolumeTemplateSourcesItemDownwardAPIItemsItem {
  fieldRef: postgresqlClusterSpecEnvItemValueFromFieldRef
  mode: Int
  path: String!
  resourceFieldRef: postgresqlClusterSpecEnvItemValueFromResourceFieldRef
}
input postgresqlClusterSpecProjectedVolumeTemplateSourcesItemDownwardAPI {
  items: [postgresqlClusterSpecProjectedVolumeTemplateSourcesItemDownwardAPIItemsItem]
}
input postgresqlClusterSpecProjectedVolumeTemplateSourcesItemSecret {
  items: [postgresqlClusterSpecProjectedVolumeTemplateSourcesItemConfigMapItemsItem]
  name: String
  optional: Boolean
}
input postgresqlClusterSpecProjectedVolumeTemplateSourcesItemServiceAccountToken {
  audience: String
  expirationSeconds: Int
  path: String!
}
input postgresqlClusterSpecProjectedVolumeTemplateSourcesItem {
  configMap: postgresqlClusterSpecProjectedVolumeTemplateSourcesItemConfigMap
  downwardAPI: postgresqlClusterSpecProjectedVolumeTemplateSourcesItemDownwardAPI
  secret: postgresqlClusterSpecProjectedVolumeTemplateSourcesItemSecret
  serviceAccountToken: postgresqlClusterSpecProjectedVolumeTemplateSourcesItemServiceAccountToken
}
input postgresqlClusterSpecProjectedVolumeTemplate {
  defaultMode: Int
  sources: [postgresqlClusterSpecProjectedVolumeTemplateSourcesItem]
}
input postgresqlClusterSpecReplica {
  enabled: Boolean
  source: String!
}
input postgresqlClusterSpecReplicationSlotsHighAvailability {
  enabled: Boolean
  slotPrefix: String
}
input postgresqlClusterSpecReplicationSlots {
  highAvailability: postgresqlClusterSpecReplicationSlotsHighAvailability
  updateInterval: Int
}
input postgresqlClusterSpecResourcesClaimsItem {
  name: String!
}
input postgresqlClusterSpecResources {
  claims: [postgresqlClusterSpecResourcesClaimsItem]
  limits: JSONObject
  requests: JSONObject
}
input postgresqlClusterSpecSeccompProfile {
  localhostProfile: String
  type: String!
}
input postgresqlClusterSpecStoragePvcTemplateDataSourceRef {
  apiGroup: String
  kind: String!
  name: String!
  namespace: String
}
input postgresqlClusterSpecStoragePvcTemplate {
  accessModes: [String]
  dataSource: postgresqlClusterSpecBootstrapRecoveryVolumeSnapshotsStorage
  dataSourceRef: postgresqlClusterSpecStoragePvcTemplateDataSourceRef
  resources: postgresqlClusterSpecResources
  selector: postgresqlClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector
  storageClassName: String
  volumeMode: String
  volumeName: String
}
input postgresqlClusterSpecStorage {
  pvcTemplate: postgresqlClusterSpecStoragePvcTemplate
  resizeInUseVolumes: Boolean
  size: String
  storageClass: String
}
input postgresqlClusterSpecTopologySpreadConstraintsItem {
  labelSelector: postgresqlClusterSpecAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector
  matchLabelKeys: [String]
  maxSkew: Int!
  minDomains: Int
  nodeAffinityPolicy: String
  nodeTaintsPolicy: String
  topologyKey: String!
  whenUnsatisfiable: String!
}
input postgresqlClusterSpec {
  affinity: postgresqlClusterSpecAffinity
  backup: postgresqlClusterSpecBackup
  bootstrap: postgresqlClusterSpecBootstrap
  certificates: postgresqlClusterSpecCertificates
  description: String
  enableSuperuserAccess: Boolean
  env: [postgresqlClusterSpecEnvItem]
  envFrom: [postgresqlClusterSpecEnvFromItem]
  externalClusters: [postgresqlClusterSpecExternalClustersItem]
  failoverDelay: Int
  imageName: String
  imagePullPolicy: String
  imagePullSecrets: [postgresqlBackupSpecCluster]
  inheritedMetadata: JSONObject
  instances: Int!
  logLevel: String
  managed: postgresqlClusterSpecManaged
  maxSyncReplicas: Int
  minSyncReplicas: Int
  monitoring: postgresqlClusterSpecMonitoring
  nodeMaintenanceWindow: postgresqlClusterSpecNodeMaintenanceWindow
  postgresGID: Int
  postgresUID: Int
  postgresql: postgresqlClusterSpecPostgresql
  primaryUpdateMethod: String
  primaryUpdateStrategy: String
  priorityClassName: String
  projectedVolumeTemplate: postgresqlClusterSpecProjectedVolumeTemplate
  replica: postgresqlClusterSpecReplica
  replicationSlots: postgresqlClusterSpecReplicationSlots
  resources: postgresqlClusterSpecResources
  schedulerName: String
  seccompProfile: postgresqlClusterSpecSeccompProfile
  serviceAccountTemplate: JSONObject
  startDelay: Int
  stopDelay: Int
  storage: postgresqlClusterSpecStorage
  superuserSecret: postgresqlBackupSpecCluster
  switchoverDelay: Int
  topologySpreadConstraints: [postgresqlClusterSpecTopologySpreadConstraintsItem]
  walStorage: postgresqlClusterSpecStorage
}
type postgresqlClusterAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem {
  key: String!
  operator: String!
  values: [String]
}
type postgresqlClusterAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector {
  matchExpressions: [postgresqlClusterAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelectorMatchExpressionsItem]
  matchLabels: JSONObject
}
type postgresqlClusterAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm {
  labelSelector: postgresqlClusterAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector
  namespaceSelector: postgresqlClusterAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector
  namespaces: [String]
  topologyKey: String!
}
type postgresqlClusterAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem {
  podAffinityTerm: postgresqlClusterAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm!
  weight: Int!
}
type postgresqlClusterAffinityAdditionalPodAffinity {
  preferredDuringSchedulingIgnoredDuringExecution: [postgresqlClusterAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem]
  requiredDuringSchedulingIgnoredDuringExecution: [postgresqlClusterAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm]
}
type postgresqlClusterAffinityAdditionalPodAntiAffinity {
  preferredDuringSchedulingIgnoredDuringExecution: [postgresqlClusterAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem]
  requiredDuringSchedulingIgnoredDuringExecution: [postgresqlClusterAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTerm]
}
type postgresqlClusterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchExpressionsItem {
  key: String!
  operator: String!
  values: [String]
}
type postgresqlClusterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreference {
  matchExpressions: [postgresqlClusterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchExpressionsItem]
  matchFields: [postgresqlClusterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreferenceMatchExpressionsItem]
}
type postgresqlClusterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem {
  preference: postgresqlClusterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreference!
  weight: Int!
}
type postgresqlClusterAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  nodeSelectorTerms: [postgresqlClusterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPreference!]
}
type postgresqlClusterAffinityNodeAffinity {
  preferredDuringSchedulingIgnoredDuringExecution: [postgresqlClusterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionItem]
  requiredDuringSchedulingIgnoredDuringExecution: postgresqlClusterAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
}
type postgresqlClusterAffinityTolerationsItem {
  effect: String
  key: String
  operator: String
  tolerationSeconds: Int
  value: String
}
type postgresqlClusterAffinity {
  additionalPodAffinity: postgresqlClusterAffinityAdditionalPodAffinity
  additionalPodAntiAffinity: postgresqlClusterAffinityAdditionalPodAntiAffinity
  enablePodAntiAffinity: Boolean
  nodeAffinity: postgresqlClusterAffinityNodeAffinity
  nodeSelector: JSONObject
  podAntiAffinityType: String
  tolerations: [postgresqlClusterAffinityTolerationsItem]
  topologyKey: String
}
type postgresqlClusterBackupBarmanObjectStoreData {
  compression: String
  encryption: String
  immediateCheckpoint: Boolean
  jobs: Int
}
type postgresqlClusterBackupBarmanObjectStoreWal {
  compression: String
  encryption: String
  maxParallel: Int
}
type postgresqlClusterBackupBarmanObjectStore {
  azureCredentials: postgresqlBackupStatusAzureCredentials
  data: postgresqlClusterBackupBarmanObjectStoreData
  destinationPath: String!
  endpointCA: postgresqlBackupStatusAzureCredentialsConnectionString
  endpointURL: String
  googleCredentials: postgresqlBackupStatusGoogleCredentials
  historyTags: JSONObject
  s3Credentials: postgresqlBackupStatusS3Credentials
  serverName: String
  tags: JSONObject
  wal: postgresqlClusterBackupBarmanObjectStoreWal
}
type postgresqlClusterBackup {
  barmanObjectStore: postgresqlClusterBackupBarmanObjectStore
  retentionPolicy: String
  target: String
}
type postgresqlClusterBootstrapInitdbImportSource {
  externalCluster: String!
}
type postgresqlClusterBootstrapInitdbImport {
  databases: [String]!
  postImportApplicationSQL: [String]
  roles: [String]
  schemaOnly: Boolean
  source: postgresqlClusterBootstrapInitdbImportSource!
  type: String!
}
type postgresqlClusterBootstrapInitdbPostInitApplicationSQLRefs {
  configMapRefs: [postgresqlBackupStatusAzureCredentialsConnectionString]
  secretRefs: [postgresqlBackupStatusAzureCredentialsConnectionString]
}
type postgresqlClusterBootstrapInitdb {
  dataChecksums: Boolean
  database: String
  encoding: String
  import: postgresqlClusterBootstrapInitdbImport
  localeCType: String
  localeCollate: String
  options: [String]
  owner: String
  postInitApplicationSQL: [String]
  postInitApplicationSQLRefs: postgresqlClusterBootstrapInitdbPostInitApplicationSQLRefs
  postInitSQL: [String]
  postInitTemplateSQL: [String]
  secret: postgresqlBackupCluster
  walSegmentSize: Int
}
type postgresqlClusterBootstrapPg_basebackup {
  database: String
  owner: String
  secret: postgresqlBackupCluster
  source: String!
}
type postgresqlClusterBootstrapRecoveryBackup {
  endpointCA: postgresqlBackupStatusAzureCredentialsConnectionString
  name: String!
}
type postgresqlClusterBootstrapRecoveryRecoveryTarget {
  backupID: String
  exclusive: Boolean
  targetImmediate: Boolean
  targetLSN: String
  targetName: String
  targetTLI: String
  targetTime: String
  targetXID: String
}
type postgresqlClusterBootstrapRecoveryVolumeSnapshotsStorage {
  apiGroup: String
  kind: String!
  name: String!
}
type postgresqlClusterBootstrapRecoveryVolumeSnapshots {
  storage: postgresqlClusterBootstrapRecoveryVolumeSnapshotsStorage!
  walStorage: postgresqlClusterBootstrapRecoveryVolumeSnapshotsStorage
}
type postgresqlClusterBootstrapRecovery {
  backup: postgresqlClusterBootstrapRecoveryBackup
  database: String
  owner: String
  recoveryTarget: postgresqlClusterBootstrapRecoveryRecoveryTarget
  secret: postgresqlBackupCluster
  source: String
  volumeSnapshots: postgresqlClusterBootstrapRecoveryVolumeSnapshots
}
type postgresqlClusterBootstrap {
  initdb: postgresqlClusterBootstrapInitdb
  pg_basebackup: postgresqlClusterBootstrapPg_basebackup
  recovery: postgresqlClusterBootstrapRecovery
}
type postgresqlClusterCertificates {
  clientCASecret: String
  replicationTLSSecret: String
  serverAltDNSNames: [String]
  serverCASecret: String
  serverTLSSecret: String
}
type postgresqlClusterEnvItemValueFromConfigMapKeyRef {
  key: String!
  name: String
  optional: Boolean
}
type postgresqlClusterEnvItemValueFromFieldRef {
  apiVersion: String
  fieldPath: String!
}
type postgresqlClusterEnvItemValueFromResourceFieldRef {
  containerName: String
  divisor: JSONObject
  resource: String!
}
type postgresqlClusterEnvItemValueFromSecretKeyRef {
  key: String!
  name: String
  optional: Boolean
}
type postgresqlClusterEnvItemValueFrom {
  configMapKeyRef: postgresqlClusterEnvItemValueFromConfigMapKeyRef
  fieldRef: postgresqlClusterEnvItemValueFromFieldRef
  resourceFieldRef: postgresqlClusterEnvItemValueFromResourceFieldRef
  secretKeyRef: postgresqlClusterEnvItemValueFromSecretKeyRef
}
type postgresqlClusterEnvItem {
  name: String!
  value: String
  valueFrom: postgresqlClusterEnvItemValueFrom
}
type postgresqlClusterEnvFromItemConfigMapRef {
  name: String
  optional: Boolean
}
type postgresqlClusterEnvFromItemSecretRef {
  name: String
  optional: Boolean
}
type postgresqlClusterEnvFromItem {
  configMapRef: postgresqlClusterEnvFromItemConfigMapRef
  prefix: String
  secretRef: postgresqlClusterEnvFromItemSecretRef
}
type postgresqlClusterExternalClustersItem {
  barmanObjectStore: postgresqlClusterBackupBarmanObjectStore
  connectionParameters: JSONObject
  name: String!
  password: postgresqlClusterEnvItemValueFromSecretKeyRef
  sslCert: postgresqlClusterEnvItemValueFromSecretKeyRef
  sslKey: postgresqlClusterEnvItemValueFromSecretKeyRef
  sslRootCert: postgresqlClusterEnvItemValueFromSecretKeyRef
}
type postgresqlClusterManagedRolesItem {
  bypassrls: Boolean
  comment: String
  connectionLimit: Int
  createdb: Boolean
  createrole: Boolean
  disablePassword: Boolean
  ensure: String
  inRoles: [String]
  inherit: Boolean
  login: Boolean
  name: String!
  passwordSecret: postgresqlBackupCluster
  replication: Boolean
  superuser: Boolean
  validUntil: String
}
type postgresqlClusterManaged {
  roles: [postgresqlClusterManagedRolesItem]
}
type postgresqlClusterMonitoring {
  customQueriesConfigMap: [postgresqlBackupStatusAzureCredentialsConnectionString]
  customQueriesSecret: [postgresqlBackupStatusAzureCredentialsConnectionString]
  disableDefaultQueries: Boolean
  enablePodMonitor: Boolean
}
type postgresqlClusterNodeMaintenanceWindow {
  inProgress: Boolean!
  reusePVC: Boolean
}
type postgresqlClusterPostgresqlLdapBindAsAuth {
  prefix: String
  suffix: String
}
type postgresqlClusterPostgresqlLdapBindSearchAuth {
  baseDN: String
  bindDN: String
  bindPassword: postgresqlClusterEnvItemValueFromSecretKeyRef
  searchAttribute: String
  searchFilter: String
}
type postgresqlClusterPostgresqlLdap {
  bindAsAuth: postgresqlClusterPostgresqlLdapBindAsAuth
  bindSearchAuth: postgresqlClusterPostgresqlLdapBindSearchAuth
  port: Int
  scheme: String
  server: String
  tls: Boolean
}
type postgresqlClusterPostgresqlSyncReplicaElectionConstraint {
  enabled: Boolean!
  nodeLabelsAntiAffinity: [String]
}
type postgresqlClusterPostgresql {
  ldap: postgresqlClusterPostgresqlLdap
  parameters: JSONObject
  pg_hba: [String]
  promotionTimeout: Int
  shared_preload_libraries: [String]
  syncReplicaElectionConstraint: postgresqlClusterPostgresqlSyncReplicaElectionConstraint
}
type postgresqlClusterProjectedVolumeTemplateSourcesItemConfigMapItemsItem {
  key: String!
  mode: Int
  path: String!
}
type postgresqlClusterProjectedVolumeTemplateSourcesItemConfigMap {
  items: [postgresqlClusterProjectedVolumeTemplateSourcesItemConfigMapItemsItem]
  name: String
  optional: Boolean
}
type postgresqlClusterProjectedVolumeTemplateSourcesItemDownwardAPIItemsItem {
  fieldRef: postgresqlClusterEnvItemValueFromFieldRef
  mode: Int
  path: String!
  resourceFieldRef: postgresqlClusterEnvItemValueFromResourceFieldRef
}
type postgresqlClusterProjectedVolumeTemplateSourcesItemDownwardAPI {
  items: [postgresqlClusterProjectedVolumeTemplateSourcesItemDownwardAPIItemsItem]
}
type postgresqlClusterProjectedVolumeTemplateSourcesItemSecret {
  items: [postgresqlClusterProjectedVolumeTemplateSourcesItemConfigMapItemsItem]
  name: String
  optional: Boolean
}
type postgresqlClusterProjectedVolumeTemplateSourcesItemServiceAccountToken {
  audience: String
  expirationSeconds: Int
  path: String!
}
type postgresqlClusterProjectedVolumeTemplateSourcesItem {
  configMap: postgresqlClusterProjectedVolumeTemplateSourcesItemConfigMap
  downwardAPI: postgresqlClusterProjectedVolumeTemplateSourcesItemDownwardAPI
  secret: postgresqlClusterProjectedVolumeTemplateSourcesItemSecret
  serviceAccountToken: postgresqlClusterProjectedVolumeTemplateSourcesItemServiceAccountToken
}
type postgresqlClusterProjectedVolumeTemplate {
  defaultMode: Int
  sources: [postgresqlClusterProjectedVolumeTemplateSourcesItem]
}
type postgresqlClusterReplica {
  enabled: Boolean
  source: String!
}
type postgresqlClusterReplicationSlotsHighAvailability {
  enabled: Boolean
  slotPrefix: String
}
type postgresqlClusterReplicationSlots {
  highAvailability: postgresqlClusterReplicationSlotsHighAvailability
  updateInterval: Int
}
type postgresqlClusterResourcesClaimsItem {
  name: String!
}
type postgresqlClusterResources {
  claims: [postgresqlClusterResourcesClaimsItem]
  limits: JSONObject
  requests: JSONObject
}
type postgresqlClusterSeccompProfile {
  localhostProfile: String
  type: String!
}
type postgresqlClusterStoragePvcTemplateDataSourceRef {
  apiGroup: String
  kind: String!
  name: String!
  namespace: String
}
type postgresqlClusterStoragePvcTemplate {
  accessModes: [String]
  dataSource: postgresqlClusterBootstrapRecoveryVolumeSnapshotsStorage
  dataSourceRef: postgresqlClusterStoragePvcTemplateDataSourceRef
  resources: postgresqlClusterResources
  selector: postgresqlClusterAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector
  storageClassName: String
  volumeMode: String
  volumeName: String
}
type postgresqlClusterStorage {
  pvcTemplate: postgresqlClusterStoragePvcTemplate
  resizeInUseVolumes: Boolean
  size: String
  storageClass: String
}
type postgresqlClusterTopologySpreadConstraintsItem {
  labelSelector: postgresqlClusterAffinityAdditionalPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionItemPodAffinityTermLabelSelector
  matchLabelKeys: [String]
  maxSkew: Int!
  minDomains: Int
  nodeAffinityPolicy: String
  nodeTaintsPolicy: String
  topologyKey: String!
  whenUnsatisfiable: String!
}
type postgresqlCluster {
  metadata: metadata
  affinity: postgresqlClusterAffinity
  backup: postgresqlClusterBackup
  bootstrap: postgresqlClusterBootstrap
  certificates: postgresqlClusterCertificates
  description: String
  enableSuperuserAccess: Boolean
  env: [postgresqlClusterEnvItem]
  envFrom: [postgresqlClusterEnvFromItem]
  externalClusters: [postgresqlClusterExternalClustersItem]
  failoverDelay: Int
  imageName: String
  imagePullPolicy: String
  imagePullSecrets: [postgresqlBackupCluster]
  inheritedMetadata: JSONObject
  instances: Int!
  logLevel: String
  managed: postgresqlClusterManaged
  maxSyncReplicas: Int
  minSyncReplicas: Int
  monitoring: postgresqlClusterMonitoring
  nodeMaintenanceWindow: postgresqlClusterNodeMaintenanceWindow
  postgresGID: Int
  postgresUID: Int
  postgresql: postgresqlClusterPostgresql
  primaryUpdateMethod: String
  primaryUpdateStrategy: String
  priorityClassName: String
  projectedVolumeTemplate: postgresqlClusterProjectedVolumeTemplate
  replica: postgresqlClusterReplica
  replicationSlots: postgresqlClusterReplicationSlots
  resources: postgresqlClusterResources
  schedulerName: String
  seccompProfile: postgresqlClusterSeccompProfile
  serviceAccountTemplate: JSONObject
  startDelay: Int
  stopDelay: Int
  storage: postgresqlClusterStorage
  superuserSecret: postgresqlBackupCluster
  switchoverDelay: Int
  topologySpreadConstraints: [postgresqlClusterTopologySpreadConstraintsItem]
  walStorage: postgresqlClusterStorage
  status: postgresqlClusterStatus
}
type postgresqlPoolerStatusSecretsClientCA {
  name: String
  version: String
}
type postgresqlPoolerStatusSecretsPgBouncerSecrets {
  authQuery: postgresqlPoolerStatusSecretsClientCA
}
type postgresqlPoolerStatusSecrets {
  clientCA: postgresqlPoolerStatusSecretsClientCA
  pgBouncerSecrets: postgresqlPoolerStatusSecretsPgBouncerSecrets
  serverCA: postgresqlPoolerStatusSecretsClientCA
  serverTLS: postgresqlPoolerStatusSecretsClientCA
}
type postgresqlPoolerStatus {
  instances: Int
  secrets: postgresqlPoolerStatusSecrets
}
input postgresqlPoolerSpecDeploymentStrategy {
  rollingUpdate: JSONObject
  type: String
}
input postgresqlPoolerSpecMonitoring {
  enablePodMonitor: Boolean
}
input postgresqlPoolerSpecPgbouncer {
  authQuery: String
  authQuerySecret: postgresqlBackupSpecCluster
  parameters: JSONObject
  paused: Boolean
  pg_hba: [String]
  poolMode: String!
}
input postgresqlPoolerSpecTemplateSpecAffinity {
  nodeAffinity: postgresqlClusterSpecAffinityNodeAffinity
  podAffinity: postgresqlClusterSpecAffinityAdditionalPodAffinity
  podAntiAffinity: postgresqlClusterSpecAffinityAdditionalPodAntiAffinity
}
input postgresqlPoolerSpecTemplateSpecContainersItemLifecyclePostStartExec {
  command: [String]
}
input postgresqlPoolerSpecTemplateSpecContainersItemLifecyclePostStartHttpGetHttpHeadersItem {
  name: String!
  value: String!
}
input postgresqlPoolerSpecTemplateSpecContainersItemLifecyclePostStartHttpGet {
  host: String
  httpHeaders: [postgresqlPoolerSpecTemplateSpecContainersItemLifecyclePostStartHttpGetHttpHeadersItem]
  path: String
  port: JSONObject!
  scheme: String
}
input postgresqlPoolerSpecTemplateSpecContainersItemLifecyclePostStartTcpSocket {
  host: String
  port: JSONObject!
}
input postgresqlPoolerSpecTemplateSpecContainersItemLifecyclePostStart {
  exec: postgresqlPoolerSpecTemplateSpecContainersItemLifecyclePostStartExec
  httpGet: postgresqlPoolerSpecTemplateSpecContainersItemLifecyclePostStartHttpGet
  tcpSocket: postgresqlPoolerSpecTemplateSpecContainersItemLifecyclePostStartTcpSocket
}
input postgresqlPoolerSpecTemplateSpecContainersItemLifecycle {
  postStart: postgresqlPoolerSpecTemplateSpecContainersItemLifecyclePostStart
  preStop: postgresqlPoolerSpecTemplateSpecContainersItemLifecyclePostStart
}
input postgresqlPoolerSpecTemplateSpecContainersItemLivenessProbeGrpc {
  port: Int!
  service: String
}
input postgresqlPoolerSpecTemplateSpecContainersItemLivenessProbe {
  exec: postgresqlPoolerSpecTemplateSpecContainersItemLifecyclePostStartExec
  failureThreshold: Int
  grpc: postgresqlPoolerSpecTemplateSpecContainersItemLivenessProbeGrpc
  httpGet: postgresqlPoolerSpecTemplateSpecContainersItemLifecyclePostStartHttpGet
  initialDelaySeconds: Int
  periodSeconds: Int
  successThreshold: Int
  tcpSocket: postgresqlPoolerSpecTemplateSpecContainersItemLifecyclePostStartTcpSocket
  terminationGracePeriodSeconds: Int
  timeoutSeconds: Int
}
input postgresqlPoolerSpecTemplateSpecContainersItemPortsItem {
  containerPort: Int!
  hostIP: String
  hostPort: Int
  name: String
  protocol: String
}
input postgresqlPoolerSpecTemplateSpecContainersItemResizePolicyItem {
  resourceName: String!
  restartPolicy: String!
}
input postgresqlPoolerSpecTemplateSpecContainersItemSecurityContextCapabilities {
  add: [String]
  drop: [String]
}
input postgresqlPoolerSpecTemplateSpecContainersItemSecurityContextSeLinuxOptions {
  level: String
  role: String
  type: String
  user: String
}
input postgresqlPoolerSpecTemplateSpecContainersItemSecurityContextWindowsOptions {
  gmsaCredentialSpec: String
  gmsaCredentialSpecName: String
  hostProcess: Boolean
  runAsUserName: String
}
input postgresqlPoolerSpecTemplateSpecContainersItemSecurityContext {
  allowPrivilegeEscalation: Boolean
  capabilities: postgresqlPoolerSpecTemplateSpecContainersItemSecurityContextCapabilities
  privileged: Boolean
  procMount: String
  readOnlyRootFilesystem: Boolean
  runAsGroup: Int
  runAsNonRoot: Boolean
  runAsUser: Int
  seLinuxOptions: postgresqlPoolerSpecTemplateSpecContainersItemSecurityContextSeLinuxOptions
  seccompProfile: postgresqlClusterSpecSeccompProfile
  windowsOptions: postgresqlPoolerSpecTemplateSpecContainersItemSecurityContextWindowsOptions
}
input postgresqlPoolerSpecTemplateSpecContainersItemVolumeDevicesItem {
  devicePath: String!
  name: String!
}
input postgresqlPoolerSpecTemplateSpecContainersItemVolumeMountsItem {
  mountPath: String!
  mountPropagation: String
  name: String!
  readOnly: Boolean
  subPath: String
  subPathExpr: String
}
input postgresqlPoolerSpecTemplateSpecContainersItem {
  args: [String]
  command: [String]
  env: [postgresqlClusterSpecEnvItem]
  envFrom: [postgresqlClusterSpecEnvFromItem]
  image: String
  imagePullPolicy: String
  lifecycle: postgresqlPoolerSpecTemplateSpecContainersItemLifecycle
  livenessProbe: postgresqlPoolerSpecTemplateSpecContainersItemLivenessProbe
  name: String!
  ports: [postgresqlPoolerSpecTemplateSpecContainersItemPortsItem]
  readinessProbe: postgresqlPoolerSpecTemplateSpecContainersItemLivenessProbe
  resizePolicy: [postgresqlPoolerSpecTemplateSpecContainersItemResizePolicyItem]
  resources: postgresqlClusterSpecResources
  securityContext: postgresqlPoolerSpecTemplateSpecContainersItemSecurityContext
  startupProbe: postgresqlPoolerSpecTemplateSpecContainersItemLivenessProbe
  stdin: Boolean
  stdinOnce: Boolean
  terminationMessagePath: String
  terminationMessagePolicy: String
  tty: Boolean
  volumeDevices: [postgresqlPoolerSpecTemplateSpecContainersItemVolumeDevicesItem]
  volumeMounts: [postgresqlPoolerSpecTemplateSpecContainersItemVolumeMountsItem]
  workingDir: String
}
input postgresqlPoolerSpecTemplateSpecDnsConfigOptionsItem {
  name: String
  value: String
}
input postgresqlPoolerSpecTemplateSpecDnsConfig {
  nameservers: [String]
  options: [postgresqlPoolerSpecTemplateSpecDnsConfigOptionsItem]
  searches: [String]
}
input postgresqlPoolerSpecTemplateSpecEphemeralContainersItem {
  args: [String]
  command: [String]
  env: [postgresqlClusterSpecEnvItem]
  envFrom: [postgresqlClusterSpecEnvFromItem]
  image: String
  imagePullPolicy: String
  lifecycle: postgresqlPoolerSpecTemplateSpecContainersItemLifecycle
  livenessProbe: postgresqlPoolerSpecTemplateSpecContainersItemLivenessProbe
  name: String!
  ports: [postgresqlPoolerSpecTemplateSpecContainersItemPortsItem]
  readinessProbe: postgresqlPoolerSpecTemplateSpecContainersItemLivenessProbe
  resizePolicy: [postgresqlPoolerSpecTemplateSpecContainersItemResizePolicyItem]
  resources: postgresqlClusterSpecResources
  securityContext: postgresqlPoolerSpecTemplateSpecContainersItemSecurityContext
  startupProbe: postgresqlPoolerSpecTemplateSpecContainersItemLivenessProbe
  stdin: Boolean
  stdinOnce: Boolean
  targetContainerName: String
  terminationMessagePath: String
  terminationMessagePolicy: String
  tty: Boolean
  volumeDevices: [postgresqlPoolerSpecTemplateSpecContainersItemVolumeDevicesItem]
  volumeMounts: [postgresqlPoolerSpecTemplateSpecContainersItemVolumeMountsItem]
  workingDir: String
}
input postgresqlPoolerSpecTemplateSpecHostAliasesItem {
  hostnames: [String]
  ip: String
}
input postgresqlPoolerSpecTemplateSpecImagePullSecretsItem {
  name: String
}
input postgresqlPoolerSpecTemplateSpecOs {
  name: String!
}
input postgresqlPoolerSpecTemplateSpecReadinessGatesItem {
  conditionType: String!
}
input postgresqlPoolerSpecTemplateSpecResourceClaimsItemSource {
  resourceClaimName: String
  resourceClaimTemplateName: String
}
input postgresqlPoolerSpecTemplateSpecResourceClaimsItem {
  name: String!
  source: postgresqlPoolerSpecTemplateSpecResourceClaimsItemSource
}
input postgresqlPoolerSpecTemplateSpecSchedulingGatesItem {
  name: String!
}
input postgresqlPoolerSpecTemplateSpecSecurityContextSysctlsItem {
  name: String!
  value: String!
}
input postgresqlPoolerSpecTemplateSpecSecurityContext {
  fsGroup: Int
  fsGroupChangePolicy: String
  runAsGroup: Int
  runAsNonRoot: Boolean
  runAsUser: Int
  seLinuxOptions: postgresqlPoolerSpecTemplateSpecContainersItemSecurityContextSeLinuxOptions
  seccompProfile: postgresqlClusterSpecSeccompProfile
  supplementalGroups: [Int]
  sysctls: [postgresqlPoolerSpecTemplateSpecSecurityContextSysctlsItem]
  windowsOptions: postgresqlPoolerSpecTemplateSpecContainersItemSecurityContextWindowsOptions
}
input postgresqlPoolerSpecTemplateSpecVolumesItemAwsElasticBlockStore {
  fsType: String
  partition: Int
  readOnly: Boolean
  volumeID: String!
}
input postgresqlPoolerSpecTemplateSpecVolumesItemAzureDisk {
  cachingMode: String
  diskName: String!
  diskURI: String!
  fsType: String
  kind: String
  readOnly: Boolean
}
input postgresqlPoolerSpecTemplateSpecVolumesItemAzureFile {
  readOnly: Boolean
  secretName: String!
  shareName: String!
}
input postgresqlPoolerSpecTemplateSpecVolumesItemCephfs {
  monitors: [String]!
  path: String
  readOnly: Boolean
  secretFile: String
  secretRef: postgresqlPoolerSpecTemplateSpecImagePullSecretsItem
  user: String
}
input postgresqlPoolerSpecTemplateSpecVolumesItemCinder {
  fsType: String
  readOnly: Boolean
  secretRef: postgresqlPoolerSpecTemplateSpecImagePullSecretsItem
  volumeID: String!
}
input postgresqlPoolerSpecTemplateSpecVolumesItemConfigMap {
  defaultMode: Int
  items: [postgresqlClusterSpecProjectedVolumeTemplateSourcesItemConfigMapItemsItem]
  name: String
  optional: Boolean
}
input postgresqlPoolerSpecTemplateSpecVolumesItemCsi {
  driver: String!
  fsType: String
  nodePublishSecretRef: postgresqlPoolerSpecTemplateSpecImagePullSecretsItem
  readOnly: Boolean
  volumeAttributes: JSONObject
}
input postgresqlPoolerSpecTemplateSpecVolumesItemDownwardAPI {
  defaultMode: Int
  items: [postgresqlClusterSpecProjectedVolumeTemplateSourcesItemDownwardAPIItemsItem]
}
input postgresqlPoolerSpecTemplateSpecVolumesItemEmptyDir {
  medium: String
  sizeLimit: JSONObject
}
input postgresqlPoolerSpecTemplateSpecVolumesItemEphemeralVolumeClaimTemplate {
  metadata: JSONObject
  spec: postgresqlClusterSpecStoragePvcTemplate!
}
input postgresqlPoolerSpecTemplateSpecVolumesItemEphemeral {
  volumeClaimTemplate: postgresqlPoolerSpecTemplateSpecVolumesItemEphemeralVolumeClaimTemplate
}
input postgresqlPoolerSpecTemplateSpecVolumesItemFc {
  fsType: String
  lun: Int
  readOnly: Boolean
  targetWWNs: [String]
  wwids: [String]
}
input postgresqlPoolerSpecTemplateSpecVolumesItemFlexVolume {
  driver: String!
  fsType: String
  options: JSONObject
  readOnly: Boolean
  secretRef: postgresqlPoolerSpecTemplateSpecImagePullSecretsItem
}
input postgresqlPoolerSpecTemplateSpecVolumesItemFlocker {
  datasetName: String
  datasetUUID: String
}
input postgresqlPoolerSpecTemplateSpecVolumesItemGcePersistentDisk {
  fsType: String
  partition: Int
  pdName: String!
  readOnly: Boolean
}
input postgresqlPoolerSpecTemplateSpecVolumesItemGitRepo {
  directory: String
  repository: String!
  revision: String
}
input postgresqlPoolerSpecTemplateSpecVolumesItemGlusterfs {
  endpoints: String!
  path: String!
  readOnly: Boolean
}
input postgresqlPoolerSpecTemplateSpecVolumesItemHostPath {
  path: String!
  type: String
}
input postgresqlPoolerSpecTemplateSpecVolumesItemIscsi {
  chapAuthDiscovery: Boolean
  chapAuthSession: Boolean
  fsType: String
  initiatorName: String
  iqn: String!
  iscsiInterface: String
  lun: Int!
  portals: [String]
  readOnly: Boolean
  secretRef: postgresqlPoolerSpecTemplateSpecImagePullSecretsItem
  targetPortal: String!
}
input postgresqlPoolerSpecTemplateSpecVolumesItemNfs {
  path: String!
  readOnly: Boolean
  server: String!
}
input postgresqlPoolerSpecTemplateSpecVolumesItemPersistentVolumeClaim {
  claimName: String!
  readOnly: Boolean
}
input postgresqlPoolerSpecTemplateSpecVolumesItemPhotonPersistentDisk {
  fsType: String
  pdID: String!
}
input postgresqlPoolerSpecTemplateSpecVolumesItemPortworxVolume {
  fsType: String
  readOnly: Boolean
  volumeID: String!
}
input postgresqlPoolerSpecTemplateSpecVolumesItemQuobyte {
  group: String
  readOnly: Boolean
  registry: String!
  tenant: String
  user: String
  volume: String!
}
input postgresqlPoolerSpecTemplateSpecVolumesItemRbd {
  fsType: String
  image: String!
  keyring: String
  monitors: [String]!
  pool: String
  readOnly: Boolean
  secretRef: postgresqlPoolerSpecTemplateSpecImagePullSecretsItem
  user: String
}
input postgresqlPoolerSpecTemplateSpecVolumesItemScaleIO {
  fsType: String
  gateway: String!
  protectionDomain: String
  readOnly: Boolean
  secretRef: postgresqlPoolerSpecTemplateSpecImagePullSecretsItem!
  sslEnabled: Boolean
  storageMode: String
  storagePool: String
  system: String!
  volumeName: String
}
input postgresqlPoolerSpecTemplateSpecVolumesItemSecret {
  defaultMode: Int
  items: [postgresqlClusterSpecProjectedVolumeTemplateSourcesItemConfigMapItemsItem]
  optional: Boolean
  secretName: String
}
input postgresqlPoolerSpecTemplateSpecVolumesItemStorageos {
  fsType: String
  readOnly: Boolean
  secretRef: postgresqlPoolerSpecTemplateSpecImagePullSecretsItem
  volumeName: String
  volumeNamespace: String
}
input postgresqlPoolerSpecTemplateSpecVolumesItemVsphereVolume {
  fsType: String
  storagePolicyID: String
  storagePolicyName: String
  volumePath: String!
}
input postgresqlPoolerSpecTemplateSpecVolumesItem {
  awsElasticBlockStore: postgresqlPoolerSpecTemplateSpecVolumesItemAwsElasticBlockStore
  azureDisk: postgresqlPoolerSpecTemplateSpecVolumesItemAzureDisk
  azureFile: postgresqlPoolerSpecTemplateSpecVolumesItemAzureFile
  cephfs: postgresqlPoolerSpecTemplateSpecVolumesItemCephfs
  cinder: postgresqlPoolerSpecTemplateSpecVolumesItemCinder
  configMap: postgresqlPoolerSpecTemplateSpecVolumesItemConfigMap
  csi: postgresqlPoolerSpecTemplateSpecVolumesItemCsi
  downwardAPI: postgresqlPoolerSpecTemplateSpecVolumesItemDownwardAPI
  emptyDir: postgresqlPoolerSpecTemplateSpecVolumesItemEmptyDir
  ephemeral: postgresqlPoolerSpecTemplateSpecVolumesItemEphemeral
  fc: postgresqlPoolerSpecTemplateSpecVolumesItemFc
  flexVolume: postgresqlPoolerSpecTemplateSpecVolumesItemFlexVolume
  flocker: postgresqlPoolerSpecTemplateSpecVolumesItemFlocker
  gcePersistentDisk: postgresqlPoolerSpecTemplateSpecVolumesItemGcePersistentDisk
  gitRepo: postgresqlPoolerSpecTemplateSpecVolumesItemGitRepo
  glusterfs: postgresqlPoolerSpecTemplateSpecVolumesItemGlusterfs
  hostPath: postgresqlPoolerSpecTemplateSpecVolumesItemHostPath
  iscsi: postgresqlPoolerSpecTemplateSpecVolumesItemIscsi
  name: String!
  nfs: postgresqlPoolerSpecTemplateSpecVolumesItemNfs
  persistentVolumeClaim: postgresqlPoolerSpecTemplateSpecVolumesItemPersistentVolumeClaim
  photonPersistentDisk: postgresqlPoolerSpecTemplateSpecVolumesItemPhotonPersistentDisk
  portworxVolume: postgresqlPoolerSpecTemplateSpecVolumesItemPortworxVolume
  projected: postgresqlClusterSpecProjectedVolumeTemplate
  quobyte: postgresqlPoolerSpecTemplateSpecVolumesItemQuobyte
  rbd: postgresqlPoolerSpecTemplateSpecVolumesItemRbd
  scaleIO: postgresqlPoolerSpecTemplateSpecVolumesItemScaleIO
  secret: postgresqlPoolerSpecTemplateSpecVolumesItemSecret
  storageos: postgresqlPoolerSpecTemplateSpecVolumesItemStorageos
  vsphereVolume: postgresqlPoolerSpecTemplateSpecVolumesItemVsphereVolume
}
input postgresqlPoolerSpecTemplateSpec {
  activeDeadlineSeconds: Int
  affinity: postgresqlPoolerSpecTemplateSpecAffinity
  automountServiceAccountToken: Boolean
  containers: [postgresqlPoolerSpecTemplateSpecContainersItem]!
  dnsConfig: postgresqlPoolerSpecTemplateSpecDnsConfig
  dnsPolicy: String
  enableServiceLinks: Boolean
  ephemeralContainers: [postgresqlPoolerSpecTemplateSpecEphemeralContainersItem]
  hostAliases: [postgresqlPoolerSpecTemplateSpecHostAliasesItem]
  hostIPC: Boolean
  hostNetwork: Boolean
  hostPID: Boolean
  hostUsers: Boolean
  hostname: String
  imagePullSecrets: [postgresqlPoolerSpecTemplateSpecImagePullSecretsItem]
  initContainers: [postgresqlPoolerSpecTemplateSpecContainersItem]
  nodeName: String
  nodeSelector: JSONObject
  os: postgresqlPoolerSpecTemplateSpecOs
  overhead: JSONObject
  preemptionPolicy: String
  priority: Int
  priorityClassName: String
  readinessGates: [postgresqlPoolerSpecTemplateSpecReadinessGatesItem]
  resourceClaims: [postgresqlPoolerSpecTemplateSpecResourceClaimsItem]
  restartPolicy: String
  runtimeClassName: String
  schedulerName: String
  schedulingGates: [postgresqlPoolerSpecTemplateSpecSchedulingGatesItem]
  securityContext: postgresqlPoolerSpecTemplateSpecSecurityContext
  serviceAccount: String
  serviceAccountName: String
  setHostnameAsFQDN: Boolean
  shareProcessNamespace: Boolean
  subdomain: String
  terminationGracePeriodSeconds: Int
  tolerations: [postgresqlClusterSpecAffinityTolerationsItem]
  topologySpreadConstraints: [postgresqlClusterSpecTopologySpreadConstraintsItem]
  volumes: [postgresqlPoolerSpecTemplateSpecVolumesItem]
}
input postgresqlPoolerSpecTemplate {
  metadata: JSONObject
  spec: postgresqlPoolerSpecTemplateSpec
}
input postgresqlPoolerSpec {
  cluster: postgresqlBackupSpecCluster!
  deploymentStrategy: postgresqlPoolerSpecDeploymentStrategy
  instances: Int!
  monitoring: postgresqlPoolerSpecMonitoring
  pgbouncer: postgresqlPoolerSpecPgbouncer!
  template: postgresqlPoolerSpecTemplate
  type: String!
}
type postgresqlPoolerDeploymentStrategy {
  rollingUpdate: JSONObject
  type: String
}
type postgresqlPoolerMonitoring {
  enablePodMonitor: Boolean
}
type postgresqlPoolerPgbouncer {
  authQuery: String
  authQuerySecret: postgresqlBackupCluster
  parameters: JSONObject
  paused: Boolean
  pg_hba: [String]
  poolMode: String!
}
type postgresqlPoolerTemplateSpecAffinity {
  nodeAffinity: postgresqlClusterAffinityNodeAffinity
  podAffinity: postgresqlClusterAffinityAdditionalPodAffinity
  podAntiAffinity: postgresqlClusterAffinityAdditionalPodAntiAffinity
}
type postgresqlPoolerTemplateSpecContainersItemLifecyclePostStartExec {
  command: [String]
}
type postgresqlPoolerTemplateSpecContainersItemLifecyclePostStartHttpGetHttpHeadersItem {
  name: String!
  value: String!
}
type postgresqlPoolerTemplateSpecContainersItemLifecyclePostStartHttpGet {
  host: String
  httpHeaders: [postgresqlPoolerTemplateSpecContainersItemLifecyclePostStartHttpGetHttpHeadersItem]
  path: String
  port: JSONObject!
  scheme: String
}
type postgresqlPoolerTemplateSpecContainersItemLifecyclePostStartTcpSocket {
  host: String
  port: JSONObject!
}
type postgresqlPoolerTemplateSpecContainersItemLifecyclePostStart {
  exec: postgresqlPoolerTemplateSpecContainersItemLifecyclePostStartExec
  httpGet: postgresqlPoolerTemplateSpecContainersItemLifecyclePostStartHttpGet
  tcpSocket: postgresqlPoolerTemplateSpecContainersItemLifecyclePostStartTcpSocket
}
type postgresqlPoolerTemplateSpecContainersItemLifecycle {
  postStart: postgresqlPoolerTemplateSpecContainersItemLifecyclePostStart
  preStop: postgresqlPoolerTemplateSpecContainersItemLifecyclePostStart
}
type postgresqlPoolerTemplateSpecContainersItemLivenessProbeGrpc {
  port: Int!
  service: String
}
type postgresqlPoolerTemplateSpecContainersItemLivenessProbe {
  exec: postgresqlPoolerTemplateSpecContainersItemLifecyclePostStartExec
  failureThreshold: Int
  grpc: postgresqlPoolerTemplateSpecContainersItemLivenessProbeGrpc
  httpGet: postgresqlPoolerTemplateSpecContainersItemLifecyclePostStartHttpGet
  initialDelaySeconds: Int
  periodSeconds: Int
  successThreshold: Int
  tcpSocket: postgresqlPoolerTemplateSpecContainersItemLifecyclePostStartTcpSocket
  terminationGracePeriodSeconds: Int
  timeoutSeconds: Int
}
type postgresqlPoolerTemplateSpecContainersItemPortsItem {
  containerPort: Int!
  hostIP: String
  hostPort: Int
  name: String
  protocol: String
}
type postgresqlPoolerTemplateSpecContainersItemResizePolicyItem {
  resourceName: String!
  restartPolicy: String!
}
type postgresqlPoolerTemplateSpecContainersItemSecurityContextCapabilities {
  add: [String]
  drop: [String]
}
type postgresqlPoolerTemplateSpecContainersItemSecurityContextSeLinuxOptions {
  level: String
  role: String
  type: String
  user: String
}
type postgresqlPoolerTemplateSpecContainersItemSecurityContextWindowsOptions {
  gmsaCredentialSpec: String
  gmsaCredentialSpecName: String
  hostProcess: Boolean
  runAsUserName: String
}
type postgresqlPoolerTemplateSpecContainersItemSecurityContext {
  allowPrivilegeEscalation: Boolean
  capabilities: postgresqlPoolerTemplateSpecContainersItemSecurityContextCapabilities
  privileged: Boolean
  procMount: String
  readOnlyRootFilesystem: Boolean
  runAsGroup: Int
  runAsNonRoot: Boolean
  runAsUser: Int
  seLinuxOptions: postgresqlPoolerTemplateSpecContainersItemSecurityContextSeLinuxOptions
  seccompProfile: postgresqlClusterSeccompProfile
  windowsOptions: postgresqlPoolerTemplateSpecContainersItemSecurityContextWindowsOptions
}
type postgresqlPoolerTemplateSpecContainersItemVolumeDevicesItem {
  devicePath: String!
  name: String!
}
type postgresqlPoolerTemplateSpecContainersItemVolumeMountsItem {
  mountPath: String!
  mountPropagation: String
  name: String!
  readOnly: Boolean
  subPath: String
  subPathExpr: String
}
type postgresqlPoolerTemplateSpecContainersItem {
  args: [String]
  command: [String]
  env: [postgresqlClusterEnvItem]
  envFrom: [postgresqlClusterEnvFromItem]
  image: String
  imagePullPolicy: String
  lifecycle: postgresqlPoolerTemplateSpecContainersItemLifecycle
  livenessProbe: postgresqlPoolerTemplateSpecContainersItemLivenessProbe
  name: String!
  ports: [postgresqlPoolerTemplateSpecContainersItemPortsItem]
  readinessProbe: postgresqlPoolerTemplateSpecContainersItemLivenessProbe
  resizePolicy: [postgresqlPoolerTemplateSpecContainersItemResizePolicyItem]
  resources: postgresqlClusterResources
  securityContext: postgresqlPoolerTemplateSpecContainersItemSecurityContext
  startupProbe: postgresqlPoolerTemplateSpecContainersItemLivenessProbe
  stdin: Boolean
  stdinOnce: Boolean
  terminationMessagePath: String
  terminationMessagePolicy: String
  tty: Boolean
  volumeDevices: [postgresqlPoolerTemplateSpecContainersItemVolumeDevicesItem]
  volumeMounts: [postgresqlPoolerTemplateSpecContainersItemVolumeMountsItem]
  workingDir: String
}
type postgresqlPoolerTemplateSpecDnsConfigOptionsItem {
  name: String
  value: String
}
type postgresqlPoolerTemplateSpecDnsConfig {
  nameservers: [String]
  options: [postgresqlPoolerTemplateSpecDnsConfigOptionsItem]
  searches: [String]
}
type postgresqlPoolerTemplateSpecEphemeralContainersItem {
  args: [String]
  command: [String]
  env: [postgresqlClusterEnvItem]
  envFrom: [postgresqlClusterEnvFromItem]
  image: String
  imagePullPolicy: String
  lifecycle: postgresqlPoolerTemplateSpecContainersItemLifecycle
  livenessProbe: postgresqlPoolerTemplateSpecContainersItemLivenessProbe
  name: String!
  ports: [postgresqlPoolerTemplateSpecContainersItemPortsItem]
  readinessProbe: postgresqlPoolerTemplateSpecContainersItemLivenessProbe
  resizePolicy: [postgresqlPoolerTemplateSpecContainersItemResizePolicyItem]
  resources: postgresqlClusterResources
  securityContext: postgresqlPoolerTemplateSpecContainersItemSecurityContext
  startupProbe: postgresqlPoolerTemplateSpecContainersItemLivenessProbe
  stdin: Boolean
  stdinOnce: Boolean
  targetContainerName: String
  terminationMessagePath: String
  terminationMessagePolicy: String
  tty: Boolean
  volumeDevices: [postgresqlPoolerTemplateSpecContainersItemVolumeDevicesItem]
  volumeMounts: [postgresqlPoolerTemplateSpecContainersItemVolumeMountsItem]
  workingDir: String
}
type postgresqlPoolerTemplateSpecHostAliasesItem {
  hostnames: [String]
  ip: String
}
type postgresqlPoolerTemplateSpecImagePullSecretsItem {
  name: String
}
type postgresqlPoolerTemplateSpecOs {
  name: String!
}
type postgresqlPoolerTemplateSpecReadinessGatesItem {
  conditionType: String!
}
type postgresqlPoolerTemplateSpecResourceClaimsItemSource {
  resourceClaimName: String
  resourceClaimTemplateName: String
}
type postgresqlPoolerTemplateSpecResourceClaimsItem {
  name: String!
  source: postgresqlPoolerTemplateSpecResourceClaimsItemSource
}
type postgresqlPoolerTemplateSpecSchedulingGatesItem {
  name: String!
}
type postgresqlPoolerTemplateSpecSecurityContextSysctlsItem {
  name: String!
  value: String!
}
type postgresqlPoolerTemplateSpecSecurityContext {
  fsGroup: Int
  fsGroupChangePolicy: String
  runAsGroup: Int
  runAsNonRoot: Boolean
  runAsUser: Int
  seLinuxOptions: postgresqlPoolerTemplateSpecContainersItemSecurityContextSeLinuxOptions
  seccompProfile: postgresqlClusterSeccompProfile
  supplementalGroups: [Int]
  sysctls: [postgresqlPoolerTemplateSpecSecurityContextSysctlsItem]
  windowsOptions: postgresqlPoolerTemplateSpecContainersItemSecurityContextWindowsOptions
}
type postgresqlPoolerTemplateSpecVolumesItemAwsElasticBlockStore {
  fsType: String
  partition: Int
  readOnly: Boolean
  volumeID: String!
}
type postgresqlPoolerTemplateSpecVolumesItemAzureDisk {
  cachingMode: String
  diskName: String!
  diskURI: String!
  fsType: String
  kind: String
  readOnly: Boolean
}
type postgresqlPoolerTemplateSpecVolumesItemAzureFile {
  readOnly: Boolean
  secretName: String!
  shareName: String!
}
type postgresqlPoolerTemplateSpecVolumesItemCephfs {
  monitors: [String]!
  path: String
  readOnly: Boolean
  secretFile: String
  secretRef: postgresqlPoolerTemplateSpecImagePullSecretsItem
  user: String
}
type postgresqlPoolerTemplateSpecVolumesItemCinder {
  fsType: String
  readOnly: Boolean
  secretRef: postgresqlPoolerTemplateSpecImagePullSecretsItem
  volumeID: String!
}
type postgresqlPoolerTemplateSpecVolumesItemConfigMap {
  defaultMode: Int
  items: [postgresqlClusterProjectedVolumeTemplateSourcesItemConfigMapItemsItem]
  name: String
  optional: Boolean
}
type postgresqlPoolerTemplateSpecVolumesItemCsi {
  driver: String!
  fsType: String
  nodePublishSecretRef: postgresqlPoolerTemplateSpecImagePullSecretsItem
  readOnly: Boolean
  volumeAttributes: JSONObject
}
type postgresqlPoolerTemplateSpecVolumesItemDownwardAPI {
  defaultMode: Int
  items: [postgresqlClusterProjectedVolumeTemplateSourcesItemDownwardAPIItemsItem]
}
type postgresqlPoolerTemplateSpecVolumesItemEmptyDir {
  medium: String
  sizeLimit: JSONObject
}
type postgresqlPoolerTemplateSpecVolumesItemEphemeralVolumeClaimTemplate {
  metadata: JSONObject
  spec: postgresqlClusterStoragePvcTemplate!
}
type postgresqlPoolerTemplateSpecVolumesItemEphemeral {
  volumeClaimTemplate: postgresqlPoolerTemplateSpecVolumesItemEphemeralVolumeClaimTemplate
}
type postgresqlPoolerTemplateSpecVolumesItemFc {
  fsType: String
  lun: Int
  readOnly: Boolean
  targetWWNs: [String]
  wwids: [String]
}
type postgresqlPoolerTemplateSpecVolumesItemFlexVolume {
  driver: String!
  fsType: String
  options: JSONObject
  readOnly: Boolean
  secretRef: postgresqlPoolerTemplateSpecImagePullSecretsItem
}
type postgresqlPoolerTemplateSpecVolumesItemFlocker {
  datasetName: String
  datasetUUID: String
}
type postgresqlPoolerTemplateSpecVolumesItemGcePersistentDisk {
  fsType: String
  partition: Int
  pdName: String!
  readOnly: Boolean
}
type postgresqlPoolerTemplateSpecVolumesItemGitRepo {
  directory: String
  repository: String!
  revision: String
}
type postgresqlPoolerTemplateSpecVolumesItemGlusterfs {
  endpoints: String!
  path: String!
  readOnly: Boolean
}
type postgresqlPoolerTemplateSpecVolumesItemHostPath {
  path: String!
  type: String
}
type postgresqlPoolerTemplateSpecVolumesItemIscsi {
  chapAuthDiscovery: Boolean
  chapAuthSession: Boolean
  fsType: String
  initiatorName: String
  iqn: String!
  iscsiInterface: String
  lun: Int!
  portals: [String]
  readOnly: Boolean
  secretRef: postgresqlPoolerTemplateSpecImagePullSecretsItem
  targetPortal: String!
}
type postgresqlPoolerTemplateSpecVolumesItemNfs {
  path: String!
  readOnly: Boolean
  server: String!
}
type postgresqlPoolerTemplateSpecVolumesItemPersistentVolumeClaim {
  claimName: String!
  readOnly: Boolean
}
type postgresqlPoolerTemplateSpecVolumesItemPhotonPersistentDisk {
  fsType: String
  pdID: String!
}
type postgresqlPoolerTemplateSpecVolumesItemPortworxVolume {
  fsType: String
  readOnly: Boolean
  volumeID: String!
}
type postgresqlPoolerTemplateSpecVolumesItemQuobyte {
  group: String
  readOnly: Boolean
  registry: String!
  tenant: String
  user: String
  volume: String!
}
type postgresqlPoolerTemplateSpecVolumesItemRbd {
  fsType: String
  image: String!
  keyring: String
  monitors: [String]!
  pool: String
  readOnly: Boolean
  secretRef: postgresqlPoolerTemplateSpecImagePullSecretsItem
  user: String
}
type postgresqlPoolerTemplateSpecVolumesItemScaleIO {
  fsType: String
  gateway: String!
  protectionDomain: String
  readOnly: Boolean
  secretRef: postgresqlPoolerTemplateSpecImagePullSecretsItem!
  sslEnabled: Boolean
  storageMode: String
  storagePool: String
  system: String!
  volumeName: String
}
type postgresqlPoolerTemplateSpecVolumesItemSecret {
  defaultMode: Int
  items: [postgresqlClusterProjectedVolumeTemplateSourcesItemConfigMapItemsItem]
  optional: Boolean
  secretName: String
}
type postgresqlPoolerTemplateSpecVolumesItemStorageos {
  fsType: String
  readOnly: Boolean
  secretRef: postgresqlPoolerTemplateSpecImagePullSecretsItem
  volumeName: String
  volumeNamespace: String
}
type postgresqlPoolerTemplateSpecVolumesItemVsphereVolume {
  fsType: String
  storagePolicyID: String
  storagePolicyName: String
  volumePath: String!
}
type postgresqlPoolerTemplateSpecVolumesItem {
  awsElasticBlockStore: postgresqlPoolerTemplateSpecVolumesItemAwsElasticBlockStore
  azureDisk: postgresqlPoolerTemplateSpecVolumesItemAzureDisk
  azureFile: postgresqlPoolerTemplateSpecVolumesItemAzureFile
  cephfs: postgresqlPoolerTemplateSpecVolumesItemCephfs
  cinder: postgresqlPoolerTemplateSpecVolumesItemCinder
  configMap: postgresqlPoolerTemplateSpecVolumesItemConfigMap
  csi: postgresqlPoolerTemplateSpecVolumesItemCsi
  downwardAPI: postgresqlPoolerTemplateSpecVolumesItemDownwardAPI
  emptyDir: postgresqlPoolerTemplateSpecVolumesItemEmptyDir
  ephemeral: postgresqlPoolerTemplateSpecVolumesItemEphemeral
  fc: postgresqlPoolerTemplateSpecVolumesItemFc
  flexVolume: postgresqlPoolerTemplateSpecVolumesItemFlexVolume
  flocker: postgresqlPoolerTemplateSpecVolumesItemFlocker
  gcePersistentDisk: postgresqlPoolerTemplateSpecVolumesItemGcePersistentDisk
  gitRepo: postgresqlPoolerTemplateSpecVolumesItemGitRepo
  glusterfs: postgresqlPoolerTemplateSpecVolumesItemGlusterfs
  hostPath: postgresqlPoolerTemplateSpecVolumesItemHostPath
  iscsi: postgresqlPoolerTemplateSpecVolumesItemIscsi
  name: String!
  nfs: postgresqlPoolerTemplateSpecVolumesItemNfs
  persistentVolumeClaim: postgresqlPoolerTemplateSpecVolumesItemPersistentVolumeClaim
  photonPersistentDisk: postgresqlPoolerTemplateSpecVolumesItemPhotonPersistentDisk
  portworxVolume: postgresqlPoolerTemplateSpecVolumesItemPortworxVolume
  projected: postgresqlClusterProjectedVolumeTemplate
  quobyte: postgresqlPoolerTemplateSpecVolumesItemQuobyte
  rbd: postgresqlPoolerTemplateSpecVolumesItemRbd
  scaleIO: postgresqlPoolerTemplateSpecVolumesItemScaleIO
  secret: postgresqlPoolerTemplateSpecVolumesItemSecret
  storageos: postgresqlPoolerTemplateSpecVolumesItemStorageos
  vsphereVolume: postgresqlPoolerTemplateSpecVolumesItemVsphereVolume
}
type postgresqlPoolerTemplateSpec {
  activeDeadlineSeconds: Int
  affinity: postgresqlPoolerTemplateSpecAffinity
  automountServiceAccountToken: Boolean
  containers: [postgresqlPoolerTemplateSpecContainersItem]!
  dnsConfig: postgresqlPoolerTemplateSpecDnsConfig
  dnsPolicy: String
  enableServiceLinks: Boolean
  ephemeralContainers: [postgresqlPoolerTemplateSpecEphemeralContainersItem]
  hostAliases: [postgresqlPoolerTemplateSpecHostAliasesItem]
  hostIPC: Boolean
  hostNetwork: Boolean
  hostPID: Boolean
  hostUsers: Boolean
  hostname: String
  imagePullSecrets: [postgresqlPoolerTemplateSpecImagePullSecretsItem]
  initContainers: [postgresqlPoolerTemplateSpecContainersItem]
  nodeName: String
  nodeSelector: JSONObject
  os: postgresqlPoolerTemplateSpecOs
  overhead: JSONObject
  preemptionPolicy: String
  priority: Int
  priorityClassName: String
  readinessGates: [postgresqlPoolerTemplateSpecReadinessGatesItem]
  resourceClaims: [postgresqlPoolerTemplateSpecResourceClaimsItem]
  restartPolicy: String
  runtimeClassName: String
  schedulerName: String
  schedulingGates: [postgresqlPoolerTemplateSpecSchedulingGatesItem]
  securityContext: postgresqlPoolerTemplateSpecSecurityContext
  serviceAccount: String
  serviceAccountName: String
  setHostnameAsFQDN: Boolean
  shareProcessNamespace: Boolean
  subdomain: String
  terminationGracePeriodSeconds: Int
  tolerations: [postgresqlClusterAffinityTolerationsItem]
  topologySpreadConstraints: [postgresqlClusterTopologySpreadConstraintsItem]
  volumes: [postgresqlPoolerTemplateSpecVolumesItem]
}
type postgresqlPoolerTemplate {
  metadata: JSONObject
  spec: postgresqlPoolerTemplateSpec
}
type postgresqlPooler {
  metadata: metadata
  cluster: postgresqlBackupCluster!
  deploymentStrategy: postgresqlPoolerDeploymentStrategy
  instances: Int!
  monitoring: postgresqlPoolerMonitoring
  pgbouncer: postgresqlPoolerPgbouncer!
  template: postgresqlPoolerTemplate
  type: String!
  status: postgresqlPoolerStatus
}
type postgresqlScheduledBackupStatus {
  lastCheckTime: String
  lastScheduleTime: String
  nextScheduleTime: String
}
input postgresqlScheduledBackupSpec {
  backupOwnerReference: String
  cluster: postgresqlBackupSpecCluster
  immediate: Boolean
  schedule: String!
  suspend: Boolean
  target: String
}
type postgresqlScheduledBackup {
  metadata: metadata
  backupOwnerReference: String
  cluster: postgresqlBackupCluster
  immediate: Boolean
  schedule: String!
  suspend: Boolean
  target: String
  status: postgresqlScheduledBackupStatus
}
type Query {
  postgresqlBackup(namespace: String!, name: String!): postgresqlBackup
  postgresqlCluster(namespace: String!, name: String!): postgresqlCluster
  postgresqlPooler(namespace: String!, name: String!): postgresqlPooler
  postgresqlScheduledBackup(namespace: String!, name: String!): postgresqlScheduledBackup
}
type Mutation {
  createPostgresqlBackup(namespace: String!, name: String!, spec: postgresqlBackupSpec!): postgresqlBackup
  patchPostgresqlBackup(namespace: String!, name: String!, spec: postgresqlBackupSpec!): postgresqlBackup
  deletePostgresqlBackup(namespace: String!, name: String!): postgresqlBackup
  createPostgresqlCluster(namespace: String!, name: String!, spec: postgresqlClusterSpec!): postgresqlCluster
  patchPostgresqlCluster(namespace: String!, name: String!, spec: postgresqlClusterSpec!): postgresqlCluster
  deletePostgresqlCluster(namespace: String!, name: String!): postgresqlCluster
  createPostgresqlPooler(namespace: String!, name: String!, spec: postgresqlPoolerSpec!): postgresqlPooler
  patchPostgresqlPooler(namespace: String!, name: String!, spec: postgresqlPoolerSpec!): postgresqlPooler
  deletePostgresqlPooler(namespace: String!, name: String!): postgresqlPooler
  createPostgresqlScheduledBackup(namespace: String!, name: String!, spec: postgresqlScheduledBackupSpec!): postgresqlScheduledBackup
  patchPostgresqlScheduledBackup(namespace: String!, name: String!, spec: postgresqlScheduledBackupSpec!): postgresqlScheduledBackup
  deletePostgresqlScheduledBackup(namespace: String!, name: String!): postgresqlScheduledBackup
}