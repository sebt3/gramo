import { QTableColumn } from 'quasar'
import { ref, gqlDataToYaml, tableColumnAlign, useCore, useNavigationStoreRef } from '../core'
export { ref, useCore, useQuery, useMutation, sanitizeData, getProperties } from '../core';
export { InnoDBClusterListExcludes, InnoDBClusterReadExcludes, InnoDBClusterSimpleExcludes } from './custom.js'
import { extraInnoDBClusterColumns } from './custom.js'
import { stringify, parse } from 'yaml'

export const InnoDBClusterColumns:Array<QTableColumn> = ([
  {name: 'Name', label: 'Name', field: row => row.metadata.name, sortable: true, align: tableColumnAlign.left}
] as Array<QTableColumn>).concat(extraInnoDBClusterColumns).concat([
  {name: 'Action', label: '', field: 'Action', sortable: false, align: tableColumnAlign.right}
]);
export const InnoDBClusterAllColumns = ([
  {name: 'Namespace', label: 'Namespace', field: row => row.metadata.namespace, sortable: true, align: tableColumnAlign.left}
] as Array<QTableColumn>).concat(InnoDBClusterColumns);

export const InnoDBClusterDefinition = {"type":"object","required":["spec"],"properties":{"apiVersion":{"description":"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources","type":"string"},"kind":{"description":"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds","type":"string"},"spec":{"type":"object","required":["secretName"],"properties":{"backupProfiles":{"description":"Backup profile specifications for the cluster, which can be referenced from backup schedules and one-off backup jobs","type":"array","items":{"required":["name"],"x-kubernetes-preserve-unknown-fields":true}},"backupSchedules":{"description":"Schedules for periodically executed backups","type":"array","items":{"required":["name","schedule"],"x-kubernetes-preserve-unknown-fields":true}},"baseServerId":{"description":"Base value for MySQL server_id for instances in the cluster","type":"integer","maximum":4294967195,"minimum":0},"datadirVolumeClaimTemplate":{"description":"Template for a PersistentVolumeClaim, to be used as datadir","x-kubernetes-preserve-unknown-fields":true},"edition":{"description":"MySQL Server Edition (community or enterprise)","type":"string","pattern":"^(community|enterprise)$"},"imagePullPolicy":{"description":"Defaults to Always, but set to IfNotPresent in deploy-operator.yaml when deploying Operator","type":"string"},"imagePullSecrets":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"}}}},"imageRepository":{"description":"Repository where images are pulled from; defaults to container-registry.oracle.com/mysql","type":"string"},"initDB":{"x-kubernetes-preserve-unknown-fields":true},"instances":{"description":"Number of MySQL replica instances for the cluster","type":"integer","maximum":9,"minimum":1},"keyring":{"description":"Keyring specification","type":"object","properties":{"encryptedFile":{"description":"Keyring 'Encrypted File' specification","type":"object","required":["fileName","storage","password"],"properties":{"fileName":{"description":"Full path to the keyring file name inside the storage volume","type":"string"},"password":{"description":"Name of a secret that contains password for the keyring in the key 'keyring_password'","type":"string"},"readOnly":{"description":"Whether to open the keyring file in read-only mode","type":"boolean"},"storage":{"description":"Specification of the volume to be mounted where the keyring file resides","x-kubernetes-preserve-unknown-fields":true}}},"file":{"description":"Keyring 'File' specification","type":"object","required":["fileName","storage"],"properties":{"fileName":{"description":"Full path to the keyring file name inside the storage volume","type":"string"},"readOnly":{"description":"Whether to open the keyring file in read-only mode","type":"boolean"},"storage":{"description":"Specification of the volume to be mounted where the keyring file resides","x-kubernetes-preserve-unknown-fields":true}}},"oci":{"description":"Keyring 'OCI' specification","type":"object","required":["user","keySecret","keyFingerprint","tenancy"],"properties":{"caCertificate":{"description":"Secret that contains ca.crt field with CA certificate bundle file that the keyring_oci plugin uses for Oracle Cloud Infrastructure certificate verification","type":"string"},"compartment":{"description":"Compartment identifier in the form ocid1.compartment.oc1...","type":"string","pattern":"^ocid1\\.compartment\\."},"endpoints":{"type":"object","properties":{"encryption":{"description":"Encryption endpoint URI like {identifier}-crypto.kms.{region}.oraclecloud.com","type":"string"},"management":{"description":"Management endpoint URI like {identifier}-management.kms.{region}.oraclecloud.com","type":"string"},"secrets":{"description":"Secrets endpoint URI like secrets.vaults.{region}.oci.oraclecloud.com","type":"string"},"vaults":{"description":"Vaults endpoint URI like vaults.{region}.oci.oraclecloud.com","type":"string"}}},"keyFingerprint":{"description":"Private key fingerprint","type":"string","pattern":"([0-9a-f]{2}:){15}[0-9a-f]{2}$"},"keySecret":{"description":"A secret that contains the private key under the field 'privatekey'","type":"string"},"masterKey":{"description":"Master key identified in the form ocid1.key.oc1...","type":"string","pattern":"^ocid1\\.key\\."},"tenancy":{"description":"Tenancy identifier in the form ocid1.tenancy.oc1...","type":"string","pattern":"^ocid1\\.tenancy\\."},"user":{"description":"User identifier in the form of ocid1.user.oc1...","type":"string","pattern":"^ocid1\\.user\\."},"virtualVault":{"description":"Vault identifier in the form ocid1.vault.oc1...","type":"string","pattern":"^ocid1\\.vault\\."}}}}},"logs":{"type":"object","properties":{"collector":{"type":"object","properties":{"containerName":{"description":"Name of the collector container sidecar","type":"string"},"env":{"type":"array","items":{"description":"Environment variables to be passed to the image. Definition will be directly copied like podSpec fields are","x-kubernetes-preserve-unknown-fields":true}},"fluentd":{"description":"Properties of the fluentd log collector","type":"object","properties":{"additionalFilterConfiguration":{"description":"Raw configuration of additional Fluentd filters to be added to the configuration file","type":"string"},"errorLog":{"type":"object","properties":{"options":{"description":"fluentd specific options for the error log","x-kubernetes-preserve-unknown-fields":true},"tag":{"description":"Tag for the error log records","type":"string"}}},"generalLog":{"type":"object","properties":{"options":{"description":"fluentd specific options for the general log","x-kubernetes-preserve-unknown-fields":true},"tag":{"description":"Tag for the general log records","type":"string"}}},"recordAugmentation":{"type":"object","properties":{"annotations":{"type":"array","items":{"type":"object","required":["fieldName","annotationName"],"properties":{"annotationName":{"description":"Name of the pod label that holds the value to be stored under fieldName in the log record","type":"string"},"fieldName":{"description":"Name of the field added to the log record with value from annotationName","type":"string"}}}},"enabled":{"description":"Whether to enable record augmentation with additional data","type":"boolean"},"labels":{"type":"array","items":{"type":"object","required":["fieldName","labelName"],"properties":{"fieldName":{"description":"Name of the field added to the log record with value from labelName","type":"string"},"labelName":{"description":"Name of the pod label that holds the value to be stored under fieldName in the log record","type":"string"}}}},"podFields":{"type":"array","items":{"type":"object","required":["fieldName","fieldPath"],"properties":{"fieldName":{"description":"Name of the field added to the log record with value taken from a field with path stored in fieldPath","type":"string"},"fieldPath":{"description":"Value for the field fieldName. The path should be of the same syntax as the one used for mounting environment variables from field reference - valueFrom.fieldRef.fieldPath . The field will be mounted in the pod as a environment variable, prefixed with a prefix and used then added to the log record. Examples for fieldRef are : spec.nodeName, metadata.namespace, status.podIP, etc.","type":"string"}}}},"resourceFields":{"type":"array","items":{"type":"object","required":["fieldName","containerName","resource"],"properties":{"containerName":{"type":"string"},"fieldName":{"description":"Name of the field added to the log record with value taken from a field with path stored in fieldPath","type":"string"},"resource":{"description":"See https://kubernetes.io/docs/tasks/inject-data-application/environment-variable-expose-pod-information/#use-container-fields-as-values-for-environment-variables","type":"string"}}}},"staticFields":{"type":"array","items":{"type":"object","required":["fieldName","fieldValue"],"properties":{"fieldName":{"description":"Name of the field added to the log record with value from fieldValue","type":"string"},"fieldValue":{"description":"Value for the static field with name taken from fieldName","type":"string"}}}}}},"sinks":{"type":"array","items":{"required":["name","rawConfig"],"x-kubernetes-preserve-unknown-fields":true}},"slowQueryLog":{"type":"object","properties":{"options":{"description":"fluentd specific options for the slow log","x-kubernetes-preserve-unknown-fields":true},"tag":{"description":"Tag for the slow log records","type":"string"}}}}},"image":{"description":"Name of an image, including registry and repository, to be used for the log collector sidecar. If provided it needs to be an image for the configured collector type.","type":"string"}}},"error":{"type":"object","properties":{"collect":{"description":"Whether error logging data should be collected. Implies that the logging should be enabled. If enabled the error log will be switched to JSON format output","type":"boolean"},"verbosity":{"description":"Log error verbosity. For details, see the MySQL Server --log-error-verbosity documentation.","type":"integer","maximum":3,"minimum":1}}},"general":{"type":"object","properties":{"collect":{"description":"Whether general logging data should be collected. Implies that the logging should be enabled.","type":"boolean"},"enabled":{"description":"Whether general logging should be enabled","type":"boolean"}}},"slowQuery":{"type":"object","properties":{"collect":{"description":"Whether slow query logging data should be collected. Implies that the logging should be enabled.","type":"boolean"},"enabled":{"description":"Whether slow query logging should be enabled","type":"boolean"},"longQueryTime":{"description":"Long query time threshold","type":"number","minimum":0}}}}},"metrics":{"description":"Configuration of a Prometheus-style metrics provider","type":"object","required":["enable","image"],"properties":{"enable":{"description":"Toggle to enable or disable the metrics sidecar","type":"boolean"},"image":{"description":"Name of an image to be used for the metrics sidecar, if provided metrics will be enabled","type":"string"},"monitor":{"description":"Create a ServiceMonitor for Prometheus Operator","type":"boolean"},"monitorSpec":{"description":"Custom configuration for the ServiceMonitor object","x-kubernetes-preserve-unknown-fields":true},"options":{"description":"Options passed to the metrics provider as command line arguments","type":"array","items":{"type":"string"}},"tlsSecret":{"description":"Name of a Secret with TLS certificate, key and CA, which will be mounted at /tls into the container an can be used from webConfig","type":"string"},"webConfig":{"description":"Name of a ConfigMap with a web.config file, if this option is provided a command line option --web.config.file is added","type":"string"}}},"mycnf":{"description":"Custom configuration additions for my.cnf","type":"string"},"podAnnotations":{"x-kubernetes-preserve-unknown-fields":true},"podLabels":{"x-kubernetes-preserve-unknown-fields":true},"podSpec":{"x-kubernetes-preserve-unknown-fields":true},"readReplicas":{"type":"array","items":{"type":"object","required":["name","baseServerId"],"properties":{"baseServerId":{"description":"Base value for MySQL server_id for instances of the readReplica, if 0 it will be assigned automatically","type":"integer","maximum":4294967195,"minimum":0},"datadirVolumeClaimTemplate":{"description":"Template for a PersistentVolumeClaim, to be used as datadir","x-kubernetes-preserve-unknown-fields":true},"instances":{"description":"Number of MySQL instances for the set of read replica","type":"integer","maximum":999,"minimum":1},"mycnf":{"description":"Custom configuration additions for my.cnf","type":"string"},"name":{"type":"string"},"podAnnotations":{"x-kubernetes-preserve-unknown-fields":true},"podLabels":{"x-kubernetes-preserve-unknown-fields":true},"podSpec":{"x-kubernetes-preserve-unknown-fields":true},"version":{"description":"MySQL Server version","type":"string","pattern":"^\\d+\\.\\d+\\.\\d+(-.+)?"}}}},"router":{"description":"MySQL Router specification","type":"object","properties":{"bootstrapOptions":{"description":"Command line options passed to MySQL Router while bootstrapping","type":"array","items":{"type":"string"}},"instances":{"description":"Number of MySQL Router instances to deploy","type":"integer","minimum":0},"options":{"description":"Command line options passed to MySQL Router while running","type":"array","items":{"type":"string"}},"podAnnotations":{"x-kubernetes-preserve-unknown-fields":true},"podLabels":{"x-kubernetes-preserve-unknown-fields":true},"podSpec":{"x-kubernetes-preserve-unknown-fields":true},"routingOptions":{"description":"Set routing options for the cluster","type":"object","properties":{"invalidated_cluster_policy":{"type":"string","enum":["drop_all","accept_ro"]},"read_only_targets":{"type":"string","enum":["all","read_replicas","secondaries"]},"stats_updates_frequency":{"type":"integer","minimum":0}}},"tlsSecretName":{"description":"Name of a TLS type Secret containing MySQL Router certificate and private key used for SSL","type":"string"},"version":{"description":"Override MySQL Router version","type":"string","pattern":"^\\d+\\.\\d+\\.\\d+(-.+)?"}}},"secretName":{"description":"Name of a generic type Secret containing root/default account password","type":"string"},"service":{"description":"Configuration of the Service used by applications connecting to the InnoDB Cluster","type":"object","properties":{"annotations":{"description":"Custom annotations for the Service","x-kubernetes-preserve-unknown-fields":true},"defaultPort":{"description":"Target for the Service's default (3306) port. If mysql-rw traffic will go to the primary and allow read and write operations, with mysql-ro traffic goes to the replica and allows only read operations, with mysql-rw-split the router's read-write-splitting will be targeted","type":"string","enum":["mysql-rw","mysql-ro","mysql-rw-split"]},"labels":{"description":"Custom labels for the Service","x-kubernetes-preserve-unknown-fields":true},"type":{"type":"string","enum":["ClusterIP","NodePort","LoadBalancer"]}}},"serviceAccountName":{"type":"string"},"tlsCASecretName":{"description":"Name of a generic type Secret containing CA (ca.pem) and optional CRL (crl.pem) for SSL","type":"string"},"tlsSecretName":{"description":"Name of a TLS type Secret containing Server certificate and private key for SSL","type":"string"},"tlsUseSelfSigned":{"description":"Enables use of self-signed TLS certificates, reducing or disabling TLS based security verifications","type":"boolean"},"version":{"description":"MySQL Server version","type":"string","pattern":"^\\d+\\.\\d+\\.\\d+(-.+)?"}}},"status":{"x-kubernetes-preserve-unknown-fields":true}},"x-kubernetes-group-version-kind":[{"group":"mysql.oracle.com","kind":"InnoDBCluster","version":"v2"}]};

export function useInnoDBCluster() {
  const { router, $q, pagination, setItemFromRoute, onErrorHandler, notify, notifySuccess, notifyError, notifyWorking, isNamespaced, setNamespaceFromRoute, setNamespacedItemFromRoute } = useCore();
  const viewer = ref({
      tab: 'simple',
      full: '',
      props: {
        "spec": '',
      }
  });
  const editor = ref({
      tab: 'simple',
      yaml: '',
      obj: {},
      setKey: (key, o) => {editor.value.obj[key] = o;editor.value.yaml = stringify(editor.value.obj)},
      ready: false,
      setYaml: (y) => {editor.value.yaml = y;editor.value.obj = parse(y);},
//      updateFromQuery: (res: object, obj: object) => {editor.value.ready=false;if(!res['loading']){editor.value.setSpec(obj);editor.value.ready=true;}},
  });
  return {
    editor, viewer, viewerUpdate: (obj) => {
      viewer.value.full=gqlDataToYaml(obj)
      viewer.value.props["spec"]=gqlDataToYaml({"spec": obj["spec"]})
    },
    navigation: useNavigationStoreRef(),
    onlyReadProperties: (obj) => {
      const res = {}
      Object.keys(obj).forEach(k=>{
        if (["spec","status"].includes(k)||k=='metadata')
          res[k] = obj[k];
      })
      return res
    },
    onlyWriteProperties: (obj) => {
      const res = {}
      Object.keys(obj).forEach(k=>{
        if (["spec"].includes(k))
          res[k] = obj[k];
      })
      return res
    },
    isNamespaced, setNamespaceFromRoute, setNamespacedItemFromRoute,
    router, pagination, setItemFromRoute, notify, notifySuccess, notifyError, notifyWorking, onErrorHandler,
    onNotInnoDBClusterFound: (res) => {
    if ( !res.loading && res.data.k8sNamespace[0].oracleInnoDBCluster == null) {
        const matched = router.currentRoute.value.matched
        notifyError('InnoDBCluster not found');
        router.push({
          path: matched[matched.length>1?matched.length-2:matched.length-1].path,
          replace: true
        })
      }
    },
    toView: (namespace, name) => router.push({ name: 'oracleInnoDBClusterView', params: {name, namespace}}),
    toViewReloaded: async (namespace, name) => {await router.push({ name: 'oracleInnoDBClusterView', params: {name, namespace}});router.go(0);},
    toEdit: (namespace, name) => router.push({ name: 'oracleInnoDBClusterEdit', params: {name, namespace}}),
    deleteDone: () => notifySuccess('Deletion proceded'),
    deleteError: (err) => {
      notifyError('Deletion failed');
      console.log('deletion error',err);
    },
    patchDone: () => {
      notifySuccess('Modification applied');
      router.go(-1);
    },
    patchError: (err) => {
      notifyError('Modification failed');
      console.log('mutation error', err)
    },
    actionNew: (namespace)    => router.push({ name: 'oracleInnoDBClusterCreate', params: {namespace}}),
    actionDelete: (deletor, meta) => {
      $q.dialog({
        title: 'Confirm <span class="text-red">delete</span>',
        message: `<em>You are</em> about to <span class="text-red">delete</span> InnoDBCluster <strong>${meta.name}</strong>`,
        persistent: true, cancel: true, html: true, ok: {color: 'negative'}
      }).onOk(() => {
        notifyWorking('Delete in progress');
        deletor({"name": meta.name, "namespace":meta.namespace});
      })
    },
  }
}