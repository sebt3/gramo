    {{type}}{{targetGroup}}{{targetShort}}: async (parent, args: object) => {
      try{
{{#if (and (eq type 'use') (defined path))}}
        const spec = getByPath(parent, '{{path}}')
        if (!Array.isArray(spec['volumes']) || spec['volumes'].filter(v=>v['persistentVolumeClaim']!=undefined).length<1) return null;
        const claims = spec['volumes'].filter(v=>v['persistentVolumeClaim']!=undefined).map(v=>v['persistentVolumeClaim']['claimName'])
        const lst = await list{{targetGroup}}{{targetShort}}.{{targetGroup}}{{targetShort}}(parent,{namespace: parent['metadata']['namespace'], ...args})
        return lst.filter(o=>claims.includes(o['metadata']['name']))
{{/if}}
{{#if (and (eq type 'users') (defined path))}}
        const lst = await list{{targetGroup}}{{targetShort}}.{{targetGroup}}{{targetShort}}(parent,{namespace: parent['metadata']['namespace'], ...args})
        return lst.filter(w=>
                Array.isArray(getByPath(w, '{{path}}')['volumes']) &&
                getByPath(w, '{{path}}')['volumes'].filter(v=>
                    v['persistentVolumeClaim']!=undefined &&
                    v['persistentVolumeClaim']['claimName']==parent['metadata']['name']
                ).length>0
        )
{{/if}}
{{#if (eq type 'equity')}}
        const res = (await list{{targetGroup}}{{targetShort}}.{{targetGroup}}{{targetShort}}(parent,args))
              .filter(o=>parent['spec']['volumeName']==o['metadata']['name'])
        if (Array.isArray(res) && res.length>0) return res[0];
{{/if}}
{{#if (eq type 'parent')}}
        if(parent['spec']['claimRef']['kind']!='{{targetShort}}') return null;
        const res = (await list{{targetGroup}}{{targetShort}}.{{targetGroup}}{{targetShort}}(parent,{namespace: parent['spec']['claimRef']['namespace'], ...args}))
              .filter(r=>r['metadata']['name']==parent['spec']['claimRef']['name'])
        if (Array.isArray(res) && res.length>0) return res[0];
{{/if}}
      } catch (err) {
        console.error(err)
      }
      return null
    },
