{{#if (and (eq type 'consume') (eq targetShort 'Category'))}}
    {{type}}{{targetGroup}}{{targetShort}}: async (parent, args: object) => {
        return {
            name: parent.spec.category,
        };
    },
{{/if}}
{{#if (and (eq type 'consume') (eq targetShort 'Package'))}}
    {{type}}{{targetGroup}}{{targetShort}}: async (parent, args: object) => {
        const packages = await list{{targetGroup}}{{targetShort}}.{{targetGroup}}{{targetShort}}(parent, args)
        const lstPkg = packages.filter((pck) => pck['name'] == parent.spec.component && pck['category']  == parent.spec.category && pck['distrib']  == parent.spec.distrib);
        if (lstPkg.length>0) return lstPkg[0];
        return null;
    },
{{/if}}
{{#if (and (eq type 'consume') (eq targetShort 'Distrib'))}}
    {{type}}{{targetGroup}}{{targetShort}}: async (parent, args: object) => {
        const lst = (await list{{targetGroup}}{{targetShort}}.{{targetGroup}}{{targetShort}}(parent,{})).filter((i) => i.metadata.name == parent.spec.distrib)
        if (lst.length>0) return lst[0];
        return {
            metadata: {
                name: parent.spec.distrib,
            },
        };
    },
{{/if}}
{{#if (and (eq type 'provide') (eq targetShort 'Install'))}}
    {{type}}{{targetGroup}}{{targetShort}}: async (dist, args: object) => {
        const nss = await listNamespace.k8sNamespace(dist, args)
        const res = (await Promise.all(nss.map(n=>n['metadata']['name']).map(async (ns)=>{
            const lst = await list{{targetGroup}}{{targetShort}}.{{targetGroup}}{{targetShort}}(dist, {namespace: ns, ...args})
            return lst.filter(r=>r['spec']['distrib']==dist['metadata']['name'])
        })))
        return res.flat().filter((v)=>v!=null)
    },
{{/if}}
{{#if (and (eq type 'users') (and (eq short 'Distrib') (eq targetShort 'Category')))}}
    {{type}}{{targetGroup}}{{targetShort}}: async (dist, args: object) => {
        const res = (await listvynilPackage.vynilPackage(dist, args)).filter(pkg => {
            if ((gramoConfig.limitVynilDistrib != ""  && pkg['distrib'] != gramoConfig.limitVynilDistrib) ||
                (gramoConfig.limitVynilCategory != "" && pkg['category'] != gramoConfig.limitVynilCategory)) return false;
            return pkg['distrib'] === dist['metadata']['name']
        }).map(p=>p.category).filter((v,i,a)=>a.indexOf(v) === i).map(name=>{return {name:name} })
        return res
    },
{{/if}}
{{#if (and (eq type 'provide') (eq targetShort 'Package'))}}
    {{type}}{{targetGroup}}{{targetShort}}: async (dist, args: object) => {
        const packages = await list{{targetGroup}}{{targetShort}}.{{targetGroup}}{{targetShort}}(dist, args)
        const res = packages.filter(pkg => {
            if ((gramoConfig.limitVynilDistrib != ""  && pkg['distrib'] != gramoConfig.limitVynilDistrib) ||
                (gramoConfig.limitVynilCategory != "" && pkg['category'] != gramoConfig.limitVynilCategory)) return false;
            return pkg['distrib'] === dist['metadata']['name']
        });
        return res
    },
{{/if}}
{{#if (eq type 'parent')}}
    {{type}}{{targetGroup}}{{targetShort}}: async (obj: object, args: object) => {
        if (obj['metadata']['labels'] == null || obj['metadata']['labels']['vynil.solidite.fr/owner-name'] == null || obj['metadata']['labels']['vynil.solidite.fr/owner-namespace'] == null) return null;
        const insts = (await list{{targetGroup}}{{targetShort}}.{{targetGroup}}{{targetShort}}(obj, {namespace: obj['metadata']['labels']['vynil.solidite.fr/owner-namespace'], ...args})).filter(inst=>inst['metadata']['name']==obj['metadata']['labels']['vynil.solidite.fr/owner-name']);
        if (Array.isArray(insts) && insts.length>0) return insts[0]
        return null
    },
{{/if}}
{{#if (eq type 'child')}}
    {{type}}{{targetGroup}}{{targetShort}}: async (parent: object, args: object) => {
        if (parent['status']==undefined || parent['status']['tfstate']==undefined || !Array.isArray(parent['status']['tfstate']['resources'])) return null;
        /*console.log(parent['status']['tfstate']['resources']
            .filter(r=>r.mode=='managed'&&r.provider=='provider["registry.terraform.io/hashicorp/kubernetes"]')
            .map(r=>r.instances.map(i=>{return {name: i.attributes.metadata[0].name, namespace: i.attributes.metadata[0].namespace} })).flat().flat()
        )*/
        const list = parent['status']['tfstate']['resources']
                .filter(r=>r.mode=='managed'&&r.provider=='provider["registry.terraform.io/gavinbunney/kubectl"]')
                .map(r=>r.instances).flat().flat()
                .filter(i=>i.attributes.kind=='{{targetShort}}')
                .map(i=>{return {namespace: i.attributes.namespace, name:i.attributes.name} })
            .concat(parent['status']['tfstate']['resources']
                .filter(r=>r.mode=='managed'&&r.provider=='provider["registry.terraform.io/kbst/kustomization"]')
                .map(r=>r.instances).flat().map(r=>r.index_key.split('/')).map(([_,short,namespace,name])=>{return {short,namespace,name} })
                .filter(f=>f.short=='{{targetShort}}').map(f=>{return {namespace:f.namespace,name:f.name} }))
    {{#if (eq targetShort 'Secret')}}
            .concat(parent['status']['tfstate']['resources']
                .filter(r=>r.mode=='managed'&&r.provider=='provider["registry.terraform.io/hashicorp/kubernetes"]' && r.type=='kubernetes_secret_v1')
                .map(r=>r.instances.map(i=>{return {name: i.attributes.metadata[0].name, namespace: i.attributes.metadata[0].namespace} })).flat().flat())
    {{/if}}
    {{#if (eq targetShort 'ConfigMap')}}
            .concat(parent['status']['tfstate']['resources']
                .filter(r=>r.mode=='managed'&&r.provider=='provider["registry.terraform.io/hashicorp/kubernetes"]' && r.type=='kubernetes_config_map_v1')
                .map(r=>r.instances.map(i=>{return {name: i.attributes.metadata[0].name, namespace: i.attributes.metadata[0].namespace} })).flat().flat())
    {{/if}}
    {{#if (eq targetShort 'Namespace')}}
            .concat(parent['status']['tfstate']['resources']
                .filter(r=>r.mode=='managed'&&r.provider=='provider["registry.terraform.io/hashicorp/kubernetes"]' && r.type=='kubernetes_namespace_v1')
                .map(r=>r.instances.map(i=>{return {name: i.attributes.metadata[0].name, namespace: i.attributes.metadata[0].namespace} })).flat().flat())
    {{/if}}
        if (list.length<1) return null;
        const res = (await Promise.all(list.map(i=>i.namespace).filter((v,i,a)=>a.indexOf(v) === i).map(async (ns)=>{
            const names=list.filter(o=>o.namespace==ns).map(o=>o.name)
            const lst = await list{{targetGroup}}{{targetShort}}.{{targetGroup}}{{targetShort}}(parent, {namespace: ns, ...args})
            return lst.filter(r=>names.includes(r['metadata']['name']))
        }))).flat()
        if (Array.isArray(res) && res.length>0) return res;
        return null
    },
{{/if}}
{{#if (and (eq type 'users') (eq targetShort 'Distrib'))}}
    {{type}}{{targetGroup}}{{targetShort}}: async (used, args: object) => {
        if (used['metadata']['namespace']!=gramoConfig.vynilNamespace || used['metadata']['name'].match(/-clone/)==null ) return null;
        const lst = await list{{targetGroup}}{{targetShort}}.{{targetGroup}}{{targetShort}}(used,args)
    {{#if (eq short 'CronJob')}}
        return lst.filter(dist=>used['metadata']['name'] == dist['metadata']['name']+'-clone')
    {{else}}
        return lst.filter(dist=>used['metadata']['name'].startsWith(dist['metadata']['name']+'-clone'))
    {{/if}}
    },
{{/if}}
{{#if (and (eq type 'use') (eq short 'Distrib'))}}
    {{type}}{{targetGroup}}{{targetShort}}: async (dist, args: object) => {
        const lst = await list{{targetGroup}}{{targetShort}}.{{targetGroup}}{{targetShort}}(dist,{namespace: gramoConfig.vynilNamespace, ...args})
    {{#if (eq short 'CronJob')}}
        return lst.filter(used=>used['metadata']['name'] == dist['metadata']['name']+'-clone')
    {{else}}
        return lst.filter(used=>used['metadata']['name'].startsWith(dist['metadata']['name']+'-clone'))
    {{/if}}
    },
{{/if}}
{{#if (and (eq type 'users') (and (eq targetShort 'Install') (eq short 'Job')))}}
    {{type}}{{targetGroup}}{{targetShort}}: async (used, args: object) => {
        if (used['metadata']['namespace']!=gramoConfig.vynilNamespace || used['metadata']['name'].split('--').length!=3 ) return null;
        const lst = await list{{targetGroup}}{{targetShort}}.{{targetGroup}}{{targetShort}}(used,{namespace: used['metadata']['name'].split('--')[0], ...args})
        return lst.filter(inst=>inst['metadata']['name'] == used['metadata']['name'].split('--')[1])
    },
{{/if}}
{{#if (and (eq type 'use') (and (eq short 'Install') (eq targetShort 'Job')))}}
    {{type}}{{targetGroup}}{{targetShort}}: async (inst, args: object) => {
        const lst = await list{{targetGroup}}{{targetShort}}.{{targetGroup}}{{targetShort}}(inst,{namespace: gramoConfig.vynilNamespace, ...args})
        return lst.filter(job=>job['metadata']['name'].split('--').length==3 && `${inst['metadata']['namespace']}--${inst['metadata']['name']}--agent` == job['metadata']['name'])
    },
{{/if}}
