import k8s from '@kubernetes/client-node';
import rfc6902  from 'rfc6902';
import {kc, cache, applyFilter, applyFieldSelection, getByPath, {{#if namespaced}}getMetaNS{{else}}getMeta{{/if}} } from '../k8slibs.js';
import { lists as listNamespace } from '../k8s/Namespace.js';
import { gramoConfig } from '../../config.js'
{{#each listTargets}}
{{#unless (eq name 'Url')}}
import { lists as list{{group}}{{name}} } from '../{{group}}/{{name}}.js';
{{/unless}}
{{/each}}
{{#if (defined crd)}}
const k8sApi = kc.makeApiClient(k8s.CustomObjectsApi);
{{else}}
const k8sApi = kc.makeApiClient(k8s.{{capitalizeFirstLetter sub}}{{capitalizeFirstLetter apiVersion}}Api);
{{/if}}
export const mutations = {
{{> createResolver ctx=. }}
{{> deleteResolver ctx=. }}
{{> patchResolver ctx=. }}
};
export const lists = {
{{> listResolver ctx=. }}
};
{{#unless namespaced}}
export const queries = {
    {{group}}{{short}}: lists.{{group}}{{short}},
};
{{/unless}}
const localResolvers = {
{{#each autoResolvers}}
    {{#if (eq algo 'traefik')}}
{{> resolversTraefik algo=this.algo type=this.type targetShort=this.targetShort targetGroup=this.targetGroup path=this.path }}
    {{/if}}
    {{#if (eq algo 'certmanager')}}
{{> resolversCertManager algo=this.algo type=this.type targetShort=this.targetShort targetGroup=this.targetGroup path=this.path }}
    {{/if}}
    {{#if (eq algo 'fluxcd')}}
{{> resolversFluxCD algo=this.algo type=this.type targetShort=this.targetShort targetGroup=this.targetGroup path=this.path }}
    {{/if}}
    {{#if (eq algo 'vynil')}}
{{> resolversVynil algo=this.algo type=this.type targetShort=this.targetShort targetGroup=this.targetGroup path=this.path }}
    {{/if}}
    {{#if (eq algo 'selector')}}
{{> resolversSelector algo=this.algo type=this.type targetShort=this.targetShort targetGroup=this.targetGroup path=this.path }}
    {{/if}}
    {{#if (eq algo 'ingress')}}
{{> resolversIngress algo=this.algo type=this.type targetShort=this.targetShort targetGroup=this.targetGroup path=this.path }}
    {{/if}}
    {{#if (eq algo 'serviceAccount')}}
{{> resolversServiceAccount algo=this.algo type=this.type targetShort=this.targetShort targetGroup=this.targetGroup path=this.path }}
    {{/if}}
    {{#if (eq algo 'nodeName')}}
{{> resolversNodeName algo=this.algo type=this.type targetShort=this.targetShort targetGroup=this.targetGroup path=this.path }}
    {{/if}}
    {{#if (eq algo 'secret')}}
{{> resolversSecret algo=this.algo type=this.type targetShort=this.targetShort targetGroup=this.targetGroup path=this.path }}
    {{/if}}
    {{#if (eq algo 'configMap')}}
{{> resolversConfigMap algo=this.algo type=this.type targetShort=this.targetShort targetGroup=this.targetGroup path=this.path }}
    {{/if}}
    {{#if (eq algo 'storageClass')}}
{{> resolversStorageClass algo=this.algo type=this.type targetShort=this.targetShort targetGroup=this.targetGroup path=this.path }}
    {{/if}}
    {{#if (eq algo 'apiService')}}
{{> resolversApiService algo=this.algo type=this.type targetShort=this.targetShort targetGroup=this.targetGroup path=this.path }}
    {{/if}}
    {{#if (eq algo 'roleBinding')}}
{{> resolversRoleBinding algo=this.algo type=this.type targetShort=this.targetShort targetGroup=this.targetGroup path=this.path }}
    {{/if}}
    {{#if (eq algo 'role')}}
{{> resolversRole algo=this.algo type=this.type targetShort=this.targetShort targetGroup=this.targetGroup path=this.path }}
    {{/if}}
    {{#if (eq algo 'k8s')}}
{{> resolversK8S algo=this.algo type=this.type targetShort=this.targetShort targetGroup=this.targetGroup path=this.path }}
    {{/if}}
    {{#if (eq algo 'pvc')}}
{{> resolversPVC algo=this.algo type=this.type targetShort=this.targetShort targetGroup=this.targetGroup path=this.path }}
    {{/if}}
{{/each}}
};
export const resolvers = {
    {{group}}{{short}}: {
        parentReference: async (obj, args: object) => {
{{#if autoResolvers}}
            let res = null;
  {{#each autoResolvers}}
    {{#if (eq type 'parent')}}
            res = await localResolvers.{{type}}{{targetGroup}}{{targetShort}}(obj,args);
            if (res!=null) return {
                group: '{{targetGroup}}',
                short: '{{targetShort}}',
                name: res['metadata']['name'],
                namespace: res['metadata']['namespace']
            };
    {{/if}}
  {{/each}}
{{/if}}
            return null
        },
        ...localResolvers
    }
};
{{#if namespaced}}
export const nsResolver = {
    {{group}}{{short}}: async (parent, args: object) => {
        return lists.{{group}}{{short}}(parent,{namespace: parent.metadata.name, ...args})
    }
};
{{/if}}

