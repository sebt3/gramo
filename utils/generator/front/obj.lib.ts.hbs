import { QTableColumn } from 'quasar'
const { i18n } = await import("../i18n")
const { usePermissionStore } = await import('../../stores/permission.js')
const { watch, ref, gqlDataToYaml, useCore, useNavigationStoreRef, defineAsyncComponent } = await import('../core')
const { tableColumnAlign } = await import('../core/navigation.js')
export { onMounted, defineAsyncComponent, elude, getColor, getConditionColor, timeAgo, ref, useCore, useQuery, useMutation, sanitizeData, getProperties } from '../core';
export { i18n } from "../../libs/i18n"
export { {{ short }}ListExcludes, {{ short }}ListExcludes as itemListExcludes, {{ short }}ReadExcludes, {{ short }}ReadExcludes as itemReadExcludes, {{ short }}SimpleExcludes, {{ short }}SimpleExcludes as itemSimpleExcludes, icon{{ short }} as iconItem, color{{ short }} as colorItem, description{{ short }} as descriptionItem, short{{ short }} as shortItem, extra{{ short }}Columns as extraColumns } from './custom.js'
const { extra{{short}}Columns } = await import('./custom.js')
const { stringify, parse } = await import('yaml')
const can = usePermissionStore().can;
export const {{short}}Columns:Array<QTableColumn> = ([
  {name: 'Name', label: i18n.global.t('meta.name'), field: row => row.metadata.name, sortable: true, align: tableColumnAlign.left}
] as Array<QTableColumn>).concat(extra{{short}}Columns).concat([
  {name: 'Problems', label: i18n.global.t('core.status'), field: 'Ok', sortable: false, align: tableColumnAlign.right},
  {name: 'Action', label: i18n.global.t('core.action'), field: 'Action', sortable: false, align: tableColumnAlign.right}
]);
export const itemColumns = {{short}}Columns;
{{#if namespaced}}
export const {{short}}AllColumns = ([
  {name: 'Namespace', label: i18n.global.t('meta.namespace'), field: row => row.metadata.namespace, sortable: true, align: tableColumnAlign.left}
] as Array<QTableColumn>).concat({{short}}Columns);
{{else}}
export const {{short}}AllColumns = {{short}}Columns;
{{/if}}
export const extraComponents = [
{{#each extraComponents}}"{{this}}",{{/each}}
    {{#if (eq group 'cnpg')}}
{{> cnpgCustom ctx=. operation='extraComponents'}}
    {{/if}}
    {{#if (eq group 'fluxcd')}}
{{> fluxcdCustom ctx=. operation='extraComponents'}}
    {{/if}}
    {{#if (eq group 'k8s')}}
{{> k8sCustom ctx=. operation='extraComponents'}}
    {{/if}}
    {{#if (eq group 'k8up')}}
{{> k8upCustom ctx=. operation='extraComponents'}}
    {{/if}}
    {{#if (eq group 'monitoring')}}
{{> monitoringCustom ctx=. operation='extraComponents'}}
    {{/if}}
    {{#if (eq group 'redis')}}
{{> redisCustom ctx=. operation='extraComponents'}}
    {{/if}}
    {{#if (eq group 'secretgenerator')}}
{{> secretgeneratorCustom ctx=. operation='extraComponents'}}
    {{/if}}
    {{#if (eq group 'traefik')}}
{{> traefikCustom ctx=. operation='extraComponents'}}
    {{/if}}
    {{#if (eq group 'vynil')}}
{{> vynilCustom ctx=. operation='extraComponents'}}
    {{/if}}
    {{#if (eq group 'tekton')}}
{{> tektonCustom ctx=. operation='extraComponents'}}
    {{/if}}
    {{#if (eq group 'core')}}
{{> coreCustom ctx=. operation='extraComponents'}}
    {{/if}}
]
export const componentLoader = (name:string) => {
  switch (`${name}`) {
{{#each extraComponents}}
    case "{{this}}":{
      return defineAsyncComponent(() => import( '@/components/{{../group}}/{{../short}}{{this}}.vue'))
    }
{{/each}}
    {{#if (eq group 'cnpg')}}
{{> cnpgCustom ctx=. operation='componentLoader'}}
    {{/if}}
    {{#if (eq group 'fluxcd')}}
{{> fluxcdCustom ctx=. operation='componentLoader'}}
    {{/if}}
    {{#if (eq group 'k8s')}}
{{> k8sCustom ctx=. operation='componentLoader'}}
    {{/if}}
    {{#if (eq group 'k8up')}}
{{> k8upCustom ctx=. operation='componentLoader'}}
    {{/if}}
    {{#if (eq group 'monitoring')}}
{{> monitoringCustom ctx=. operation='componentLoader'}}
    {{/if}}
    {{#if (eq group 'redis')}}
{{> redisCustom ctx=. operation='componentLoader'}}
    {{/if}}
    {{#if (eq group 'secretgenerator')}}
{{> secretgeneratorCustom ctx=. operation='componentLoader'}}
    {{/if}}
    {{#if (eq group 'traefik')}}
{{> traefikCustom ctx=. operation='componentLoader'}}
    {{/if}}
    {{#if (eq group 'vynil')}}
{{> vynilCustom ctx=. operation='componentLoader'}}
    {{/if}}
    {{#if (eq group 'tekton')}}
{{> tektonCustom ctx=. operation='componentLoader'}}
    {{/if}}
    {{#if (eq group 'core')}}
{{> coreCustom ctx=. operation='componentLoader'}}
    {{/if}}
  }
  return null
}
export const componentHave = (name:string, model:object) => {
  return extraComponents.includes(name) &&
    {{#if (eq group 'cnpg')}}
{{> cnpgCustom ctx=. operation='componentHave'}}
    {{/if}}
    {{#if (eq group 'fluxcd')}}
{{> fluxcdCustom ctx=. operation='componentHave'}}
    {{/if}}
    {{#if (eq group 'k8s')}}
{{> k8sCustom ctx=. operation='componentHave'}}
    {{/if}}
    {{#if (eq group 'k8up')}}
{{> k8upCustom ctx=. operation='componentHave'}}
    {{/if}}
    {{#if (eq group 'monitoring')}}
{{> monitoringCustom ctx=. operation='componentHave'}}
    {{/if}}
    {{#if (eq group 'redis')}}
{{> redisCustom ctx=. operation='componentHave'}}
    {{/if}}
    {{#if (eq group 'secretgenerator')}}
{{> secretgeneratorCustom ctx=. operation='componentHave'}}
    {{/if}}
    {{#if (eq group 'traefik')}}
{{> traefikCustom ctx=. operation='componentHave'}}
    {{/if}}
    {{#if (eq group 'vynil')}}
{{> vynilCustom ctx=. operation='componentHave'}}
    {{/if}}
    {{#if (eq group 'tekton')}}
{{> tektonCustom ctx=. operation='componentHave'}}
    {{/if}}
    {{#if (eq group 'core')}}
{{> coreCustom ctx=. operation='componentHave'}}
    {{/if}}
    true
}
export const itemAllColumns = {{short}}AllColumns;
const { isNamespaced, setNamespaceFromRoute, setNamespacedItemFromRoute } = await import('../../libs/core/navigation.js')
export const namespaced = {{#if namespaced}}true{{else}}false{{/if}};
export const {{short}}Definition = {{toJson definition}};
export const itemDefinition = {{short}}Definition;
export function use{{ short }}(router) {
  const { $q, onErrorHandler, notify, notifySuccess, notifyError, notifyWorking } = useCore();
  const viewer = ref({
      tab: 'meta',
      full: '',
      props: {
{{#each writeProperties}}
        "{{this}}": '',
{{/each}}
      }
  });
  const onlyReadProperties = (obj) => Object.keys(obj).filter(k=>{{toJsonKeys readProperties}}.includes(k)||k=='metadata').reduce((res,k)=>{res[k] = obj[k]; return res},{});
  const onlyWriteProperties = (obj) => Object.keys(obj).filter(k=>{{toJsonKeys writeProperties}}.includes(k)).reduce((res,k)=>{res[k] = obj[k];return res},{});
  const editor = ref({
      tab: 'simple',
      showDoc: false,
      yaml: '',
      obj: ref({}),
      setKey: (key:string, o:object) => {
        if (key!=null) {
          editor.value.obj[key] = o;editor.value.yaml = stringify(editor.value.obj)
        } else {
          Object.keys(o).forEach(key=>{editor.value.obj[key] = o[key]})
          editor.value.yaml = stringify(editor.value.obj)
        }
      },
      ready: false,
      setYaml: (y) => {editor.value.yaml = y;const tmp = parse(y);Object.keys(tmp).forEach(k=>editor.value.obj[k]=tmp[k]);},
      updateFromQuery: (obj: object) => {
        editor.value.ready=false;
        editor.value.obj = onlyWriteProperties(obj);
        editor.value.yaml = stringify(editor.value.obj);
        editor.value.ready=true;
      },
  });
  return {
    onlyReadProperties, onlyWriteProperties, editor, viewer, $q, viewerUpdate: (obj) => {
      viewer.value.full=gqlDataToYaml(obj)
{{#each writeProperties}}
      viewer.value.props["{{this}}"]=gqlDataToYaml({"{{this}}": obj["{{this}}"]})
{{/each}}
    },
    can: (verb:string, namespace?:string) => can(verb, '{{group}}', '{{short}}', namespace),
    readProperties: {{toJsonKeys readProperties}},
    writeProperties: {{toJsonKeys writeProperties}},
    navigation: useNavigationStoreRef(),
    isNamespaced, setNamespaceFromRoute, setNamespacedItemFromRoute, namespaced: {{#if namespaced}}true{{else}}false{{/if}},
    notify, notifySuccess, notifyError, notifyWorking, onErrorHandler,
    onNot{{ short }}Found: (res) => {
{{#if namespaced}}
    if ( !res.loading && res.data.k8sNamespace[0].{{group}}{{short}} == null) {
{{else}}
    if ( !res.loading && res.data.{{group}}{{short}} == null) {
{{/if}}
        const matched = router.currentRoute.value.matched
        notifyError(i18n.global.t('core.notFound', {short: '{{ short }}'}));
        router.push({
          path: matched[matched.length>1?matched.length-2:matched.length-1].path,
          replace: true
        })
      }
    },
{{#if namespaced}}
    toView: (namespace, name) => router.push({ name: '{{group}}{{short}}View', params: {name, namespace}}),
    toViewReloaded: async (namespace, name) => {await router.push({ name: '{{group}}{{short}}View', params: {name, namespace}});router.go(0);},
    toEdit: (namespace, name) => router.push({ name: '{{group}}{{short}}Edit', params: {name, namespace}}),
    toList: (namespace) => router.push({ name: '{{group}}{{short}}Table', params: {namespace}}),
{{else}}
    toView: (name) => router.push({ name: '{{group}}{{short}}View', params: {name}}),
    toViewReloaded: async (name) => {await router.push({ name: '{{group}}{{short}}View', params: {name}});router.go(0);},
    toEdit: (name) => router.push({ name: '{{group}}{{short}}Edit', params: {name}}),
{{/if}}
    toParentView: (group,short,name,namespace) => router.push({ name: `${group}${short}View`, params: {name,namespace}}),
    deleteDone: () => notifySuccess(i18n.global.t('delete.notifyDone')),
    deleteError: (err) => {
      notifyError(i18n.global.t('delete.notifyError'));
      console.log('deletion error',err);
    },
    patchDone: () => {
      notifySuccess(i18n.global.t('edit.notifyDone'));
      router.go(-1);
    },
    patchError: (err) => {
      notifyError(i18n.global.t('edit.notifyError'));
      console.log('mutation error', err)
    },
{{#if namespaced}}
    actionNew: (namespace)    => router.push({ name: '{{group}}{{short}}Create', params: {namespace}}),
{{else}}
    actionNew: ()    => router.push({ name: '{{group}}{{short}}Create'}),
{{/if}}
    actionDelete: (deletor:(o:object)=>any, meta:object) => {
      $q.dialog({
        title: i18n.global.t('delete.title'),
        message: i18n.global.t('delete.message',{short: '{{short}}', name: meta.name}),
        persistent: true, cancel: true, html: true, ok: {color: 'negative'}
      }).onOk(() => {
        notifyWorking(i18n.global.t('delete.notifyWorking'));
{{#if (defined crd)}}
{{#if namespaced}}
        deletor({"group": '{{apiGroup}}', "version": '{{apiVersion}}', "plural": '{{crd.status.acceptedNames.plural}}', "name": meta.name, "namespace":meta.namespace});
{{else}}
        deletor({"group": '{{apiGroup}}', "version": '{{apiVersion}}', "plural": '{{crd.status.acceptedNames.plural}}', "name": meta.name});
{{/if}}
{{else}}
{{#if namespaced}}
        deletor({"name": meta.name, "namespace":meta.namespace});
{{else}}
        deletor({"name": meta.name});
{{/if}}
{{/if}}
      })
    },
  }
}
export const useItem = use{{ short }}