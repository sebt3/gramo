{
  "name": "cilium",
  "objects": [
    {
      "alternatives": [],
      "name": "io.cilium.v2.CiliumClusterwideNetworkPolicy",
      "definition": {
        "description": "CiliumClusterwideNetworkPolicy is a Kubernetes third-party resource with an modified version of CiliumNetworkPolicy which is cluster scoped rather than namespace scoped.",
        "type": "object",
        "required": [
          "metadata"
        ],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "spec": {
            "description": "Spec is the desired Cilium specific rule specification.",
            "type": "object",
            "properties": {
              "description": {
                "description": "Description is a free form string, it can be used by the creator of the rule to store human readable explanation of the purpose of this rule. Rules cannot be identified by comment.",
                "type": "string"
              },
              "egress": {
                "description": "Egress is a list of EgressRule which are enforced at egress. If omitted or empty, this rule does not apply at egress.",
                "type": "array",
                "items": {
                  "description": "EgressRule contains all rule types which can be applied at egress, i.e. network traffic that originates inside the endpoint and exits the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members of the structure are specified, then all members     must match in order for the rule to take effect. The exception to this     rule is the ToRequires member; the effects of any Requires field in any     rule will apply to all other rules as well. \n   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are     mutually exclusive. Only one of these members may be present within an     individual rule.",
                  "type": "object",
                  "properties": {
                    "authentication": {
                      "description": "Authentication is the required authentication type for the allowed traffic, if any.",
                      "type": "object",
                      "required": [
                        "mode"
                      ],
                      "properties": {
                        "mode": {
                          "description": "Mode is the required authentication mode for the allowed traffic, if any.",
                          "type": "string",
                          "enum": [
                            "disabled",
                            "required",
                            "test-always-fail"
                          ]
                        }
                      }
                    },
                    "icmps": {
                      "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is allowed to initiate type 8 ICMP connections.",
                      "type": "array",
                      "items": {
                        "description": "ICMPRule is a list of ICMP fields.",
                        "type": "object",
                        "properties": {
                          "fields": {
                            "description": "Fields is a list of ICMP fields.",
                            "type": "array",
                            "items": {
                              "description": "ICMPField is a ICMP field.",
                              "type": "object",
                              "required": [
                                "type"
                              ],
                              "properties": {
                                "family": {
                                  "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                  "type": "string",
                                  "enum": [
                                    "IPv4",
                                    "IPv6"
                                  ]
                                },
                                "type": {
                                  "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                  "type": "integer",
                                  "maximum": 255,
                                  "minimum": 0
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "toCIDR": {
                      "description": "ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules.  This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24",
                      "type": "array",
                      "items": {
                        "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                        "type": "string",
                        "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                      }
                    },
                    "toCIDRSet": {
                      "description": "ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.",
                      "type": "array",
                      "items": {
                        "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                        "type": "object",
                        "properties": {
                          "cidr": {
                            "description": "CIDR is a CIDR prefix / IP Block.",
                            "type": "string",
                            "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                          },
                          "cidrGroupRef": {
                            "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                            "type": "string",
                            "maxLength": 253,
                            "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                          },
                          "except": {
                            "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                            "type": "array",
                            "items": {
                              "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                              "type": "string",
                              "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                            }
                          }
                        }
                      }
                    },
                    "toEndpoints": {
                      "description": "ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\".",
                      "type": "array",
                      "items": {
                        "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                        "type": "object",
                        "properties": {
                          "matchExpressions": {
                            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                            "type": "array",
                            "items": {
                              "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                              "type": "object",
                              "required": [
                                "key",
                                "operator"
                              ],
                              "properties": {
                                "key": {
                                  "description": "key is the label key that the selector applies to.",
                                  "type": "string"
                                },
                                "operator": {
                                  "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                  "type": "string",
                                  "enum": [
                                    "In",
                                    "NotIn",
                                    "Exists",
                                    "DoesNotExist"
                                  ]
                                },
                                "values": {
                                  "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          },
                          "matchLabels": {
                            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                            "type": "object",
                            "additionalProperties": {
                              "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                              "type": "string",
                              "maxLength": 63,
                              "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                            }
                          }
                        }
                      }
                    },
                    "toEntities": {
                      "description": "ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`, `health`,`unmanaged` and `all`.",
                      "type": "array",
                      "items": {
                        "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                        "type": "string",
                        "enum": [
                          "all",
                          "world",
                          "cluster",
                          "host",
                          "init",
                          "ingress",
                          "unmanaged",
                          "remote-node",
                          "health",
                          "none",
                          "kube-apiserver"
                        ]
                      }
                    },
                    "toFQDNs": {
                      "description": "ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result from DNS resolution of `ToFQDN.MatchName`s are added to the same EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and L7 rules within this EgressRule will also apply to these IPs. The DNS -> IP mapping is re-resolved periodically from within the cilium-agent, and the IPs in the DNS response are effected in the policy for selected pods as-is (i.e. the list of IPs is not modified in any way). Note: An explicit rule to allow for DNS traffic is needed for the pods, as ToFQDN counts as an egress rule and will enforce egress policy when PolicyEnforcment=default. Note: If the resolved IPs are IPs within the kubernetes cluster, the ToFQDN rule will not apply to that IP. Note: ToFQDN cannot occur in the same policy as other To* rules.",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "matchName": {
                            "description": "MatchName matches literal DNS names. A trailing \".\" is automatically added when missing.",
                            "type": "string",
                            "pattern": "^([-a-zA-Z0-9_]+[.]?)+$"
                          },
                          "matchPattern": {
                            "description": "MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"*\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"*\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: `*.cilium.io` matches subomains of cilium at that level   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with \"cilium.io\"   except those containing \".\" separator, subcilium.io and sub-cilium.io match,   www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\"   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,   blog.cilium.io, cilium.io and google.com do not",
                            "type": "string",
                            "pattern": "^([-a-zA-Z0-9_*]+[.]?)+$"
                          }
                        }
                      }
                    },
                    "toGroups": {
                      "description": "ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws:     securityGroupsIds:     - 'sg-XXXXXXXXXXXXX'",
                      "type": "array",
                      "items": {
                        "description": "ToGroups structure to store all kinds of new integrations that needs a new derivative policy.",
                        "type": "object",
                        "properties": {
                          "aws": {
                            "description": "AWSGroup is an structure that can be used to whitelisting information from AWS integration",
                            "type": "object",
                            "properties": {
                              "labels": {
                                "type": "object",
                                "additionalProperties": {
                                  "type": "string"
                                }
                              },
                              "region": {
                                "type": "string"
                              },
                              "securityGroupsIds": {
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              },
                              "securityGroupsNames": {
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "toPorts": {
                      "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is allowed to initiate connections to destination port 8080/tcp",
                      "type": "array",
                      "items": {
                        "description": "PortRule is a list of ports/protocol combinations with optional Layer 7 rules which must be met.",
                        "type": "object",
                        "properties": {
                          "listener": {
                            "description": "listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.",
                            "type": "object",
                            "required": [
                              "envoyConfig",
                              "name"
                            ],
                            "properties": {
                              "envoyConfig": {
                                "description": "EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.",
                                "type": "object",
                                "required": [
                                  "name"
                                ],
                                "properties": {
                                  "kind": {
                                    "description": "Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.",
                                    "type": "string",
                                    "enum": [
                                      "CiliumEnvoyConfig",
                                      "CiliumClusterwideEnvoyConfig"
                                    ]
                                  },
                                  "name": {
                                    "description": "Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where the listener is defined in.",
                                    "type": "string",
                                    "minLength": 1
                                  }
                                }
                              },
                              "name": {
                                "description": "Name is the name of the listener.",
                                "type": "string",
                                "minLength": 1
                              }
                            }
                          },
                          "originatingTLS": {
                            "description": "OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.",
                            "type": "object",
                            "required": [
                              "secret"
                            ],
                            "properties": {
                              "certificate": {
                                "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                "type": "string"
                              },
                              "privateKey": {
                                "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                "type": "string"
                              },
                              "secret": {
                                "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                "type": "object",
                                "required": [
                                  "name"
                                ],
                                "properties": {
                                  "name": {
                                    "description": "Name is the name of the secret.",
                                    "type": "string"
                                  },
                                  "namespace": {
                                    "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                    "type": "string"
                                  }
                                }
                              },
                              "trustedCA": {
                                "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                "type": "string"
                              }
                            }
                          },
                          "ports": {
                            "description": "Ports is a list of L4 port/protocol",
                            "type": "array",
                            "items": {
                              "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                              "type": "object",
                              "required": [
                                "port"
                              ],
                              "properties": {
                                "port": {
                                  "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                  "type": "string",
                                  "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                },
                                "protocol": {
                                  "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                  "type": "string",
                                  "enum": [
                                    "TCP",
                                    "UDP",
                                    "SCTP",
                                    "ANY"
                                  ]
                                }
                              }
                            }
                          },
                          "rules": {
                            "description": "Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.",
                            "type": "object",
                            "properties": {
                              "dns": {
                                "description": "DNS-specific rules.",
                                "type": "array",
                                "items": {
                                  "description": "PortRuleDNS is a list of allowed DNS lookups.",
                                  "type": "object",
                                  "properties": {
                                    "matchName": {
                                      "description": "MatchName matches literal DNS names. A trailing \".\" is automatically added when missing.",
                                      "type": "string",
                                      "pattern": "^([-a-zA-Z0-9_]+[.]?)+$"
                                    },
                                    "matchPattern": {
                                      "description": "MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"*\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"*\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: `*.cilium.io` matches subomains of cilium at that level   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with \"cilium.io\"   except those containing \".\" separator, subcilium.io and sub-cilium.io match,   www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\"   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,   blog.cilium.io, cilium.io and google.com do not",
                                      "type": "string",
                                      "pattern": "^([-a-zA-Z0-9_*]+[.]?)+$"
                                    }
                                  }
                                }
                              },
                              "http": {
                                "description": "HTTP specific rules.",
                                "type": "array",
                                "items": {
                                  "description": "PortRuleHTTP is a list of HTTP protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect. \n All fields of this type are extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986.",
                                  "type": "object",
                                  "properties": {
                                    "headerMatches": {
                                      "description": "HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match.",
                                      "type": "array",
                                      "items": {
                                        "description": "HeaderMatch extends the HeaderValue for matching requirement of a named header field against an immediate string, a secret value, or a regex.  If none of the optional fields is present, then the header value is not matched, only presence of the header is enough.",
                                        "type": "object",
                                        "required": [
                                          "name"
                                        ],
                                        "properties": {
                                          "mismatch": {
                                            "description": "Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.",
                                            "type": "string",
                                            "enum": [
                                              "LOG",
                                              "ADD",
                                              "DELETE",
                                              "REPLACE"
                                            ]
                                          },
                                          "name": {
                                            "description": "Name identifies the header.",
                                            "type": "string"
                                          },
                                          "secret": {
                                            "description": "Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no \"Value\" specified, the match will fail.",
                                            "type": "object",
                                            "required": [
                                              "name"
                                            ],
                                            "properties": {
                                              "name": {
                                                "description": "Name is the name of the secret.",
                                                "type": "string"
                                              },
                                              "namespace": {
                                                "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                                "type": "string"
                                              }
                                            }
                                          },
                                          "value": {
                                            "description": "Value matches the exact value of the header. Can be specified either alone or together with \"Secret\"; will be used as the header value if the secret can not be found in the latter case.",
                                            "type": "string"
                                          }
                                        }
                                      }
                                    },
                                    "headers": {
                                      "description": "Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present.",
                                      "type": "array",
                                      "items": {
                                        "type": "string"
                                      }
                                    },
                                    "host": {
                                      "description": "Host is an extended POSIX regex matched against the host header of a request, e.g. \"foo.com\" \n If omitted or empty, the value of the host header is ignored.",
                                      "type": "string",
                                      "format": "idn-hostname"
                                    },
                                    "method": {
                                      "description": "Method is an extended POSIX regex matched against the method of a request, e.g. \"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\", ... \n If omitted or empty, all methods are allowed.",
                                      "type": "string"
                                    },
                                    "path": {
                                      "description": "Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986. \n If omitted or empty, all paths are all allowed.",
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "kafka": {
                                "description": "Kafka-specific rules.",
                                "type": "array",
                                "items": {
                                  "description": "PortRule is a list of Kafka protocol constraints. All fields are optional, if all fields are empty or missing, the rule will match all Kafka messages.",
                                  "type": "object",
                                  "properties": {
                                    "apiKey": {
                                      "description": "APIKey is a case-insensitive string matched against the key of a request, e.g. \"produce\", \"fetch\", \"createtopic\", \"deletetopic\", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys \n If omitted or empty, and if Role is not specified, then all keys are allowed.",
                                      "type": "string"
                                    },
                                    "apiVersion": {
                                      "description": "APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer. \n If omitted or empty, all versions are allowed.",
                                      "type": "string"
                                    },
                                    "clientID": {
                                      "description": "ClientID is the client identifier as provided in the request. \n From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client. \n If omitted or empty, all client identifiers are allowed.",
                                      "type": "string"
                                    },
                                    "role": {
                                      "description": "Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as \"produce\" or \"consume\". A Role automatically expands into all APIKeys required to perform the specified higher-level operation. \n The following values are supported:  - \"produce\": Allow producing to the topics specified in the rule  - \"consume\": Allow consuming from the topics specified in the rule \n This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule. \n If omitted or empty, and if APIKey is not specified, then all keys are allowed.",
                                      "type": "string",
                                      "enum": [
                                        "produce",
                                        "consume"
                                      ]
                                    },
                                    "topic": {
                                      "description": "Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected. \n This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _. \n Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255. \n If omitted or empty, all topics are allowed.",
                                      "type": "string",
                                      "maxLength": 255
                                    }
                                  }
                                }
                              },
                              "l7": {
                                "description": "Key-value pair rules.",
                                "type": "array",
                                "items": {
                                  "description": "PortRuleL7 is a list of key-value pairs interpreted by a L7 protocol as protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect.",
                                  "type": "object",
                                  "additionalProperties": {
                                    "type": "string"
                                  }
                                }
                              },
                              "l7proto": {
                                "description": "Name of the L7 protocol for which the Key-value pair rules apply.",
                                "type": "string"
                              }
                            }
                          },
                          "serverNames": {
                            "description": "ServerNames is a list of allowed TLS SNI values. If not empty, then TLS must be present and one of the provided SNIs must be indicated in the TLS handshake.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "terminatingTLS": {
                            "description": "TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.",
                            "type": "object",
                            "required": [
                              "secret"
                            ],
                            "properties": {
                              "certificate": {
                                "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                "type": "string"
                              },
                              "privateKey": {
                                "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                "type": "string"
                              },
                              "secret": {
                                "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                "type": "object",
                                "required": [
                                  "name"
                                ],
                                "properties": {
                                  "name": {
                                    "description": "Name is the name of the secret.",
                                    "type": "string"
                                  },
                                  "namespace": {
                                    "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                    "type": "string"
                                  }
                                }
                              },
                              "trustedCA": {
                                "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    },
                    "toRequires": {
                      "description": "ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\".",
                      "type": "array",
                      "items": {
                        "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                        "type": "object",
                        "properties": {
                          "matchExpressions": {
                            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                            "type": "array",
                            "items": {
                              "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                              "type": "object",
                              "required": [
                                "key",
                                "operator"
                              ],
                              "properties": {
                                "key": {
                                  "description": "key is the label key that the selector applies to.",
                                  "type": "string"
                                },
                                "operator": {
                                  "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                  "type": "string",
                                  "enum": [
                                    "In",
                                    "NotIn",
                                    "Exists",
                                    "DoesNotExist"
                                  ]
                                },
                                "values": {
                                  "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          },
                          "matchLabels": {
                            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                            "type": "object",
                            "additionalProperties": {
                              "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                              "type": "string",
                              "maxLength": 63,
                              "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                            }
                          }
                        }
                      }
                    },
                    "toServices": {
                      "description": "ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service",
                      "type": "array",
                      "items": {
                        "description": "Service wraps around selectors for services",
                        "type": "object",
                        "properties": {
                          "k8sService": {
                            "description": "K8sService selects service by name and namespace pair",
                            "type": "object",
                            "properties": {
                              "namespace": {
                                "type": "string"
                              },
                              "serviceName": {
                                "type": "string"
                              }
                            }
                          },
                          "k8sServiceSelector": {
                            "description": "K8sServiceSelector selects services by k8s labels and namespace",
                            "type": "object",
                            "required": [
                              "selector"
                            ],
                            "properties": {
                              "namespace": {
                                "type": "string"
                              },
                              "selector": {
                                "description": "ServiceSelector is a label selector for k8s services",
                                "type": "object",
                                "properties": {
                                  "matchExpressions": {
                                    "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                    "type": "array",
                                    "items": {
                                      "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                      "type": "object",
                                      "required": [
                                        "key",
                                        "operator"
                                      ],
                                      "properties": {
                                        "key": {
                                          "description": "key is the label key that the selector applies to.",
                                          "type": "string"
                                        },
                                        "operator": {
                                          "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                          "type": "string",
                                          "enum": [
                                            "In",
                                            "NotIn",
                                            "Exists",
                                            "DoesNotExist"
                                          ]
                                        },
                                        "values": {
                                          "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                          "type": "array",
                                          "items": {
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  },
                                  "matchLabels": {
                                    "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                    "type": "object",
                                    "additionalProperties": {
                                      "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                      "type": "string",
                                      "maxLength": 63,
                                      "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              },
              "egressDeny": {
                "description": "EgressDeny is a list of EgressDenyRule which are enforced at egress. Any rule inserted here will be denied regardless of the allowed egress rules in the 'egress' field. If omitted or empty, this rule does not apply at egress.",
                "type": "array",
                "items": {
                  "description": "EgressDenyRule contains all rule types which can be applied at egress, i.e. network traffic that originates inside the endpoint and exits the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members of the structure are specified, then all members     must match in order for the rule to take effect. The exception to this     rule is the ToRequires member; the effects of any Requires field in any     rule will apply to all other rules as well. \n   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are     mutually exclusive. Only one of these members may be present within an     individual rule.",
                  "type": "object",
                  "properties": {
                    "icmps": {
                      "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is not allowed to initiate type 8 ICMP connections.",
                      "type": "array",
                      "items": {
                        "description": "ICMPRule is a list of ICMP fields.",
                        "type": "object",
                        "properties": {
                          "fields": {
                            "description": "Fields is a list of ICMP fields.",
                            "type": "array",
                            "items": {
                              "description": "ICMPField is a ICMP field.",
                              "type": "object",
                              "required": [
                                "type"
                              ],
                              "properties": {
                                "family": {
                                  "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                  "type": "string",
                                  "enum": [
                                    "IPv4",
                                    "IPv6"
                                  ]
                                },
                                "type": {
                                  "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                  "type": "integer",
                                  "maximum": 255,
                                  "minimum": 0
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "toCIDR": {
                      "description": "ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules.  This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24",
                      "type": "array",
                      "items": {
                        "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                        "type": "string",
                        "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                      }
                    },
                    "toCIDRSet": {
                      "description": "ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.",
                      "type": "array",
                      "items": {
                        "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                        "type": "object",
                        "properties": {
                          "cidr": {
                            "description": "CIDR is a CIDR prefix / IP Block.",
                            "type": "string",
                            "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                          },
                          "cidrGroupRef": {
                            "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                            "type": "string",
                            "maxLength": 253,
                            "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                          },
                          "except": {
                            "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                            "type": "array",
                            "items": {
                              "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                              "type": "string",
                              "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                            }
                          }
                        }
                      }
                    },
                    "toEndpoints": {
                      "description": "ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\".",
                      "type": "array",
                      "items": {
                        "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                        "type": "object",
                        "properties": {
                          "matchExpressions": {
                            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                            "type": "array",
                            "items": {
                              "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                              "type": "object",
                              "required": [
                                "key",
                                "operator"
                              ],
                              "properties": {
                                "key": {
                                  "description": "key is the label key that the selector applies to.",
                                  "type": "string"
                                },
                                "operator": {
                                  "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                  "type": "string",
                                  "enum": [
                                    "In",
                                    "NotIn",
                                    "Exists",
                                    "DoesNotExist"
                                  ]
                                },
                                "values": {
                                  "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          },
                          "matchLabels": {
                            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                            "type": "object",
                            "additionalProperties": {
                              "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                              "type": "string",
                              "maxLength": 63,
                              "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                            }
                          }
                        }
                      }
                    },
                    "toEntities": {
                      "description": "ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`, `health`,`unmanaged` and `all`.",
                      "type": "array",
                      "items": {
                        "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                        "type": "string",
                        "enum": [
                          "all",
                          "world",
                          "cluster",
                          "host",
                          "init",
                          "ingress",
                          "unmanaged",
                          "remote-node",
                          "health",
                          "none",
                          "kube-apiserver"
                        ]
                      }
                    },
                    "toGroups": {
                      "description": "ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws:     securityGroupsIds:     - 'sg-XXXXXXXXXXXXX'",
                      "type": "array",
                      "items": {
                        "description": "ToGroups structure to store all kinds of new integrations that needs a new derivative policy.",
                        "type": "object",
                        "properties": {
                          "aws": {
                            "description": "AWSGroup is an structure that can be used to whitelisting information from AWS integration",
                            "type": "object",
                            "properties": {
                              "labels": {
                                "type": "object",
                                "additionalProperties": {
                                  "type": "string"
                                }
                              },
                              "region": {
                                "type": "string"
                              },
                              "securityGroupsIds": {
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              },
                              "securityGroupsNames": {
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "toPorts": {
                      "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is not allowed to initiate connections to destination port 8080/tcp",
                      "type": "array",
                      "items": {
                        "description": "PortDenyRule is a list of ports/protocol that should be used for deny policies. This structure lacks the L7Rules since it's not supported in deny policies.",
                        "type": "object",
                        "properties": {
                          "ports": {
                            "description": "Ports is a list of L4 port/protocol",
                            "type": "array",
                            "items": {
                              "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                              "type": "object",
                              "required": [
                                "port"
                              ],
                              "properties": {
                                "port": {
                                  "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                  "type": "string",
                                  "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                },
                                "protocol": {
                                  "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                  "type": "string",
                                  "enum": [
                                    "TCP",
                                    "UDP",
                                    "SCTP",
                                    "ANY"
                                  ]
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "toRequires": {
                      "description": "ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\".",
                      "type": "array",
                      "items": {
                        "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                        "type": "object",
                        "properties": {
                          "matchExpressions": {
                            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                            "type": "array",
                            "items": {
                              "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                              "type": "object",
                              "required": [
                                "key",
                                "operator"
                              ],
                              "properties": {
                                "key": {
                                  "description": "key is the label key that the selector applies to.",
                                  "type": "string"
                                },
                                "operator": {
                                  "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                  "type": "string",
                                  "enum": [
                                    "In",
                                    "NotIn",
                                    "Exists",
                                    "DoesNotExist"
                                  ]
                                },
                                "values": {
                                  "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          },
                          "matchLabels": {
                            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                            "type": "object",
                            "additionalProperties": {
                              "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                              "type": "string",
                              "maxLength": 63,
                              "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                            }
                          }
                        }
                      }
                    },
                    "toServices": {
                      "description": "ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service",
                      "type": "array",
                      "items": {
                        "description": "Service wraps around selectors for services",
                        "type": "object",
                        "properties": {
                          "k8sService": {
                            "description": "K8sService selects service by name and namespace pair",
                            "type": "object",
                            "properties": {
                              "namespace": {
                                "type": "string"
                              },
                              "serviceName": {
                                "type": "string"
                              }
                            }
                          },
                          "k8sServiceSelector": {
                            "description": "K8sServiceSelector selects services by k8s labels and namespace",
                            "type": "object",
                            "required": [
                              "selector"
                            ],
                            "properties": {
                              "namespace": {
                                "type": "string"
                              },
                              "selector": {
                                "description": "ServiceSelector is a label selector for k8s services",
                                "type": "object",
                                "properties": {
                                  "matchExpressions": {
                                    "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                    "type": "array",
                                    "items": {
                                      "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                      "type": "object",
                                      "required": [
                                        "key",
                                        "operator"
                                      ],
                                      "properties": {
                                        "key": {
                                          "description": "key is the label key that the selector applies to.",
                                          "type": "string"
                                        },
                                        "operator": {
                                          "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                          "type": "string",
                                          "enum": [
                                            "In",
                                            "NotIn",
                                            "Exists",
                                            "DoesNotExist"
                                          ]
                                        },
                                        "values": {
                                          "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                          "type": "array",
                                          "items": {
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  },
                                  "matchLabels": {
                                    "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                    "type": "object",
                                    "additionalProperties": {
                                      "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                      "type": "string",
                                      "maxLength": 63,
                                      "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              },
              "endpointSelector": {
                "description": "EndpointSelector selects all endpoints which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive.",
                "type": "object",
                "properties": {
                  "matchExpressions": {
                    "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                    "type": "array",
                    "items": {
                      "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                      "type": "object",
                      "required": [
                        "key",
                        "operator"
                      ],
                      "properties": {
                        "key": {
                          "description": "key is the label key that the selector applies to.",
                          "type": "string"
                        },
                        "operator": {
                          "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                          "type": "string",
                          "enum": [
                            "In",
                            "NotIn",
                            "Exists",
                            "DoesNotExist"
                          ]
                        },
                        "values": {
                          "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        }
                      }
                    }
                  },
                  "matchLabels": {
                    "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                    "type": "object",
                    "additionalProperties": {
                      "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                      "type": "string",
                      "maxLength": 63,
                      "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                    }
                  }
                }
              },
              "ingress": {
                "description": "Ingress is a list of IngressRule which are enforced at ingress. If omitted or empty, this rule does not apply at ingress.",
                "type": "array",
                "items": {
                  "description": "IngressRule contains all rule types which can be applied at ingress, i.e. network traffic that originates outside of the endpoint and is entering the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members are set, all of them need to match in order for     the rule to take effect. The exception to this rule is FromRequires field;     the effects of any Requires field in any rule will apply to all other     rules as well. \n   - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually     exclusive. Only one of these members may be present within an individual     rule.",
                  "type": "object",
                  "properties": {
                    "authentication": {
                      "description": "Authentication is the required authentication type for the allowed traffic, if any.",
                      "type": "object",
                      "required": [
                        "mode"
                      ],
                      "properties": {
                        "mode": {
                          "description": "Mode is the required authentication mode for the allowed traffic, if any.",
                          "type": "string",
                          "enum": [
                            "disabled",
                            "required",
                            "test-always-fail"
                          ]
                        }
                      }
                    },
                    "fromCIDR": {
                      "description": "FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do *not* originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field.  This will match on the source IP address of incoming connections. Adding  a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.3.9.1",
                      "type": "array",
                      "items": {
                        "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                        "type": "string",
                        "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                      }
                    },
                    "fromCIDRSet": {
                      "description": "FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.",
                      "type": "array",
                      "items": {
                        "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                        "type": "object",
                        "properties": {
                          "cidr": {
                            "description": "CIDR is a CIDR prefix / IP Block.",
                            "type": "string",
                            "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                          },
                          "cidrGroupRef": {
                            "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                            "type": "string",
                            "maxLength": 253,
                            "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                          },
                          "except": {
                            "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                            "type": "array",
                            "items": {
                              "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                              "type": "string",
                              "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                            }
                          }
                        }
                      }
                    },
                    "fromEndpoints": {
                      "description": "FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\".",
                      "type": "array",
                      "items": {
                        "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                        "type": "object",
                        "properties": {
                          "matchExpressions": {
                            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                            "type": "array",
                            "items": {
                              "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                              "type": "object",
                              "required": [
                                "key",
                                "operator"
                              ],
                              "properties": {
                                "key": {
                                  "description": "key is the label key that the selector applies to.",
                                  "type": "string"
                                },
                                "operator": {
                                  "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                  "type": "string",
                                  "enum": [
                                    "In",
                                    "NotIn",
                                    "Exists",
                                    "DoesNotExist"
                                  ]
                                },
                                "values": {
                                  "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          },
                          "matchLabels": {
                            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                            "type": "object",
                            "additionalProperties": {
                              "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                              "type": "string",
                              "maxLength": 63,
                              "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                            }
                          }
                        }
                      }
                    },
                    "fromEntities": {
                      "description": "FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are `world`, `cluster` and `host`",
                      "type": "array",
                      "items": {
                        "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                        "type": "string",
                        "enum": [
                          "all",
                          "world",
                          "cluster",
                          "host",
                          "init",
                          "ingress",
                          "unmanaged",
                          "remote-node",
                          "health",
                          "none",
                          "kube-apiserver"
                        ]
                      }
                    },
                    "fromRequires": {
                      "description": "FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\".",
                      "type": "array",
                      "items": {
                        "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                        "type": "object",
                        "properties": {
                          "matchExpressions": {
                            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                            "type": "array",
                            "items": {
                              "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                              "type": "object",
                              "required": [
                                "key",
                                "operator"
                              ],
                              "properties": {
                                "key": {
                                  "description": "key is the label key that the selector applies to.",
                                  "type": "string"
                                },
                                "operator": {
                                  "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                  "type": "string",
                                  "enum": [
                                    "In",
                                    "NotIn",
                                    "Exists",
                                    "DoesNotExist"
                                  ]
                                },
                                "values": {
                                  "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          },
                          "matchLabels": {
                            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                            "type": "object",
                            "additionalProperties": {
                              "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                              "type": "string",
                              "maxLength": 63,
                              "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                            }
                          }
                        }
                      }
                    },
                    "icmps": {
                      "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming type 8 ICMP connections.",
                      "type": "array",
                      "items": {
                        "description": "ICMPRule is a list of ICMP fields.",
                        "type": "object",
                        "properties": {
                          "fields": {
                            "description": "Fields is a list of ICMP fields.",
                            "type": "array",
                            "items": {
                              "description": "ICMPField is a ICMP field.",
                              "type": "object",
                              "required": [
                                "type"
                              ],
                              "properties": {
                                "family": {
                                  "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                  "type": "string",
                                  "enum": [
                                    "IPv4",
                                    "IPv6"
                                  ]
                                },
                                "type": {
                                  "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                  "type": "integer",
                                  "maximum": 255,
                                  "minimum": 0
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "toPorts": {
                      "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming connections on port 80/tcp.",
                      "type": "array",
                      "items": {
                        "description": "PortRule is a list of ports/protocol combinations with optional Layer 7 rules which must be met.",
                        "type": "object",
                        "properties": {
                          "listener": {
                            "description": "listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.",
                            "type": "object",
                            "required": [
                              "envoyConfig",
                              "name"
                            ],
                            "properties": {
                              "envoyConfig": {
                                "description": "EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.",
                                "type": "object",
                                "required": [
                                  "name"
                                ],
                                "properties": {
                                  "kind": {
                                    "description": "Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.",
                                    "type": "string",
                                    "enum": [
                                      "CiliumEnvoyConfig",
                                      "CiliumClusterwideEnvoyConfig"
                                    ]
                                  },
                                  "name": {
                                    "description": "Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where the listener is defined in.",
                                    "type": "string",
                                    "minLength": 1
                                  }
                                }
                              },
                              "name": {
                                "description": "Name is the name of the listener.",
                                "type": "string",
                                "minLength": 1
                              }
                            }
                          },
                          "originatingTLS": {
                            "description": "OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.",
                            "type": "object",
                            "required": [
                              "secret"
                            ],
                            "properties": {
                              "certificate": {
                                "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                "type": "string"
                              },
                              "privateKey": {
                                "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                "type": "string"
                              },
                              "secret": {
                                "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                "type": "object",
                                "required": [
                                  "name"
                                ],
                                "properties": {
                                  "name": {
                                    "description": "Name is the name of the secret.",
                                    "type": "string"
                                  },
                                  "namespace": {
                                    "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                    "type": "string"
                                  }
                                }
                              },
                              "trustedCA": {
                                "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                "type": "string"
                              }
                            }
                          },
                          "ports": {
                            "description": "Ports is a list of L4 port/protocol",
                            "type": "array",
                            "items": {
                              "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                              "type": "object",
                              "required": [
                                "port"
                              ],
                              "properties": {
                                "port": {
                                  "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                  "type": "string",
                                  "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                },
                                "protocol": {
                                  "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                  "type": "string",
                                  "enum": [
                                    "TCP",
                                    "UDP",
                                    "SCTP",
                                    "ANY"
                                  ]
                                }
                              }
                            }
                          },
                          "rules": {
                            "description": "Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.",
                            "type": "object",
                            "properties": {
                              "dns": {
                                "description": "DNS-specific rules.",
                                "type": "array",
                                "items": {
                                  "description": "PortRuleDNS is a list of allowed DNS lookups.",
                                  "type": "object",
                                  "properties": {
                                    "matchName": {
                                      "description": "MatchName matches literal DNS names. A trailing \".\" is automatically added when missing.",
                                      "type": "string",
                                      "pattern": "^([-a-zA-Z0-9_]+[.]?)+$"
                                    },
                                    "matchPattern": {
                                      "description": "MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"*\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"*\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: `*.cilium.io` matches subomains of cilium at that level   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with \"cilium.io\"   except those containing \".\" separator, subcilium.io and sub-cilium.io match,   www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\"   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,   blog.cilium.io, cilium.io and google.com do not",
                                      "type": "string",
                                      "pattern": "^([-a-zA-Z0-9_*]+[.]?)+$"
                                    }
                                  }
                                }
                              },
                              "http": {
                                "description": "HTTP specific rules.",
                                "type": "array",
                                "items": {
                                  "description": "PortRuleHTTP is a list of HTTP protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect. \n All fields of this type are extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986.",
                                  "type": "object",
                                  "properties": {
                                    "headerMatches": {
                                      "description": "HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match.",
                                      "type": "array",
                                      "items": {
                                        "description": "HeaderMatch extends the HeaderValue for matching requirement of a named header field against an immediate string, a secret value, or a regex.  If none of the optional fields is present, then the header value is not matched, only presence of the header is enough.",
                                        "type": "object",
                                        "required": [
                                          "name"
                                        ],
                                        "properties": {
                                          "mismatch": {
                                            "description": "Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.",
                                            "type": "string",
                                            "enum": [
                                              "LOG",
                                              "ADD",
                                              "DELETE",
                                              "REPLACE"
                                            ]
                                          },
                                          "name": {
                                            "description": "Name identifies the header.",
                                            "type": "string"
                                          },
                                          "secret": {
                                            "description": "Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no \"Value\" specified, the match will fail.",
                                            "type": "object",
                                            "required": [
                                              "name"
                                            ],
                                            "properties": {
                                              "name": {
                                                "description": "Name is the name of the secret.",
                                                "type": "string"
                                              },
                                              "namespace": {
                                                "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                                "type": "string"
                                              }
                                            }
                                          },
                                          "value": {
                                            "description": "Value matches the exact value of the header. Can be specified either alone or together with \"Secret\"; will be used as the header value if the secret can not be found in the latter case.",
                                            "type": "string"
                                          }
                                        }
                                      }
                                    },
                                    "headers": {
                                      "description": "Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present.",
                                      "type": "array",
                                      "items": {
                                        "type": "string"
                                      }
                                    },
                                    "host": {
                                      "description": "Host is an extended POSIX regex matched against the host header of a request, e.g. \"foo.com\" \n If omitted or empty, the value of the host header is ignored.",
                                      "type": "string",
                                      "format": "idn-hostname"
                                    },
                                    "method": {
                                      "description": "Method is an extended POSIX regex matched against the method of a request, e.g. \"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\", ... \n If omitted or empty, all methods are allowed.",
                                      "type": "string"
                                    },
                                    "path": {
                                      "description": "Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986. \n If omitted or empty, all paths are all allowed.",
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "kafka": {
                                "description": "Kafka-specific rules.",
                                "type": "array",
                                "items": {
                                  "description": "PortRule is a list of Kafka protocol constraints. All fields are optional, if all fields are empty or missing, the rule will match all Kafka messages.",
                                  "type": "object",
                                  "properties": {
                                    "apiKey": {
                                      "description": "APIKey is a case-insensitive string matched against the key of a request, e.g. \"produce\", \"fetch\", \"createtopic\", \"deletetopic\", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys \n If omitted or empty, and if Role is not specified, then all keys are allowed.",
                                      "type": "string"
                                    },
                                    "apiVersion": {
                                      "description": "APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer. \n If omitted or empty, all versions are allowed.",
                                      "type": "string"
                                    },
                                    "clientID": {
                                      "description": "ClientID is the client identifier as provided in the request. \n From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client. \n If omitted or empty, all client identifiers are allowed.",
                                      "type": "string"
                                    },
                                    "role": {
                                      "description": "Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as \"produce\" or \"consume\". A Role automatically expands into all APIKeys required to perform the specified higher-level operation. \n The following values are supported:  - \"produce\": Allow producing to the topics specified in the rule  - \"consume\": Allow consuming from the topics specified in the rule \n This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule. \n If omitted or empty, and if APIKey is not specified, then all keys are allowed.",
                                      "type": "string",
                                      "enum": [
                                        "produce",
                                        "consume"
                                      ]
                                    },
                                    "topic": {
                                      "description": "Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected. \n This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _. \n Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255. \n If omitted or empty, all topics are allowed.",
                                      "type": "string",
                                      "maxLength": 255
                                    }
                                  }
                                }
                              },
                              "l7": {
                                "description": "Key-value pair rules.",
                                "type": "array",
                                "items": {
                                  "description": "PortRuleL7 is a list of key-value pairs interpreted by a L7 protocol as protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect.",
                                  "type": "object",
                                  "additionalProperties": {
                                    "type": "string"
                                  }
                                }
                              },
                              "l7proto": {
                                "description": "Name of the L7 protocol for which the Key-value pair rules apply.",
                                "type": "string"
                              }
                            }
                          },
                          "serverNames": {
                            "description": "ServerNames is a list of allowed TLS SNI values. If not empty, then TLS must be present and one of the provided SNIs must be indicated in the TLS handshake.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "terminatingTLS": {
                            "description": "TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.",
                            "type": "object",
                            "required": [
                              "secret"
                            ],
                            "properties": {
                              "certificate": {
                                "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                "type": "string"
                              },
                              "privateKey": {
                                "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                "type": "string"
                              },
                              "secret": {
                                "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                "type": "object",
                                "required": [
                                  "name"
                                ],
                                "properties": {
                                  "name": {
                                    "description": "Name is the name of the secret.",
                                    "type": "string"
                                  },
                                  "namespace": {
                                    "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                    "type": "string"
                                  }
                                }
                              },
                              "trustedCA": {
                                "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              },
              "ingressDeny": {
                "description": "IngressDeny is a list of IngressDenyRule which are enforced at ingress. Any rule inserted here will be denied regardless of the allowed ingress rules in the 'ingress' field. If omitted or empty, this rule does not apply at ingress.",
                "type": "array",
                "items": {
                  "description": "IngressDenyRule contains all rule types which can be applied at ingress, i.e. network traffic that originates outside of the endpoint and is entering the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members are set, all of them need to match in order for     the rule to take effect. The exception to this rule is FromRequires field;     the effects of any Requires field in any rule will apply to all other     rules as well. \n   - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually     exclusive. Only one of these members may be present within an individual     rule.",
                  "type": "object",
                  "properties": {
                    "fromCIDR": {
                      "description": "FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do *not* originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field.  This will match on the source IP address of incoming connections. Adding  a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.3.9.1",
                      "type": "array",
                      "items": {
                        "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                        "type": "string",
                        "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                      }
                    },
                    "fromCIDRSet": {
                      "description": "FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.",
                      "type": "array",
                      "items": {
                        "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                        "type": "object",
                        "properties": {
                          "cidr": {
                            "description": "CIDR is a CIDR prefix / IP Block.",
                            "type": "string",
                            "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                          },
                          "cidrGroupRef": {
                            "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                            "type": "string",
                            "maxLength": 253,
                            "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                          },
                          "except": {
                            "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                            "type": "array",
                            "items": {
                              "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                              "type": "string",
                              "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                            }
                          }
                        }
                      }
                    },
                    "fromEndpoints": {
                      "description": "FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\".",
                      "type": "array",
                      "items": {
                        "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                        "type": "object",
                        "properties": {
                          "matchExpressions": {
                            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                            "type": "array",
                            "items": {
                              "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                              "type": "object",
                              "required": [
                                "key",
                                "operator"
                              ],
                              "properties": {
                                "key": {
                                  "description": "key is the label key that the selector applies to.",
                                  "type": "string"
                                },
                                "operator": {
                                  "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                  "type": "string",
                                  "enum": [
                                    "In",
                                    "NotIn",
                                    "Exists",
                                    "DoesNotExist"
                                  ]
                                },
                                "values": {
                                  "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          },
                          "matchLabels": {
                            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                            "type": "object",
                            "additionalProperties": {
                              "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                              "type": "string",
                              "maxLength": 63,
                              "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                            }
                          }
                        }
                      }
                    },
                    "fromEntities": {
                      "description": "FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are `world`, `cluster` and `host`",
                      "type": "array",
                      "items": {
                        "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                        "type": "string",
                        "enum": [
                          "all",
                          "world",
                          "cluster",
                          "host",
                          "init",
                          "ingress",
                          "unmanaged",
                          "remote-node",
                          "health",
                          "none",
                          "kube-apiserver"
                        ]
                      }
                    },
                    "fromRequires": {
                      "description": "FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\".",
                      "type": "array",
                      "items": {
                        "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                        "type": "object",
                        "properties": {
                          "matchExpressions": {
                            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                            "type": "array",
                            "items": {
                              "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                              "type": "object",
                              "required": [
                                "key",
                                "operator"
                              ],
                              "properties": {
                                "key": {
                                  "description": "key is the label key that the selector applies to.",
                                  "type": "string"
                                },
                                "operator": {
                                  "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                  "type": "string",
                                  "enum": [
                                    "In",
                                    "NotIn",
                                    "Exists",
                                    "DoesNotExist"
                                  ]
                                },
                                "values": {
                                  "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          },
                          "matchLabels": {
                            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                            "type": "object",
                            "additionalProperties": {
                              "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                              "type": "string",
                              "maxLength": 63,
                              "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                            }
                          }
                        }
                      }
                    },
                    "icmps": {
                      "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming type 8 ICMP connections.",
                      "type": "array",
                      "items": {
                        "description": "ICMPRule is a list of ICMP fields.",
                        "type": "object",
                        "properties": {
                          "fields": {
                            "description": "Fields is a list of ICMP fields.",
                            "type": "array",
                            "items": {
                              "description": "ICMPField is a ICMP field.",
                              "type": "object",
                              "required": [
                                "type"
                              ],
                              "properties": {
                                "family": {
                                  "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                  "type": "string",
                                  "enum": [
                                    "IPv4",
                                    "IPv6"
                                  ]
                                },
                                "type": {
                                  "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                  "type": "integer",
                                  "maximum": 255,
                                  "minimum": 0
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "toPorts": {
                      "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming connections on port 80/tcp.",
                      "type": "array",
                      "items": {
                        "description": "PortDenyRule is a list of ports/protocol that should be used for deny policies. This structure lacks the L7Rules since it's not supported in deny policies.",
                        "type": "object",
                        "properties": {
                          "ports": {
                            "description": "Ports is a list of L4 port/protocol",
                            "type": "array",
                            "items": {
                              "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                              "type": "object",
                              "required": [
                                "port"
                              ],
                              "properties": {
                                "port": {
                                  "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                  "type": "string",
                                  "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                },
                                "protocol": {
                                  "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                  "type": "string",
                                  "enum": [
                                    "TCP",
                                    "UDP",
                                    "SCTP",
                                    "ANY"
                                  ]
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              },
              "labels": {
                "description": "Labels is a list of optional strings which can be used to re-identify the rule or to store metadata. It is possible to lookup or delete strings based on labels. Labels are not required to be unique, multiple rules can have overlapping or identical labels.",
                "type": "array",
                "items": {
                  "description": "Label is the Cilium's representation of a container label.",
                  "type": "object",
                  "required": [
                    "key"
                  ],
                  "properties": {
                    "key": {
                      "type": "string"
                    },
                    "source": {
                      "description": "Source can be one of the above values (e.g.: LabelSourceContainer).",
                      "type": "string"
                    },
                    "value": {
                      "type": "string"
                    }
                  }
                }
              },
              "nodeSelector": {
                "description": "NodeSelector selects all nodes which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive. Can only be used in CiliumClusterwideNetworkPolicies.",
                "type": "object",
                "properties": {
                  "matchExpressions": {
                    "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                    "type": "array",
                    "items": {
                      "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                      "type": "object",
                      "required": [
                        "key",
                        "operator"
                      ],
                      "properties": {
                        "key": {
                          "description": "key is the label key that the selector applies to.",
                          "type": "string"
                        },
                        "operator": {
                          "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                          "type": "string",
                          "enum": [
                            "In",
                            "NotIn",
                            "Exists",
                            "DoesNotExist"
                          ]
                        },
                        "values": {
                          "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        }
                      }
                    }
                  },
                  "matchLabels": {
                    "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                    "type": "object",
                    "additionalProperties": {
                      "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                      "type": "string",
                      "maxLength": 63,
                      "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                    }
                  }
                }
              }
            }
          },
          "specs": {
            "description": "Specs is a list of desired Cilium specific rule specification.",
            "type": "array",
            "items": {
              "description": "Rule is a policy rule which must be applied to all endpoints which match the labels contained in the endpointSelector \n Each rule is split into an ingress section which contains all rules applicable at ingress, and an egress section applicable at egress. For rule types such as `L4Rule` and `CIDR` which can be applied at both ingress and egress, both ingress and egress side have to either specifically allow the connection or one side has to be omitted. \n Either ingress, egress, or both can be provided. If both ingress and egress are omitted, the rule has no effect.",
              "type": "object",
              "properties": {
                "description": {
                  "description": "Description is a free form string, it can be used by the creator of the rule to store human readable explanation of the purpose of this rule. Rules cannot be identified by comment.",
                  "type": "string"
                },
                "egress": {
                  "description": "Egress is a list of EgressRule which are enforced at egress. If omitted or empty, this rule does not apply at egress.",
                  "type": "array",
                  "items": {
                    "description": "EgressRule contains all rule types which can be applied at egress, i.e. network traffic that originates inside the endpoint and exits the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members of the structure are specified, then all members     must match in order for the rule to take effect. The exception to this     rule is the ToRequires member; the effects of any Requires field in any     rule will apply to all other rules as well. \n   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are     mutually exclusive. Only one of these members may be present within an     individual rule.",
                    "type": "object",
                    "properties": {
                      "authentication": {
                        "description": "Authentication is the required authentication type for the allowed traffic, if any.",
                        "type": "object",
                        "required": [
                          "mode"
                        ],
                        "properties": {
                          "mode": {
                            "description": "Mode is the required authentication mode for the allowed traffic, if any.",
                            "type": "string",
                            "enum": [
                              "disabled",
                              "required",
                              "test-always-fail"
                            ]
                          }
                        }
                      },
                      "icmps": {
                        "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is allowed to initiate type 8 ICMP connections.",
                        "type": "array",
                        "items": {
                          "description": "ICMPRule is a list of ICMP fields.",
                          "type": "object",
                          "properties": {
                            "fields": {
                              "description": "Fields is a list of ICMP fields.",
                              "type": "array",
                              "items": {
                                "description": "ICMPField is a ICMP field.",
                                "type": "object",
                                "required": [
                                  "type"
                                ],
                                "properties": {
                                  "family": {
                                    "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                    "type": "string",
                                    "enum": [
                                      "IPv4",
                                      "IPv6"
                                    ]
                                  },
                                  "type": {
                                    "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                    "type": "integer",
                                    "maximum": 255,
                                    "minimum": 0
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      "toCIDR": {
                        "description": "ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules.  This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24",
                        "type": "array",
                        "items": {
                          "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                          "type": "string",
                          "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                        }
                      },
                      "toCIDRSet": {
                        "description": "ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.",
                        "type": "array",
                        "items": {
                          "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                          "type": "object",
                          "properties": {
                            "cidr": {
                              "description": "CIDR is a CIDR prefix / IP Block.",
                              "type": "string",
                              "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                            },
                            "cidrGroupRef": {
                              "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                              "type": "string",
                              "maxLength": 253,
                              "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                            },
                            "except": {
                              "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                              "type": "array",
                              "items": {
                                "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                "type": "string",
                                "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                              }
                            }
                          }
                        }
                      },
                      "toEndpoints": {
                        "description": "ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\".",
                        "type": "array",
                        "items": {
                          "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                          "type": "object",
                          "properties": {
                            "matchExpressions": {
                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                              "type": "array",
                              "items": {
                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "key is the label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                    "type": "string",
                                    "enum": [
                                      "In",
                                      "NotIn",
                                      "Exists",
                                      "DoesNotExist"
                                    ]
                                  },
                                  "values": {
                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "matchLabels": {
                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                              "type": "object",
                              "additionalProperties": {
                                "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                "type": "string",
                                "maxLength": 63,
                                "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                              }
                            }
                          }
                        }
                      },
                      "toEntities": {
                        "description": "ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`, `health`,`unmanaged` and `all`.",
                        "type": "array",
                        "items": {
                          "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                          "type": "string",
                          "enum": [
                            "all",
                            "world",
                            "cluster",
                            "host",
                            "init",
                            "ingress",
                            "unmanaged",
                            "remote-node",
                            "health",
                            "none",
                            "kube-apiserver"
                          ]
                        }
                      },
                      "toFQDNs": {
                        "description": "ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result from DNS resolution of `ToFQDN.MatchName`s are added to the same EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and L7 rules within this EgressRule will also apply to these IPs. The DNS -> IP mapping is re-resolved periodically from within the cilium-agent, and the IPs in the DNS response are effected in the policy for selected pods as-is (i.e. the list of IPs is not modified in any way). Note: An explicit rule to allow for DNS traffic is needed for the pods, as ToFQDN counts as an egress rule and will enforce egress policy when PolicyEnforcment=default. Note: If the resolved IPs are IPs within the kubernetes cluster, the ToFQDN rule will not apply to that IP. Note: ToFQDN cannot occur in the same policy as other To* rules.",
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "matchName": {
                              "description": "MatchName matches literal DNS names. A trailing \".\" is automatically added when missing.",
                              "type": "string",
                              "pattern": "^([-a-zA-Z0-9_]+[.]?)+$"
                            },
                            "matchPattern": {
                              "description": "MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"*\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"*\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: `*.cilium.io` matches subomains of cilium at that level   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with \"cilium.io\"   except those containing \".\" separator, subcilium.io and sub-cilium.io match,   www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\"   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,   blog.cilium.io, cilium.io and google.com do not",
                              "type": "string",
                              "pattern": "^([-a-zA-Z0-9_*]+[.]?)+$"
                            }
                          }
                        }
                      },
                      "toGroups": {
                        "description": "ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws:     securityGroupsIds:     - 'sg-XXXXXXXXXXXXX'",
                        "type": "array",
                        "items": {
                          "description": "ToGroups structure to store all kinds of new integrations that needs a new derivative policy.",
                          "type": "object",
                          "properties": {
                            "aws": {
                              "description": "AWSGroup is an structure that can be used to whitelisting information from AWS integration",
                              "type": "object",
                              "properties": {
                                "labels": {
                                  "type": "object",
                                  "additionalProperties": {
                                    "type": "string"
                                  }
                                },
                                "region": {
                                  "type": "string"
                                },
                                "securityGroupsIds": {
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                },
                                "securityGroupsNames": {
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      "toPorts": {
                        "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is allowed to initiate connections to destination port 8080/tcp",
                        "type": "array",
                        "items": {
                          "description": "PortRule is a list of ports/protocol combinations with optional Layer 7 rules which must be met.",
                          "type": "object",
                          "properties": {
                            "listener": {
                              "description": "listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.",
                              "type": "object",
                              "required": [
                                "envoyConfig",
                                "name"
                              ],
                              "properties": {
                                "envoyConfig": {
                                  "description": "EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.",
                                  "type": "object",
                                  "required": [
                                    "name"
                                  ],
                                  "properties": {
                                    "kind": {
                                      "description": "Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.",
                                      "type": "string",
                                      "enum": [
                                        "CiliumEnvoyConfig",
                                        "CiliumClusterwideEnvoyConfig"
                                      ]
                                    },
                                    "name": {
                                      "description": "Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where the listener is defined in.",
                                      "type": "string",
                                      "minLength": 1
                                    }
                                  }
                                },
                                "name": {
                                  "description": "Name is the name of the listener.",
                                  "type": "string",
                                  "minLength": 1
                                }
                              }
                            },
                            "originatingTLS": {
                              "description": "OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.",
                              "type": "object",
                              "required": [
                                "secret"
                              ],
                              "properties": {
                                "certificate": {
                                  "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                  "type": "string"
                                },
                                "privateKey": {
                                  "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                  "type": "string"
                                },
                                "secret": {
                                  "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                  "type": "object",
                                  "required": [
                                    "name"
                                  ],
                                  "properties": {
                                    "name": {
                                      "description": "Name is the name of the secret.",
                                      "type": "string"
                                    },
                                    "namespace": {
                                      "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                      "type": "string"
                                    }
                                  }
                                },
                                "trustedCA": {
                                  "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                  "type": "string"
                                }
                              }
                            },
                            "ports": {
                              "description": "Ports is a list of L4 port/protocol",
                              "type": "array",
                              "items": {
                                "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                                "type": "object",
                                "required": [
                                  "port"
                                ],
                                "properties": {
                                  "port": {
                                    "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                    "type": "string",
                                    "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                  },
                                  "protocol": {
                                    "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                    "type": "string",
                                    "enum": [
                                      "TCP",
                                      "UDP",
                                      "SCTP",
                                      "ANY"
                                    ]
                                  }
                                }
                              }
                            },
                            "rules": {
                              "description": "Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.",
                              "type": "object",
                              "properties": {
                                "dns": {
                                  "description": "DNS-specific rules.",
                                  "type": "array",
                                  "items": {
                                    "description": "PortRuleDNS is a list of allowed DNS lookups.",
                                    "type": "object",
                                    "properties": {
                                      "matchName": {
                                        "description": "MatchName matches literal DNS names. A trailing \".\" is automatically added when missing.",
                                        "type": "string",
                                        "pattern": "^([-a-zA-Z0-9_]+[.]?)+$"
                                      },
                                      "matchPattern": {
                                        "description": "MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"*\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"*\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: `*.cilium.io` matches subomains of cilium at that level   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with \"cilium.io\"   except those containing \".\" separator, subcilium.io and sub-cilium.io match,   www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\"   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,   blog.cilium.io, cilium.io and google.com do not",
                                        "type": "string",
                                        "pattern": "^([-a-zA-Z0-9_*]+[.]?)+$"
                                      }
                                    }
                                  }
                                },
                                "http": {
                                  "description": "HTTP specific rules.",
                                  "type": "array",
                                  "items": {
                                    "description": "PortRuleHTTP is a list of HTTP protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect. \n All fields of this type are extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986.",
                                    "type": "object",
                                    "properties": {
                                      "headerMatches": {
                                        "description": "HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match.",
                                        "type": "array",
                                        "items": {
                                          "description": "HeaderMatch extends the HeaderValue for matching requirement of a named header field against an immediate string, a secret value, or a regex.  If none of the optional fields is present, then the header value is not matched, only presence of the header is enough.",
                                          "type": "object",
                                          "required": [
                                            "name"
                                          ],
                                          "properties": {
                                            "mismatch": {
                                              "description": "Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.",
                                              "type": "string",
                                              "enum": [
                                                "LOG",
                                                "ADD",
                                                "DELETE",
                                                "REPLACE"
                                              ]
                                            },
                                            "name": {
                                              "description": "Name identifies the header.",
                                              "type": "string"
                                            },
                                            "secret": {
                                              "description": "Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no \"Value\" specified, the match will fail.",
                                              "type": "object",
                                              "required": [
                                                "name"
                                              ],
                                              "properties": {
                                                "name": {
                                                  "description": "Name is the name of the secret.",
                                                  "type": "string"
                                                },
                                                "namespace": {
                                                  "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                                  "type": "string"
                                                }
                                              }
                                            },
                                            "value": {
                                              "description": "Value matches the exact value of the header. Can be specified either alone or together with \"Secret\"; will be used as the header value if the secret can not be found in the latter case.",
                                              "type": "string"
                                            }
                                          }
                                        }
                                      },
                                      "headers": {
                                        "description": "Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present.",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        }
                                      },
                                      "host": {
                                        "description": "Host is an extended POSIX regex matched against the host header of a request, e.g. \"foo.com\" \n If omitted or empty, the value of the host header is ignored.",
                                        "type": "string",
                                        "format": "idn-hostname"
                                      },
                                      "method": {
                                        "description": "Method is an extended POSIX regex matched against the method of a request, e.g. \"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\", ... \n If omitted or empty, all methods are allowed.",
                                        "type": "string"
                                      },
                                      "path": {
                                        "description": "Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986. \n If omitted or empty, all paths are all allowed.",
                                        "type": "string"
                                      }
                                    }
                                  }
                                },
                                "kafka": {
                                  "description": "Kafka-specific rules.",
                                  "type": "array",
                                  "items": {
                                    "description": "PortRule is a list of Kafka protocol constraints. All fields are optional, if all fields are empty or missing, the rule will match all Kafka messages.",
                                    "type": "object",
                                    "properties": {
                                      "apiKey": {
                                        "description": "APIKey is a case-insensitive string matched against the key of a request, e.g. \"produce\", \"fetch\", \"createtopic\", \"deletetopic\", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys \n If omitted or empty, and if Role is not specified, then all keys are allowed.",
                                        "type": "string"
                                      },
                                      "apiVersion": {
                                        "description": "APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer. \n If omitted or empty, all versions are allowed.",
                                        "type": "string"
                                      },
                                      "clientID": {
                                        "description": "ClientID is the client identifier as provided in the request. \n From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client. \n If omitted or empty, all client identifiers are allowed.",
                                        "type": "string"
                                      },
                                      "role": {
                                        "description": "Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as \"produce\" or \"consume\". A Role automatically expands into all APIKeys required to perform the specified higher-level operation. \n The following values are supported:  - \"produce\": Allow producing to the topics specified in the rule  - \"consume\": Allow consuming from the topics specified in the rule \n This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule. \n If omitted or empty, and if APIKey is not specified, then all keys are allowed.",
                                        "type": "string",
                                        "enum": [
                                          "produce",
                                          "consume"
                                        ]
                                      },
                                      "topic": {
                                        "description": "Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected. \n This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _. \n Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255. \n If omitted or empty, all topics are allowed.",
                                        "type": "string",
                                        "maxLength": 255
                                      }
                                    }
                                  }
                                },
                                "l7": {
                                  "description": "Key-value pair rules.",
                                  "type": "array",
                                  "items": {
                                    "description": "PortRuleL7 is a list of key-value pairs interpreted by a L7 protocol as protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect.",
                                    "type": "object",
                                    "additionalProperties": {
                                      "type": "string"
                                    }
                                  }
                                },
                                "l7proto": {
                                  "description": "Name of the L7 protocol for which the Key-value pair rules apply.",
                                  "type": "string"
                                }
                              }
                            },
                            "serverNames": {
                              "description": "ServerNames is a list of allowed TLS SNI values. If not empty, then TLS must be present and one of the provided SNIs must be indicated in the TLS handshake.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            },
                            "terminatingTLS": {
                              "description": "TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.",
                              "type": "object",
                              "required": [
                                "secret"
                              ],
                              "properties": {
                                "certificate": {
                                  "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                  "type": "string"
                                },
                                "privateKey": {
                                  "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                  "type": "string"
                                },
                                "secret": {
                                  "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                  "type": "object",
                                  "required": [
                                    "name"
                                  ],
                                  "properties": {
                                    "name": {
                                      "description": "Name is the name of the secret.",
                                      "type": "string"
                                    },
                                    "namespace": {
                                      "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                      "type": "string"
                                    }
                                  }
                                },
                                "trustedCA": {
                                  "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                  "type": "string"
                                }
                              }
                            }
                          }
                        }
                      },
                      "toRequires": {
                        "description": "ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\".",
                        "type": "array",
                        "items": {
                          "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                          "type": "object",
                          "properties": {
                            "matchExpressions": {
                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                              "type": "array",
                              "items": {
                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "key is the label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                    "type": "string",
                                    "enum": [
                                      "In",
                                      "NotIn",
                                      "Exists",
                                      "DoesNotExist"
                                    ]
                                  },
                                  "values": {
                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "matchLabels": {
                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                              "type": "object",
                              "additionalProperties": {
                                "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                "type": "string",
                                "maxLength": 63,
                                "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                              }
                            }
                          }
                        }
                      },
                      "toServices": {
                        "description": "ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service",
                        "type": "array",
                        "items": {
                          "description": "Service wraps around selectors for services",
                          "type": "object",
                          "properties": {
                            "k8sService": {
                              "description": "K8sService selects service by name and namespace pair",
                              "type": "object",
                              "properties": {
                                "namespace": {
                                  "type": "string"
                                },
                                "serviceName": {
                                  "type": "string"
                                }
                              }
                            },
                            "k8sServiceSelector": {
                              "description": "K8sServiceSelector selects services by k8s labels and namespace",
                              "type": "object",
                              "required": [
                                "selector"
                              ],
                              "properties": {
                                "namespace": {
                                  "type": "string"
                                },
                                "selector": {
                                  "description": "ServiceSelector is a label selector for k8s services",
                                  "type": "object",
                                  "properties": {
                                    "matchExpressions": {
                                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                      "type": "array",
                                      "items": {
                                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                        "type": "object",
                                        "required": [
                                          "key",
                                          "operator"
                                        ],
                                        "properties": {
                                          "key": {
                                            "description": "key is the label key that the selector applies to.",
                                            "type": "string"
                                          },
                                          "operator": {
                                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                            "type": "string",
                                            "enum": [
                                              "In",
                                              "NotIn",
                                              "Exists",
                                              "DoesNotExist"
                                            ]
                                          },
                                          "values": {
                                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "matchLabels": {
                                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                      "type": "object",
                                      "additionalProperties": {
                                        "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                        "type": "string",
                                        "maxLength": 63,
                                        "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "egressDeny": {
                  "description": "EgressDeny is a list of EgressDenyRule which are enforced at egress. Any rule inserted here will be denied regardless of the allowed egress rules in the 'egress' field. If omitted or empty, this rule does not apply at egress.",
                  "type": "array",
                  "items": {
                    "description": "EgressDenyRule contains all rule types which can be applied at egress, i.e. network traffic that originates inside the endpoint and exits the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members of the structure are specified, then all members     must match in order for the rule to take effect. The exception to this     rule is the ToRequires member; the effects of any Requires field in any     rule will apply to all other rules as well. \n   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are     mutually exclusive. Only one of these members may be present within an     individual rule.",
                    "type": "object",
                    "properties": {
                      "icmps": {
                        "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is not allowed to initiate type 8 ICMP connections.",
                        "type": "array",
                        "items": {
                          "description": "ICMPRule is a list of ICMP fields.",
                          "type": "object",
                          "properties": {
                            "fields": {
                              "description": "Fields is a list of ICMP fields.",
                              "type": "array",
                              "items": {
                                "description": "ICMPField is a ICMP field.",
                                "type": "object",
                                "required": [
                                  "type"
                                ],
                                "properties": {
                                  "family": {
                                    "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                    "type": "string",
                                    "enum": [
                                      "IPv4",
                                      "IPv6"
                                    ]
                                  },
                                  "type": {
                                    "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                    "type": "integer",
                                    "maximum": 255,
                                    "minimum": 0
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      "toCIDR": {
                        "description": "ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules.  This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24",
                        "type": "array",
                        "items": {
                          "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                          "type": "string",
                          "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                        }
                      },
                      "toCIDRSet": {
                        "description": "ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.",
                        "type": "array",
                        "items": {
                          "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                          "type": "object",
                          "properties": {
                            "cidr": {
                              "description": "CIDR is a CIDR prefix / IP Block.",
                              "type": "string",
                              "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                            },
                            "cidrGroupRef": {
                              "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                              "type": "string",
                              "maxLength": 253,
                              "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                            },
                            "except": {
                              "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                              "type": "array",
                              "items": {
                                "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                "type": "string",
                                "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                              }
                            }
                          }
                        }
                      },
                      "toEndpoints": {
                        "description": "ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\".",
                        "type": "array",
                        "items": {
                          "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                          "type": "object",
                          "properties": {
                            "matchExpressions": {
                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                              "type": "array",
                              "items": {
                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "key is the label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                    "type": "string",
                                    "enum": [
                                      "In",
                                      "NotIn",
                                      "Exists",
                                      "DoesNotExist"
                                    ]
                                  },
                                  "values": {
                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "matchLabels": {
                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                              "type": "object",
                              "additionalProperties": {
                                "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                "type": "string",
                                "maxLength": 63,
                                "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                              }
                            }
                          }
                        }
                      },
                      "toEntities": {
                        "description": "ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`, `health`,`unmanaged` and `all`.",
                        "type": "array",
                        "items": {
                          "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                          "type": "string",
                          "enum": [
                            "all",
                            "world",
                            "cluster",
                            "host",
                            "init",
                            "ingress",
                            "unmanaged",
                            "remote-node",
                            "health",
                            "none",
                            "kube-apiserver"
                          ]
                        }
                      },
                      "toGroups": {
                        "description": "ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws:     securityGroupsIds:     - 'sg-XXXXXXXXXXXXX'",
                        "type": "array",
                        "items": {
                          "description": "ToGroups structure to store all kinds of new integrations that needs a new derivative policy.",
                          "type": "object",
                          "properties": {
                            "aws": {
                              "description": "AWSGroup is an structure that can be used to whitelisting information from AWS integration",
                              "type": "object",
                              "properties": {
                                "labels": {
                                  "type": "object",
                                  "additionalProperties": {
                                    "type": "string"
                                  }
                                },
                                "region": {
                                  "type": "string"
                                },
                                "securityGroupsIds": {
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                },
                                "securityGroupsNames": {
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      "toPorts": {
                        "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is not allowed to initiate connections to destination port 8080/tcp",
                        "type": "array",
                        "items": {
                          "description": "PortDenyRule is a list of ports/protocol that should be used for deny policies. This structure lacks the L7Rules since it's not supported in deny policies.",
                          "type": "object",
                          "properties": {
                            "ports": {
                              "description": "Ports is a list of L4 port/protocol",
                              "type": "array",
                              "items": {
                                "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                                "type": "object",
                                "required": [
                                  "port"
                                ],
                                "properties": {
                                  "port": {
                                    "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                    "type": "string",
                                    "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                  },
                                  "protocol": {
                                    "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                    "type": "string",
                                    "enum": [
                                      "TCP",
                                      "UDP",
                                      "SCTP",
                                      "ANY"
                                    ]
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      "toRequires": {
                        "description": "ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\".",
                        "type": "array",
                        "items": {
                          "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                          "type": "object",
                          "properties": {
                            "matchExpressions": {
                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                              "type": "array",
                              "items": {
                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "key is the label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                    "type": "string",
                                    "enum": [
                                      "In",
                                      "NotIn",
                                      "Exists",
                                      "DoesNotExist"
                                    ]
                                  },
                                  "values": {
                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "matchLabels": {
                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                              "type": "object",
                              "additionalProperties": {
                                "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                "type": "string",
                                "maxLength": 63,
                                "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                              }
                            }
                          }
                        }
                      },
                      "toServices": {
                        "description": "ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service",
                        "type": "array",
                        "items": {
                          "description": "Service wraps around selectors for services",
                          "type": "object",
                          "properties": {
                            "k8sService": {
                              "description": "K8sService selects service by name and namespace pair",
                              "type": "object",
                              "properties": {
                                "namespace": {
                                  "type": "string"
                                },
                                "serviceName": {
                                  "type": "string"
                                }
                              }
                            },
                            "k8sServiceSelector": {
                              "description": "K8sServiceSelector selects services by k8s labels and namespace",
                              "type": "object",
                              "required": [
                                "selector"
                              ],
                              "properties": {
                                "namespace": {
                                  "type": "string"
                                },
                                "selector": {
                                  "description": "ServiceSelector is a label selector for k8s services",
                                  "type": "object",
                                  "properties": {
                                    "matchExpressions": {
                                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                      "type": "array",
                                      "items": {
                                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                        "type": "object",
                                        "required": [
                                          "key",
                                          "operator"
                                        ],
                                        "properties": {
                                          "key": {
                                            "description": "key is the label key that the selector applies to.",
                                            "type": "string"
                                          },
                                          "operator": {
                                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                            "type": "string",
                                            "enum": [
                                              "In",
                                              "NotIn",
                                              "Exists",
                                              "DoesNotExist"
                                            ]
                                          },
                                          "values": {
                                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "matchLabels": {
                                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                      "type": "object",
                                      "additionalProperties": {
                                        "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                        "type": "string",
                                        "maxLength": 63,
                                        "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "endpointSelector": {
                  "description": "EndpointSelector selects all endpoints which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive.",
                  "type": "object",
                  "properties": {
                    "matchExpressions": {
                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                      "type": "array",
                      "items": {
                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                        "type": "object",
                        "required": [
                          "key",
                          "operator"
                        ],
                        "properties": {
                          "key": {
                            "description": "key is the label key that the selector applies to.",
                            "type": "string"
                          },
                          "operator": {
                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                            "type": "string",
                            "enum": [
                              "In",
                              "NotIn",
                              "Exists",
                              "DoesNotExist"
                            ]
                          },
                          "values": {
                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      }
                    },
                    "matchLabels": {
                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                      "type": "object",
                      "additionalProperties": {
                        "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                        "type": "string",
                        "maxLength": 63,
                        "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                      }
                    }
                  }
                },
                "ingress": {
                  "description": "Ingress is a list of IngressRule which are enforced at ingress. If omitted or empty, this rule does not apply at ingress.",
                  "type": "array",
                  "items": {
                    "description": "IngressRule contains all rule types which can be applied at ingress, i.e. network traffic that originates outside of the endpoint and is entering the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members are set, all of them need to match in order for     the rule to take effect. The exception to this rule is FromRequires field;     the effects of any Requires field in any rule will apply to all other     rules as well. \n   - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually     exclusive. Only one of these members may be present within an individual     rule.",
                    "type": "object",
                    "properties": {
                      "authentication": {
                        "description": "Authentication is the required authentication type for the allowed traffic, if any.",
                        "type": "object",
                        "required": [
                          "mode"
                        ],
                        "properties": {
                          "mode": {
                            "description": "Mode is the required authentication mode for the allowed traffic, if any.",
                            "type": "string",
                            "enum": [
                              "disabled",
                              "required",
                              "test-always-fail"
                            ]
                          }
                        }
                      },
                      "fromCIDR": {
                        "description": "FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do *not* originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field.  This will match on the source IP address of incoming connections. Adding  a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.3.9.1",
                        "type": "array",
                        "items": {
                          "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                          "type": "string",
                          "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                        }
                      },
                      "fromCIDRSet": {
                        "description": "FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.",
                        "type": "array",
                        "items": {
                          "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                          "type": "object",
                          "properties": {
                            "cidr": {
                              "description": "CIDR is a CIDR prefix / IP Block.",
                              "type": "string",
                              "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                            },
                            "cidrGroupRef": {
                              "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                              "type": "string",
                              "maxLength": 253,
                              "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                            },
                            "except": {
                              "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                              "type": "array",
                              "items": {
                                "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                "type": "string",
                                "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                              }
                            }
                          }
                        }
                      },
                      "fromEndpoints": {
                        "description": "FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\".",
                        "type": "array",
                        "items": {
                          "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                          "type": "object",
                          "properties": {
                            "matchExpressions": {
                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                              "type": "array",
                              "items": {
                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "key is the label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                    "type": "string",
                                    "enum": [
                                      "In",
                                      "NotIn",
                                      "Exists",
                                      "DoesNotExist"
                                    ]
                                  },
                                  "values": {
                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "matchLabels": {
                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                              "type": "object",
                              "additionalProperties": {
                                "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                "type": "string",
                                "maxLength": 63,
                                "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                              }
                            }
                          }
                        }
                      },
                      "fromEntities": {
                        "description": "FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are `world`, `cluster` and `host`",
                        "type": "array",
                        "items": {
                          "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                          "type": "string",
                          "enum": [
                            "all",
                            "world",
                            "cluster",
                            "host",
                            "init",
                            "ingress",
                            "unmanaged",
                            "remote-node",
                            "health",
                            "none",
                            "kube-apiserver"
                          ]
                        }
                      },
                      "fromRequires": {
                        "description": "FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\".",
                        "type": "array",
                        "items": {
                          "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                          "type": "object",
                          "properties": {
                            "matchExpressions": {
                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                              "type": "array",
                              "items": {
                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "key is the label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                    "type": "string",
                                    "enum": [
                                      "In",
                                      "NotIn",
                                      "Exists",
                                      "DoesNotExist"
                                    ]
                                  },
                                  "values": {
                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "matchLabels": {
                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                              "type": "object",
                              "additionalProperties": {
                                "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                "type": "string",
                                "maxLength": 63,
                                "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                              }
                            }
                          }
                        }
                      },
                      "icmps": {
                        "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming type 8 ICMP connections.",
                        "type": "array",
                        "items": {
                          "description": "ICMPRule is a list of ICMP fields.",
                          "type": "object",
                          "properties": {
                            "fields": {
                              "description": "Fields is a list of ICMP fields.",
                              "type": "array",
                              "items": {
                                "description": "ICMPField is a ICMP field.",
                                "type": "object",
                                "required": [
                                  "type"
                                ],
                                "properties": {
                                  "family": {
                                    "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                    "type": "string",
                                    "enum": [
                                      "IPv4",
                                      "IPv6"
                                    ]
                                  },
                                  "type": {
                                    "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                    "type": "integer",
                                    "maximum": 255,
                                    "minimum": 0
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      "toPorts": {
                        "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming connections on port 80/tcp.",
                        "type": "array",
                        "items": {
                          "description": "PortRule is a list of ports/protocol combinations with optional Layer 7 rules which must be met.",
                          "type": "object",
                          "properties": {
                            "listener": {
                              "description": "listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.",
                              "type": "object",
                              "required": [
                                "envoyConfig",
                                "name"
                              ],
                              "properties": {
                                "envoyConfig": {
                                  "description": "EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.",
                                  "type": "object",
                                  "required": [
                                    "name"
                                  ],
                                  "properties": {
                                    "kind": {
                                      "description": "Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.",
                                      "type": "string",
                                      "enum": [
                                        "CiliumEnvoyConfig",
                                        "CiliumClusterwideEnvoyConfig"
                                      ]
                                    },
                                    "name": {
                                      "description": "Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where the listener is defined in.",
                                      "type": "string",
                                      "minLength": 1
                                    }
                                  }
                                },
                                "name": {
                                  "description": "Name is the name of the listener.",
                                  "type": "string",
                                  "minLength": 1
                                }
                              }
                            },
                            "originatingTLS": {
                              "description": "OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.",
                              "type": "object",
                              "required": [
                                "secret"
                              ],
                              "properties": {
                                "certificate": {
                                  "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                  "type": "string"
                                },
                                "privateKey": {
                                  "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                  "type": "string"
                                },
                                "secret": {
                                  "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                  "type": "object",
                                  "required": [
                                    "name"
                                  ],
                                  "properties": {
                                    "name": {
                                      "description": "Name is the name of the secret.",
                                      "type": "string"
                                    },
                                    "namespace": {
                                      "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                      "type": "string"
                                    }
                                  }
                                },
                                "trustedCA": {
                                  "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                  "type": "string"
                                }
                              }
                            },
                            "ports": {
                              "description": "Ports is a list of L4 port/protocol",
                              "type": "array",
                              "items": {
                                "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                                "type": "object",
                                "required": [
                                  "port"
                                ],
                                "properties": {
                                  "port": {
                                    "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                    "type": "string",
                                    "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                  },
                                  "protocol": {
                                    "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                    "type": "string",
                                    "enum": [
                                      "TCP",
                                      "UDP",
                                      "SCTP",
                                      "ANY"
                                    ]
                                  }
                                }
                              }
                            },
                            "rules": {
                              "description": "Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.",
                              "type": "object",
                              "properties": {
                                "dns": {
                                  "description": "DNS-specific rules.",
                                  "type": "array",
                                  "items": {
                                    "description": "PortRuleDNS is a list of allowed DNS lookups.",
                                    "type": "object",
                                    "properties": {
                                      "matchName": {
                                        "description": "MatchName matches literal DNS names. A trailing \".\" is automatically added when missing.",
                                        "type": "string",
                                        "pattern": "^([-a-zA-Z0-9_]+[.]?)+$"
                                      },
                                      "matchPattern": {
                                        "description": "MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"*\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"*\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: `*.cilium.io` matches subomains of cilium at that level   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with \"cilium.io\"   except those containing \".\" separator, subcilium.io and sub-cilium.io match,   www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\"   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,   blog.cilium.io, cilium.io and google.com do not",
                                        "type": "string",
                                        "pattern": "^([-a-zA-Z0-9_*]+[.]?)+$"
                                      }
                                    }
                                  }
                                },
                                "http": {
                                  "description": "HTTP specific rules.",
                                  "type": "array",
                                  "items": {
                                    "description": "PortRuleHTTP is a list of HTTP protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect. \n All fields of this type are extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986.",
                                    "type": "object",
                                    "properties": {
                                      "headerMatches": {
                                        "description": "HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match.",
                                        "type": "array",
                                        "items": {
                                          "description": "HeaderMatch extends the HeaderValue for matching requirement of a named header field against an immediate string, a secret value, or a regex.  If none of the optional fields is present, then the header value is not matched, only presence of the header is enough.",
                                          "type": "object",
                                          "required": [
                                            "name"
                                          ],
                                          "properties": {
                                            "mismatch": {
                                              "description": "Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.",
                                              "type": "string",
                                              "enum": [
                                                "LOG",
                                                "ADD",
                                                "DELETE",
                                                "REPLACE"
                                              ]
                                            },
                                            "name": {
                                              "description": "Name identifies the header.",
                                              "type": "string"
                                            },
                                            "secret": {
                                              "description": "Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no \"Value\" specified, the match will fail.",
                                              "type": "object",
                                              "required": [
                                                "name"
                                              ],
                                              "properties": {
                                                "name": {
                                                  "description": "Name is the name of the secret.",
                                                  "type": "string"
                                                },
                                                "namespace": {
                                                  "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                                  "type": "string"
                                                }
                                              }
                                            },
                                            "value": {
                                              "description": "Value matches the exact value of the header. Can be specified either alone or together with \"Secret\"; will be used as the header value if the secret can not be found in the latter case.",
                                              "type": "string"
                                            }
                                          }
                                        }
                                      },
                                      "headers": {
                                        "description": "Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present.",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        }
                                      },
                                      "host": {
                                        "description": "Host is an extended POSIX regex matched against the host header of a request, e.g. \"foo.com\" \n If omitted or empty, the value of the host header is ignored.",
                                        "type": "string",
                                        "format": "idn-hostname"
                                      },
                                      "method": {
                                        "description": "Method is an extended POSIX regex matched against the method of a request, e.g. \"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\", ... \n If omitted or empty, all methods are allowed.",
                                        "type": "string"
                                      },
                                      "path": {
                                        "description": "Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986. \n If omitted or empty, all paths are all allowed.",
                                        "type": "string"
                                      }
                                    }
                                  }
                                },
                                "kafka": {
                                  "description": "Kafka-specific rules.",
                                  "type": "array",
                                  "items": {
                                    "description": "PortRule is a list of Kafka protocol constraints. All fields are optional, if all fields are empty or missing, the rule will match all Kafka messages.",
                                    "type": "object",
                                    "properties": {
                                      "apiKey": {
                                        "description": "APIKey is a case-insensitive string matched against the key of a request, e.g. \"produce\", \"fetch\", \"createtopic\", \"deletetopic\", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys \n If omitted or empty, and if Role is not specified, then all keys are allowed.",
                                        "type": "string"
                                      },
                                      "apiVersion": {
                                        "description": "APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer. \n If omitted or empty, all versions are allowed.",
                                        "type": "string"
                                      },
                                      "clientID": {
                                        "description": "ClientID is the client identifier as provided in the request. \n From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client. \n If omitted or empty, all client identifiers are allowed.",
                                        "type": "string"
                                      },
                                      "role": {
                                        "description": "Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as \"produce\" or \"consume\". A Role automatically expands into all APIKeys required to perform the specified higher-level operation. \n The following values are supported:  - \"produce\": Allow producing to the topics specified in the rule  - \"consume\": Allow consuming from the topics specified in the rule \n This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule. \n If omitted or empty, and if APIKey is not specified, then all keys are allowed.",
                                        "type": "string",
                                        "enum": [
                                          "produce",
                                          "consume"
                                        ]
                                      },
                                      "topic": {
                                        "description": "Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected. \n This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _. \n Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255. \n If omitted or empty, all topics are allowed.",
                                        "type": "string",
                                        "maxLength": 255
                                      }
                                    }
                                  }
                                },
                                "l7": {
                                  "description": "Key-value pair rules.",
                                  "type": "array",
                                  "items": {
                                    "description": "PortRuleL7 is a list of key-value pairs interpreted by a L7 protocol as protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect.",
                                    "type": "object",
                                    "additionalProperties": {
                                      "type": "string"
                                    }
                                  }
                                },
                                "l7proto": {
                                  "description": "Name of the L7 protocol for which the Key-value pair rules apply.",
                                  "type": "string"
                                }
                              }
                            },
                            "serverNames": {
                              "description": "ServerNames is a list of allowed TLS SNI values. If not empty, then TLS must be present and one of the provided SNIs must be indicated in the TLS handshake.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            },
                            "terminatingTLS": {
                              "description": "TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.",
                              "type": "object",
                              "required": [
                                "secret"
                              ],
                              "properties": {
                                "certificate": {
                                  "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                  "type": "string"
                                },
                                "privateKey": {
                                  "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                  "type": "string"
                                },
                                "secret": {
                                  "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                  "type": "object",
                                  "required": [
                                    "name"
                                  ],
                                  "properties": {
                                    "name": {
                                      "description": "Name is the name of the secret.",
                                      "type": "string"
                                    },
                                    "namespace": {
                                      "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                      "type": "string"
                                    }
                                  }
                                },
                                "trustedCA": {
                                  "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                  "type": "string"
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "ingressDeny": {
                  "description": "IngressDeny is a list of IngressDenyRule which are enforced at ingress. Any rule inserted here will be denied regardless of the allowed ingress rules in the 'ingress' field. If omitted or empty, this rule does not apply at ingress.",
                  "type": "array",
                  "items": {
                    "description": "IngressDenyRule contains all rule types which can be applied at ingress, i.e. network traffic that originates outside of the endpoint and is entering the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members are set, all of them need to match in order for     the rule to take effect. The exception to this rule is FromRequires field;     the effects of any Requires field in any rule will apply to all other     rules as well. \n   - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually     exclusive. Only one of these members may be present within an individual     rule.",
                    "type": "object",
                    "properties": {
                      "fromCIDR": {
                        "description": "FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do *not* originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field.  This will match on the source IP address of incoming connections. Adding  a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.3.9.1",
                        "type": "array",
                        "items": {
                          "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                          "type": "string",
                          "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                        }
                      },
                      "fromCIDRSet": {
                        "description": "FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.",
                        "type": "array",
                        "items": {
                          "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                          "type": "object",
                          "properties": {
                            "cidr": {
                              "description": "CIDR is a CIDR prefix / IP Block.",
                              "type": "string",
                              "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                            },
                            "cidrGroupRef": {
                              "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                              "type": "string",
                              "maxLength": 253,
                              "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                            },
                            "except": {
                              "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                              "type": "array",
                              "items": {
                                "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                "type": "string",
                                "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                              }
                            }
                          }
                        }
                      },
                      "fromEndpoints": {
                        "description": "FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\".",
                        "type": "array",
                        "items": {
                          "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                          "type": "object",
                          "properties": {
                            "matchExpressions": {
                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                              "type": "array",
                              "items": {
                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "key is the label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                    "type": "string",
                                    "enum": [
                                      "In",
                                      "NotIn",
                                      "Exists",
                                      "DoesNotExist"
                                    ]
                                  },
                                  "values": {
                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "matchLabels": {
                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                              "type": "object",
                              "additionalProperties": {
                                "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                "type": "string",
                                "maxLength": 63,
                                "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                              }
                            }
                          }
                        }
                      },
                      "fromEntities": {
                        "description": "FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are `world`, `cluster` and `host`",
                        "type": "array",
                        "items": {
                          "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                          "type": "string",
                          "enum": [
                            "all",
                            "world",
                            "cluster",
                            "host",
                            "init",
                            "ingress",
                            "unmanaged",
                            "remote-node",
                            "health",
                            "none",
                            "kube-apiserver"
                          ]
                        }
                      },
                      "fromRequires": {
                        "description": "FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\".",
                        "type": "array",
                        "items": {
                          "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                          "type": "object",
                          "properties": {
                            "matchExpressions": {
                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                              "type": "array",
                              "items": {
                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "key is the label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                    "type": "string",
                                    "enum": [
                                      "In",
                                      "NotIn",
                                      "Exists",
                                      "DoesNotExist"
                                    ]
                                  },
                                  "values": {
                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "matchLabels": {
                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                              "type": "object",
                              "additionalProperties": {
                                "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                "type": "string",
                                "maxLength": 63,
                                "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                              }
                            }
                          }
                        }
                      },
                      "icmps": {
                        "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming type 8 ICMP connections.",
                        "type": "array",
                        "items": {
                          "description": "ICMPRule is a list of ICMP fields.",
                          "type": "object",
                          "properties": {
                            "fields": {
                              "description": "Fields is a list of ICMP fields.",
                              "type": "array",
                              "items": {
                                "description": "ICMPField is a ICMP field.",
                                "type": "object",
                                "required": [
                                  "type"
                                ],
                                "properties": {
                                  "family": {
                                    "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                    "type": "string",
                                    "enum": [
                                      "IPv4",
                                      "IPv6"
                                    ]
                                  },
                                  "type": {
                                    "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                    "type": "integer",
                                    "maximum": 255,
                                    "minimum": 0
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      "toPorts": {
                        "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming connections on port 80/tcp.",
                        "type": "array",
                        "items": {
                          "description": "PortDenyRule is a list of ports/protocol that should be used for deny policies. This structure lacks the L7Rules since it's not supported in deny policies.",
                          "type": "object",
                          "properties": {
                            "ports": {
                              "description": "Ports is a list of L4 port/protocol",
                              "type": "array",
                              "items": {
                                "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                                "type": "object",
                                "required": [
                                  "port"
                                ],
                                "properties": {
                                  "port": {
                                    "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                    "type": "string",
                                    "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                  },
                                  "protocol": {
                                    "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                    "type": "string",
                                    "enum": [
                                      "TCP",
                                      "UDP",
                                      "SCTP",
                                      "ANY"
                                    ]
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "labels": {
                  "description": "Labels is a list of optional strings which can be used to re-identify the rule or to store metadata. It is possible to lookup or delete strings based on labels. Labels are not required to be unique, multiple rules can have overlapping or identical labels.",
                  "type": "array",
                  "items": {
                    "description": "Label is the Cilium's representation of a container label.",
                    "type": "object",
                    "required": [
                      "key"
                    ],
                    "properties": {
                      "key": {
                        "type": "string"
                      },
                      "source": {
                        "description": "Source can be one of the above values (e.g.: LabelSourceContainer).",
                        "type": "string"
                      },
                      "value": {
                        "type": "string"
                      }
                    }
                  }
                },
                "nodeSelector": {
                  "description": "NodeSelector selects all nodes which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive. Can only be used in CiliumClusterwideNetworkPolicies.",
                  "type": "object",
                  "properties": {
                    "matchExpressions": {
                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                      "type": "array",
                      "items": {
                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                        "type": "object",
                        "required": [
                          "key",
                          "operator"
                        ],
                        "properties": {
                          "key": {
                            "description": "key is the label key that the selector applies to.",
                            "type": "string"
                          },
                          "operator": {
                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                            "type": "string",
                            "enum": [
                              "In",
                              "NotIn",
                              "Exists",
                              "DoesNotExist"
                            ]
                          },
                          "values": {
                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      }
                    },
                    "matchLabels": {
                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                      "type": "object",
                      "additionalProperties": {
                        "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                        "type": "string",
                        "maxLength": 63,
                        "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                      }
                    }
                  }
                }
              }
            }
          },
          "status": {
            "description": "Status is the status of the Cilium policy rule. \n The reason this field exists in this structure is due a bug in the k8s code-generator that doesn't create a `UpdateStatus` method because the field does not exist in the structure.",
            "type": "object",
            "properties": {
              "derivativePolicies": {
                "description": "DerivativePolicies is the status of all policies derived from the Cilium policy",
                "type": "object",
                "additionalProperties": {
                  "description": "CiliumNetworkPolicyNodeStatus is the status of a Cilium policy rule for a specific node.",
                  "type": "object",
                  "properties": {
                    "annotations": {
                      "description": "Annotations corresponds to the Annotations in the ObjectMeta of the CNP that have been realized on the node for CNP. That is, if a CNP has been imported and has been assigned annotation X=Y by the user, Annotations in CiliumNetworkPolicyNodeStatus will be X=Y once the CNP that was imported corresponding to Annotation X=Y has been realized on the node.",
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "enforcing": {
                      "description": "Enforcing is set to true once all endpoints present at the time the policy has been imported are enforcing this policy.",
                      "type": "boolean"
                    },
                    "error": {
                      "description": "Error describes any error that occurred when parsing or importing the policy, or realizing the policy for the endpoints to which it applies on the node.",
                      "type": "string"
                    },
                    "lastUpdated": {
                      "description": "LastUpdated contains the last time this status was updated",
                      "type": "string",
                      "format": "date-time"
                    },
                    "localPolicyRevision": {
                      "description": "Revision is the policy revision of the repository which first implemented this policy.",
                      "type": "integer",
                      "format": "int64"
                    },
                    "ok": {
                      "description": "OK is true when the policy has been parsed and imported successfully into the in-memory policy repository on the node.",
                      "type": "boolean"
                    }
                  }
                }
              },
              "nodes": {
                "description": "Nodes is the Cilium policy status for each node",
                "type": "object",
                "additionalProperties": {
                  "description": "CiliumNetworkPolicyNodeStatus is the status of a Cilium policy rule for a specific node.",
                  "type": "object",
                  "properties": {
                    "annotations": {
                      "description": "Annotations corresponds to the Annotations in the ObjectMeta of the CNP that have been realized on the node for CNP. That is, if a CNP has been imported and has been assigned annotation X=Y by the user, Annotations in CiliumNetworkPolicyNodeStatus will be X=Y once the CNP that was imported corresponding to Annotation X=Y has been realized on the node.",
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "enforcing": {
                      "description": "Enforcing is set to true once all endpoints present at the time the policy has been imported are enforcing this policy.",
                      "type": "boolean"
                    },
                    "error": {
                      "description": "Error describes any error that occurred when parsing or importing the policy, or realizing the policy for the endpoints to which it applies on the node.",
                      "type": "string"
                    },
                    "lastUpdated": {
                      "description": "LastUpdated contains the last time this status was updated",
                      "type": "string",
                      "format": "date-time"
                    },
                    "localPolicyRevision": {
                      "description": "Revision is the policy revision of the repository which first implemented this policy.",
                      "type": "integer",
                      "format": "int64"
                    },
                    "ok": {
                      "description": "OK is true when the policy has been parsed and imported successfully into the in-memory policy repository on the node.",
                      "type": "boolean"
                    }
                  }
                }
              }
            }
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "cilium.io",
            "kind": "CiliumClusterwideNetworkPolicy",
            "version": "v2"
          }
        ]
      },
      "crd": {
        "metadata": {
          "name": "ciliumclusterwidenetworkpolicies.cilium.io",
          "uid": "3d029b4f-c221-434b-8909-541b88606b8d",
          "resourceVersion": "25877238546",
          "generation": 1,
          "creationTimestamp": "2023-11-21T10:47:04Z",
          "labels": {
            "io.cilium.k8s.crd.schema.version": "1.26.11"
          },
          "managedFields": [
            {
              "manager": "cilium-operator-generic",
              "operation": "Update",
              "apiVersion": "apiextensions.k8s.io/v1",
              "time": "2023-11-21T10:47:04Z",
              "fieldsType": "FieldsV1",
              "fieldsV1": {
                "f:metadata": {
                  "f:labels": {
                    ".": {},
                    "f:io.cilium.k8s.crd.schema.version": {}
                  }
                },
                "f:spec": {
                  "f:conversion": {
                    ".": {},
                    "f:strategy": {}
                  },
                  "f:group": {},
                  "f:names": {
                    "f:kind": {},
                    "f:listKind": {},
                    "f:plural": {},
                    "f:shortNames": {},
                    "f:singular": {}
                  },
                  "f:scope": {},
                  "f:versions": {}
                }
              }
            },
            {
              "manager": "kube-apiserver",
              "operation": "Update",
              "apiVersion": "apiextensions.k8s.io/v1",
              "time": "2023-11-21T10:47:06Z",
              "fieldsType": "FieldsV1",
              "fieldsV1": {
                "f:status": {
                  "f:acceptedNames": {
                    "f:kind": {},
                    "f:listKind": {},
                    "f:plural": {},
                    "f:shortNames": {},
                    "f:singular": {}
                  },
                  "f:conditions": {
                    "k:{\"type\":\"Established\"}": {
                      ".": {},
                      "f:lastTransitionTime": {},
                      "f:message": {},
                      "f:reason": {},
                      "f:status": {},
                      "f:type": {}
                    },
                    "k:{\"type\":\"NamesAccepted\"}": {
                      ".": {},
                      "f:lastTransitionTime": {},
                      "f:message": {},
                      "f:reason": {},
                      "f:status": {},
                      "f:type": {}
                    }
                  }
                }
              },
              "subresource": "status"
            }
          ]
        },
        "spec": {
          "group": "cilium.io",
          "names": {
            "plural": "ciliumclusterwidenetworkpolicies",
            "singular": "ciliumclusterwidenetworkpolicy",
            "shortNames": [
              "ccnp"
            ],
            "kind": "CiliumClusterwideNetworkPolicy",
            "listKind": "CiliumClusterwideNetworkPolicyList"
          },
          "scope": "Cluster",
          "versions": [
            {
              "name": "v2",
              "served": true,
              "storage": true,
              "schema": {
                "openAPIV3Schema": {
                  "description": "CiliumClusterwideNetworkPolicy is a Kubernetes third-party resource with an modified version of CiliumNetworkPolicy which is cluster scoped rather than namespace scoped.",
                  "type": "object",
                  "required": [
                    "metadata"
                  ],
                  "properties": {
                    "apiVersion": {
                      "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                      "type": "string"
                    },
                    "kind": {
                      "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                      "type": "string"
                    },
                    "metadata": {
                      "type": "object"
                    },
                    "spec": {
                      "description": "Spec is the desired Cilium specific rule specification.",
                      "type": "object",
                      "oneOf": [
                        {
                          "required": [
                            "endpointSelector"
                          ],
                          "properties": {
                            "endpointSelector": {}
                          }
                        },
                        {
                          "required": [
                            "nodeSelector"
                          ],
                          "properties": {
                            "nodeSelector": {}
                          }
                        }
                      ],
                      "properties": {
                        "description": {
                          "description": "Description is a free form string, it can be used by the creator of the rule to store human readable explanation of the purpose of this rule. Rules cannot be identified by comment.",
                          "type": "string"
                        },
                        "egress": {
                          "description": "Egress is a list of EgressRule which are enforced at egress. If omitted or empty, this rule does not apply at egress.",
                          "type": "array",
                          "items": {
                            "description": "EgressRule contains all rule types which can be applied at egress, i.e. network traffic that originates inside the endpoint and exits the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members of the structure are specified, then all members     must match in order for the rule to take effect. The exception to this     rule is the ToRequires member; the effects of any Requires field in any     rule will apply to all other rules as well. \n   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are     mutually exclusive. Only one of these members may be present within an     individual rule.",
                            "type": "object",
                            "properties": {
                              "authentication": {
                                "description": "Authentication is the required authentication type for the allowed traffic, if any.",
                                "type": "object",
                                "required": [
                                  "mode"
                                ],
                                "properties": {
                                  "mode": {
                                    "description": "Mode is the required authentication mode for the allowed traffic, if any.",
                                    "type": "string",
                                    "enum": [
                                      "disabled",
                                      "required",
                                      "test-always-fail"
                                    ]
                                  }
                                }
                              },
                              "icmps": {
                                "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is allowed to initiate type 8 ICMP connections.",
                                "type": "array",
                                "items": {
                                  "description": "ICMPRule is a list of ICMP fields.",
                                  "type": "object",
                                  "properties": {
                                    "fields": {
                                      "description": "Fields is a list of ICMP fields.",
                                      "type": "array",
                                      "items": {
                                        "description": "ICMPField is a ICMP field.",
                                        "type": "object",
                                        "required": [
                                          "type"
                                        ],
                                        "properties": {
                                          "family": {
                                            "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                            "type": "string",
                                            "default": "IPv4",
                                            "enum": [
                                              "IPv4",
                                              "IPv6"
                                            ]
                                          },
                                          "type": {
                                            "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                            "type": "integer",
                                            "maximum": 255,
                                            "minimum": 0
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              },
                              "toCIDR": {
                                "description": "ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules.  This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24",
                                "type": "array",
                                "items": {
                                  "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                  "type": "string",
                                  "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                }
                              },
                              "toCIDRSet": {
                                "description": "ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.",
                                "type": "array",
                                "items": {
                                  "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                                  "type": "object",
                                  "oneOf": [
                                    {
                                      "required": [
                                        "cidr"
                                      ],
                                      "properties": {
                                        "cidr": {}
                                      }
                                    },
                                    {
                                      "required": [
                                        "cidrGroupRef"
                                      ],
                                      "properties": {
                                        "cidrGroupRef": {}
                                      }
                                    }
                                  ],
                                  "properties": {
                                    "cidr": {
                                      "description": "CIDR is a CIDR prefix / IP Block.",
                                      "type": "string",
                                      "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                    },
                                    "cidrGroupRef": {
                                      "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                                      "type": "string",
                                      "maxLength": 253,
                                      "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                                    },
                                    "except": {
                                      "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                                      "type": "array",
                                      "items": {
                                        "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                        "type": "string",
                                        "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                      }
                                    }
                                  }
                                }
                              },
                              "toEndpoints": {
                                "description": "ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\".",
                                "type": "array",
                                "items": {
                                  "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                  "type": "object",
                                  "properties": {
                                    "matchExpressions": {
                                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                      "type": "array",
                                      "items": {
                                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                        "type": "object",
                                        "required": [
                                          "key",
                                          "operator"
                                        ],
                                        "properties": {
                                          "key": {
                                            "description": "key is the label key that the selector applies to.",
                                            "type": "string"
                                          },
                                          "operator": {
                                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                            "type": "string",
                                            "enum": [
                                              "In",
                                              "NotIn",
                                              "Exists",
                                              "DoesNotExist"
                                            ]
                                          },
                                          "values": {
                                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "matchLabels": {
                                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                      "type": "object",
                                      "additionalProperties": {
                                        "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                        "type": "string",
                                        "maxLength": 63,
                                        "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                      }
                                    }
                                  }
                                }
                              },
                              "toEntities": {
                                "description": "ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`, `health`,`unmanaged` and `all`.",
                                "type": "array",
                                "items": {
                                  "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                                  "type": "string",
                                  "enum": [
                                    "all",
                                    "world",
                                    "cluster",
                                    "host",
                                    "init",
                                    "ingress",
                                    "unmanaged",
                                    "remote-node",
                                    "health",
                                    "none",
                                    "kube-apiserver"
                                  ]
                                }
                              },
                              "toFQDNs": {
                                "description": "ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result from DNS resolution of `ToFQDN.MatchName`s are added to the same EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and L7 rules within this EgressRule will also apply to these IPs. The DNS -> IP mapping is re-resolved periodically from within the cilium-agent, and the IPs in the DNS response are effected in the policy for selected pods as-is (i.e. the list of IPs is not modified in any way). Note: An explicit rule to allow for DNS traffic is needed for the pods, as ToFQDN counts as an egress rule and will enforce egress policy when PolicyEnforcment=default. Note: If the resolved IPs are IPs within the kubernetes cluster, the ToFQDN rule will not apply to that IP. Note: ToFQDN cannot occur in the same policy as other To* rules.",
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "matchName": {
                                      "description": "MatchName matches literal DNS names. A trailing \".\" is automatically added when missing.",
                                      "type": "string",
                                      "pattern": "^([-a-zA-Z0-9_]+[.]?)+$"
                                    },
                                    "matchPattern": {
                                      "description": "MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"*\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"*\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: `*.cilium.io` matches subomains of cilium at that level   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with \"cilium.io\"   except those containing \".\" separator, subcilium.io and sub-cilium.io match,   www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\"   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,   blog.cilium.io, cilium.io and google.com do not",
                                      "type": "string",
                                      "pattern": "^([-a-zA-Z0-9_*]+[.]?)+$"
                                    }
                                  }
                                }
                              },
                              "toGroups": {
                                "description": "ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws:     securityGroupsIds:     - 'sg-XXXXXXXXXXXXX'",
                                "type": "array",
                                "items": {
                                  "description": "ToGroups structure to store all kinds of new integrations that needs a new derivative policy.",
                                  "type": "object",
                                  "properties": {
                                    "aws": {
                                      "description": "AWSGroup is an structure that can be used to whitelisting information from AWS integration",
                                      "type": "object",
                                      "properties": {
                                        "labels": {
                                          "type": "object",
                                          "additionalProperties": {
                                            "type": "string"
                                          }
                                        },
                                        "region": {
                                          "type": "string"
                                        },
                                        "securityGroupsIds": {
                                          "type": "array",
                                          "items": {
                                            "type": "string"
                                          }
                                        },
                                        "securityGroupsNames": {
                                          "type": "array",
                                          "items": {
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              },
                              "toPorts": {
                                "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is allowed to initiate connections to destination port 8080/tcp",
                                "type": "array",
                                "items": {
                                  "description": "PortRule is a list of ports/protocol combinations with optional Layer 7 rules which must be met.",
                                  "type": "object",
                                  "properties": {
                                    "listener": {
                                      "description": "listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.",
                                      "type": "object",
                                      "required": [
                                        "envoyConfig",
                                        "name"
                                      ],
                                      "properties": {
                                        "envoyConfig": {
                                          "description": "EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.",
                                          "type": "object",
                                          "required": [
                                            "name"
                                          ],
                                          "properties": {
                                            "kind": {
                                              "description": "Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.",
                                              "type": "string",
                                              "enum": [
                                                "CiliumEnvoyConfig",
                                                "CiliumClusterwideEnvoyConfig"
                                              ]
                                            },
                                            "name": {
                                              "description": "Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where the listener is defined in.",
                                              "type": "string",
                                              "minLength": 1
                                            }
                                          }
                                        },
                                        "name": {
                                          "description": "Name is the name of the listener.",
                                          "type": "string",
                                          "minLength": 1
                                        }
                                      }
                                    },
                                    "originatingTLS": {
                                      "description": "OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.",
                                      "type": "object",
                                      "required": [
                                        "secret"
                                      ],
                                      "properties": {
                                        "certificate": {
                                          "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                          "type": "string"
                                        },
                                        "privateKey": {
                                          "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                          "type": "string"
                                        },
                                        "secret": {
                                          "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                          "type": "object",
                                          "required": [
                                            "name"
                                          ],
                                          "properties": {
                                            "name": {
                                              "description": "Name is the name of the secret.",
                                              "type": "string"
                                            },
                                            "namespace": {
                                              "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "trustedCA": {
                                          "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                          "type": "string"
                                        }
                                      }
                                    },
                                    "ports": {
                                      "description": "Ports is a list of L4 port/protocol",
                                      "type": "array",
                                      "items": {
                                        "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                                        "type": "object",
                                        "required": [
                                          "port"
                                        ],
                                        "properties": {
                                          "port": {
                                            "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                            "type": "string",
                                            "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                          },
                                          "protocol": {
                                            "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                            "type": "string",
                                            "enum": [
                                              "TCP",
                                              "UDP",
                                              "SCTP",
                                              "ANY"
                                            ]
                                          }
                                        }
                                      }
                                    },
                                    "rules": {
                                      "description": "Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.",
                                      "type": "object",
                                      "properties": {
                                        "dns": {
                                          "description": "DNS-specific rules.",
                                          "type": "array",
                                          "items": {
                                            "description": "PortRuleDNS is a list of allowed DNS lookups.",
                                            "type": "object",
                                            "properties": {
                                              "matchName": {
                                                "description": "MatchName matches literal DNS names. A trailing \".\" is automatically added when missing.",
                                                "type": "string",
                                                "pattern": "^([-a-zA-Z0-9_]+[.]?)+$"
                                              },
                                              "matchPattern": {
                                                "description": "MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"*\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"*\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: `*.cilium.io` matches subomains of cilium at that level   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with \"cilium.io\"   except those containing \".\" separator, subcilium.io and sub-cilium.io match,   www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\"   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,   blog.cilium.io, cilium.io and google.com do not",
                                                "type": "string",
                                                "pattern": "^([-a-zA-Z0-9_*]+[.]?)+$"
                                              }
                                            }
                                          }
                                        },
                                        "http": {
                                          "description": "HTTP specific rules.",
                                          "type": "array",
                                          "items": {
                                            "description": "PortRuleHTTP is a list of HTTP protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect. \n All fields of this type are extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986.",
                                            "type": "object",
                                            "properties": {
                                              "headerMatches": {
                                                "description": "HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match.",
                                                "type": "array",
                                                "items": {
                                                  "description": "HeaderMatch extends the HeaderValue for matching requirement of a named header field against an immediate string, a secret value, or a regex.  If none of the optional fields is present, then the header value is not matched, only presence of the header is enough.",
                                                  "type": "object",
                                                  "required": [
                                                    "name"
                                                  ],
                                                  "properties": {
                                                    "mismatch": {
                                                      "description": "Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.",
                                                      "type": "string",
                                                      "enum": [
                                                        "LOG",
                                                        "ADD",
                                                        "DELETE",
                                                        "REPLACE"
                                                      ]
                                                    },
                                                    "name": {
                                                      "description": "Name identifies the header.",
                                                      "type": "string"
                                                    },
                                                    "secret": {
                                                      "description": "Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no \"Value\" specified, the match will fail.",
                                                      "type": "object",
                                                      "required": [
                                                        "name"
                                                      ],
                                                      "properties": {
                                                        "name": {
                                                          "description": "Name is the name of the secret.",
                                                          "type": "string"
                                                        },
                                                        "namespace": {
                                                          "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                                          "type": "string"
                                                        }
                                                      }
                                                    },
                                                    "value": {
                                                      "description": "Value matches the exact value of the header. Can be specified either alone or together with \"Secret\"; will be used as the header value if the secret can not be found in the latter case.",
                                                      "type": "string"
                                                    }
                                                  }
                                                }
                                              },
                                              "headers": {
                                                "description": "Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present.",
                                                "type": "array",
                                                "items": {
                                                  "type": "string"
                                                }
                                              },
                                              "host": {
                                                "description": "Host is an extended POSIX regex matched against the host header of a request, e.g. \"foo.com\" \n If omitted or empty, the value of the host header is ignored.",
                                                "type": "string",
                                                "format": "idn-hostname"
                                              },
                                              "method": {
                                                "description": "Method is an extended POSIX regex matched against the method of a request, e.g. \"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\", ... \n If omitted or empty, all methods are allowed.",
                                                "type": "string"
                                              },
                                              "path": {
                                                "description": "Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986. \n If omitted or empty, all paths are all allowed.",
                                                "type": "string"
                                              }
                                            }
                                          }
                                        },
                                        "kafka": {
                                          "description": "Kafka-specific rules.",
                                          "type": "array",
                                          "items": {
                                            "description": "PortRule is a list of Kafka protocol constraints. All fields are optional, if all fields are empty or missing, the rule will match all Kafka messages.",
                                            "type": "object",
                                            "properties": {
                                              "apiKey": {
                                                "description": "APIKey is a case-insensitive string matched against the key of a request, e.g. \"produce\", \"fetch\", \"createtopic\", \"deletetopic\", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys \n If omitted or empty, and if Role is not specified, then all keys are allowed.",
                                                "type": "string"
                                              },
                                              "apiVersion": {
                                                "description": "APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer. \n If omitted or empty, all versions are allowed.",
                                                "type": "string"
                                              },
                                              "clientID": {
                                                "description": "ClientID is the client identifier as provided in the request. \n From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client. \n If omitted or empty, all client identifiers are allowed.",
                                                "type": "string"
                                              },
                                              "role": {
                                                "description": "Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as \"produce\" or \"consume\". A Role automatically expands into all APIKeys required to perform the specified higher-level operation. \n The following values are supported:  - \"produce\": Allow producing to the topics specified in the rule  - \"consume\": Allow consuming from the topics specified in the rule \n This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule. \n If omitted or empty, and if APIKey is not specified, then all keys are allowed.",
                                                "type": "string",
                                                "enum": [
                                                  "produce",
                                                  "consume"
                                                ]
                                              },
                                              "topic": {
                                                "description": "Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected. \n This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _. \n Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255. \n If omitted or empty, all topics are allowed.",
                                                "type": "string",
                                                "maxLength": 255
                                              }
                                            }
                                          }
                                        },
                                        "l7": {
                                          "description": "Key-value pair rules.",
                                          "type": "array",
                                          "items": {
                                            "description": "PortRuleL7 is a list of key-value pairs interpreted by a L7 protocol as protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect.",
                                            "type": "object",
                                            "additionalProperties": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "l7proto": {
                                          "description": "Name of the L7 protocol for which the Key-value pair rules apply.",
                                          "type": "string"
                                        }
                                      }
                                    },
                                    "serverNames": {
                                      "description": "ServerNames is a list of allowed TLS SNI values. If not empty, then TLS must be present and one of the provided SNIs must be indicated in the TLS handshake.",
                                      "type": "array",
                                      "items": {
                                        "type": "string"
                                      }
                                    },
                                    "terminatingTLS": {
                                      "description": "TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.",
                                      "type": "object",
                                      "required": [
                                        "secret"
                                      ],
                                      "properties": {
                                        "certificate": {
                                          "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                          "type": "string"
                                        },
                                        "privateKey": {
                                          "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                          "type": "string"
                                        },
                                        "secret": {
                                          "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                          "type": "object",
                                          "required": [
                                            "name"
                                          ],
                                          "properties": {
                                            "name": {
                                              "description": "Name is the name of the secret.",
                                              "type": "string"
                                            },
                                            "namespace": {
                                              "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "trustedCA": {
                                          "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                          "type": "string"
                                        }
                                      }
                                    }
                                  }
                                }
                              },
                              "toRequires": {
                                "description": "ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\".",
                                "type": "array",
                                "items": {
                                  "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                  "type": "object",
                                  "properties": {
                                    "matchExpressions": {
                                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                      "type": "array",
                                      "items": {
                                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                        "type": "object",
                                        "required": [
                                          "key",
                                          "operator"
                                        ],
                                        "properties": {
                                          "key": {
                                            "description": "key is the label key that the selector applies to.",
                                            "type": "string"
                                          },
                                          "operator": {
                                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                            "type": "string",
                                            "enum": [
                                              "In",
                                              "NotIn",
                                              "Exists",
                                              "DoesNotExist"
                                            ]
                                          },
                                          "values": {
                                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "matchLabels": {
                                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                      "type": "object",
                                      "additionalProperties": {
                                        "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                        "type": "string",
                                        "maxLength": 63,
                                        "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                      }
                                    }
                                  }
                                }
                              },
                              "toServices": {
                                "description": "ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service",
                                "type": "array",
                                "items": {
                                  "description": "Service wraps around selectors for services",
                                  "type": "object",
                                  "properties": {
                                    "k8sService": {
                                      "description": "K8sService selects service by name and namespace pair",
                                      "type": "object",
                                      "properties": {
                                        "namespace": {
                                          "type": "string"
                                        },
                                        "serviceName": {
                                          "type": "string"
                                        }
                                      }
                                    },
                                    "k8sServiceSelector": {
                                      "description": "K8sServiceSelector selects services by k8s labels and namespace",
                                      "type": "object",
                                      "required": [
                                        "selector"
                                      ],
                                      "properties": {
                                        "namespace": {
                                          "type": "string"
                                        },
                                        "selector": {
                                          "description": "ServiceSelector is a label selector for k8s services",
                                          "type": "object",
                                          "properties": {
                                            "matchExpressions": {
                                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                              "type": "array",
                                              "items": {
                                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                                "type": "object",
                                                "required": [
                                                  "key",
                                                  "operator"
                                                ],
                                                "properties": {
                                                  "key": {
                                                    "description": "key is the label key that the selector applies to.",
                                                    "type": "string"
                                                  },
                                                  "operator": {
                                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                                    "type": "string",
                                                    "enum": [
                                                      "In",
                                                      "NotIn",
                                                      "Exists",
                                                      "DoesNotExist"
                                                    ]
                                                  },
                                                  "values": {
                                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                                    "type": "array",
                                                    "items": {
                                                      "type": "string"
                                                    }
                                                  }
                                                }
                                              }
                                            },
                                            "matchLabels": {
                                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                              "type": "object",
                                              "additionalProperties": {
                                                "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                                "type": "string",
                                                "maxLength": 63,
                                                "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        "egressDeny": {
                          "description": "EgressDeny is a list of EgressDenyRule which are enforced at egress. Any rule inserted here will be denied regardless of the allowed egress rules in the 'egress' field. If omitted or empty, this rule does not apply at egress.",
                          "type": "array",
                          "items": {
                            "description": "EgressDenyRule contains all rule types which can be applied at egress, i.e. network traffic that originates inside the endpoint and exits the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members of the structure are specified, then all members     must match in order for the rule to take effect. The exception to this     rule is the ToRequires member; the effects of any Requires field in any     rule will apply to all other rules as well. \n   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are     mutually exclusive. Only one of these members may be present within an     individual rule.",
                            "type": "object",
                            "properties": {
                              "icmps": {
                                "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is not allowed to initiate type 8 ICMP connections.",
                                "type": "array",
                                "items": {
                                  "description": "ICMPRule is a list of ICMP fields.",
                                  "type": "object",
                                  "properties": {
                                    "fields": {
                                      "description": "Fields is a list of ICMP fields.",
                                      "type": "array",
                                      "items": {
                                        "description": "ICMPField is a ICMP field.",
                                        "type": "object",
                                        "required": [
                                          "type"
                                        ],
                                        "properties": {
                                          "family": {
                                            "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                            "type": "string",
                                            "default": "IPv4",
                                            "enum": [
                                              "IPv4",
                                              "IPv6"
                                            ]
                                          },
                                          "type": {
                                            "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                            "type": "integer",
                                            "maximum": 255,
                                            "minimum": 0
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              },
                              "toCIDR": {
                                "description": "ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules.  This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24",
                                "type": "array",
                                "items": {
                                  "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                  "type": "string",
                                  "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                }
                              },
                              "toCIDRSet": {
                                "description": "ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.",
                                "type": "array",
                                "items": {
                                  "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                                  "type": "object",
                                  "oneOf": [
                                    {
                                      "required": [
                                        "cidr"
                                      ],
                                      "properties": {
                                        "cidr": {}
                                      }
                                    },
                                    {
                                      "required": [
                                        "cidrGroupRef"
                                      ],
                                      "properties": {
                                        "cidrGroupRef": {}
                                      }
                                    }
                                  ],
                                  "properties": {
                                    "cidr": {
                                      "description": "CIDR is a CIDR prefix / IP Block.",
                                      "type": "string",
                                      "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                    },
                                    "cidrGroupRef": {
                                      "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                                      "type": "string",
                                      "maxLength": 253,
                                      "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                                    },
                                    "except": {
                                      "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                                      "type": "array",
                                      "items": {
                                        "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                        "type": "string",
                                        "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                      }
                                    }
                                  }
                                }
                              },
                              "toEndpoints": {
                                "description": "ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\".",
                                "type": "array",
                                "items": {
                                  "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                  "type": "object",
                                  "properties": {
                                    "matchExpressions": {
                                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                      "type": "array",
                                      "items": {
                                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                        "type": "object",
                                        "required": [
                                          "key",
                                          "operator"
                                        ],
                                        "properties": {
                                          "key": {
                                            "description": "key is the label key that the selector applies to.",
                                            "type": "string"
                                          },
                                          "operator": {
                                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                            "type": "string",
                                            "enum": [
                                              "In",
                                              "NotIn",
                                              "Exists",
                                              "DoesNotExist"
                                            ]
                                          },
                                          "values": {
                                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "matchLabels": {
                                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                      "type": "object",
                                      "additionalProperties": {
                                        "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                        "type": "string",
                                        "maxLength": 63,
                                        "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                      }
                                    }
                                  }
                                }
                              },
                              "toEntities": {
                                "description": "ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`, `health`,`unmanaged` and `all`.",
                                "type": "array",
                                "items": {
                                  "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                                  "type": "string",
                                  "enum": [
                                    "all",
                                    "world",
                                    "cluster",
                                    "host",
                                    "init",
                                    "ingress",
                                    "unmanaged",
                                    "remote-node",
                                    "health",
                                    "none",
                                    "kube-apiserver"
                                  ]
                                }
                              },
                              "toGroups": {
                                "description": "ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws:     securityGroupsIds:     - 'sg-XXXXXXXXXXXXX'",
                                "type": "array",
                                "items": {
                                  "description": "ToGroups structure to store all kinds of new integrations that needs a new derivative policy.",
                                  "type": "object",
                                  "properties": {
                                    "aws": {
                                      "description": "AWSGroup is an structure that can be used to whitelisting information from AWS integration",
                                      "type": "object",
                                      "properties": {
                                        "labels": {
                                          "type": "object",
                                          "additionalProperties": {
                                            "type": "string"
                                          }
                                        },
                                        "region": {
                                          "type": "string"
                                        },
                                        "securityGroupsIds": {
                                          "type": "array",
                                          "items": {
                                            "type": "string"
                                          }
                                        },
                                        "securityGroupsNames": {
                                          "type": "array",
                                          "items": {
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              },
                              "toPorts": {
                                "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is not allowed to initiate connections to destination port 8080/tcp",
                                "type": "array",
                                "items": {
                                  "description": "PortDenyRule is a list of ports/protocol that should be used for deny policies. This structure lacks the L7Rules since it's not supported in deny policies.",
                                  "type": "object",
                                  "properties": {
                                    "ports": {
                                      "description": "Ports is a list of L4 port/protocol",
                                      "type": "array",
                                      "items": {
                                        "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                                        "type": "object",
                                        "required": [
                                          "port"
                                        ],
                                        "properties": {
                                          "port": {
                                            "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                            "type": "string",
                                            "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                          },
                                          "protocol": {
                                            "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                            "type": "string",
                                            "enum": [
                                              "TCP",
                                              "UDP",
                                              "SCTP",
                                              "ANY"
                                            ]
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              },
                              "toRequires": {
                                "description": "ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\".",
                                "type": "array",
                                "items": {
                                  "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                  "type": "object",
                                  "properties": {
                                    "matchExpressions": {
                                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                      "type": "array",
                                      "items": {
                                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                        "type": "object",
                                        "required": [
                                          "key",
                                          "operator"
                                        ],
                                        "properties": {
                                          "key": {
                                            "description": "key is the label key that the selector applies to.",
                                            "type": "string"
                                          },
                                          "operator": {
                                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                            "type": "string",
                                            "enum": [
                                              "In",
                                              "NotIn",
                                              "Exists",
                                              "DoesNotExist"
                                            ]
                                          },
                                          "values": {
                                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "matchLabels": {
                                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                      "type": "object",
                                      "additionalProperties": {
                                        "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                        "type": "string",
                                        "maxLength": 63,
                                        "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                      }
                                    }
                                  }
                                }
                              },
                              "toServices": {
                                "description": "ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service",
                                "type": "array",
                                "items": {
                                  "description": "Service wraps around selectors for services",
                                  "type": "object",
                                  "properties": {
                                    "k8sService": {
                                      "description": "K8sService selects service by name and namespace pair",
                                      "type": "object",
                                      "properties": {
                                        "namespace": {
                                          "type": "string"
                                        },
                                        "serviceName": {
                                          "type": "string"
                                        }
                                      }
                                    },
                                    "k8sServiceSelector": {
                                      "description": "K8sServiceSelector selects services by k8s labels and namespace",
                                      "type": "object",
                                      "required": [
                                        "selector"
                                      ],
                                      "properties": {
                                        "namespace": {
                                          "type": "string"
                                        },
                                        "selector": {
                                          "description": "ServiceSelector is a label selector for k8s services",
                                          "type": "object",
                                          "properties": {
                                            "matchExpressions": {
                                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                              "type": "array",
                                              "items": {
                                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                                "type": "object",
                                                "required": [
                                                  "key",
                                                  "operator"
                                                ],
                                                "properties": {
                                                  "key": {
                                                    "description": "key is the label key that the selector applies to.",
                                                    "type": "string"
                                                  },
                                                  "operator": {
                                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                                    "type": "string",
                                                    "enum": [
                                                      "In",
                                                      "NotIn",
                                                      "Exists",
                                                      "DoesNotExist"
                                                    ]
                                                  },
                                                  "values": {
                                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                                    "type": "array",
                                                    "items": {
                                                      "type": "string"
                                                    }
                                                  }
                                                }
                                              }
                                            },
                                            "matchLabels": {
                                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                              "type": "object",
                                              "additionalProperties": {
                                                "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                                "type": "string",
                                                "maxLength": 63,
                                                "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        "endpointSelector": {
                          "description": "EndpointSelector selects all endpoints which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive.",
                          "type": "object",
                          "properties": {
                            "matchExpressions": {
                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                              "type": "array",
                              "items": {
                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "key is the label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                    "type": "string",
                                    "enum": [
                                      "In",
                                      "NotIn",
                                      "Exists",
                                      "DoesNotExist"
                                    ]
                                  },
                                  "values": {
                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "matchLabels": {
                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                              "type": "object",
                              "additionalProperties": {
                                "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                "type": "string",
                                "maxLength": 63,
                                "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                              }
                            }
                          }
                        },
                        "ingress": {
                          "description": "Ingress is a list of IngressRule which are enforced at ingress. If omitted or empty, this rule does not apply at ingress.",
                          "type": "array",
                          "items": {
                            "description": "IngressRule contains all rule types which can be applied at ingress, i.e. network traffic that originates outside of the endpoint and is entering the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members are set, all of them need to match in order for     the rule to take effect. The exception to this rule is FromRequires field;     the effects of any Requires field in any rule will apply to all other     rules as well. \n   - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually     exclusive. Only one of these members may be present within an individual     rule.",
                            "type": "object",
                            "properties": {
                              "authentication": {
                                "description": "Authentication is the required authentication type for the allowed traffic, if any.",
                                "type": "object",
                                "required": [
                                  "mode"
                                ],
                                "properties": {
                                  "mode": {
                                    "description": "Mode is the required authentication mode for the allowed traffic, if any.",
                                    "type": "string",
                                    "enum": [
                                      "disabled",
                                      "required",
                                      "test-always-fail"
                                    ]
                                  }
                                }
                              },
                              "fromCIDR": {
                                "description": "FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do *not* originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field.  This will match on the source IP address of incoming connections. Adding  a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.3.9.1",
                                "type": "array",
                                "items": {
                                  "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                  "type": "string",
                                  "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                }
                              },
                              "fromCIDRSet": {
                                "description": "FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.",
                                "type": "array",
                                "items": {
                                  "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                                  "type": "object",
                                  "oneOf": [
                                    {
                                      "required": [
                                        "cidr"
                                      ],
                                      "properties": {
                                        "cidr": {}
                                      }
                                    },
                                    {
                                      "required": [
                                        "cidrGroupRef"
                                      ],
                                      "properties": {
                                        "cidrGroupRef": {}
                                      }
                                    }
                                  ],
                                  "properties": {
                                    "cidr": {
                                      "description": "CIDR is a CIDR prefix / IP Block.",
                                      "type": "string",
                                      "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                    },
                                    "cidrGroupRef": {
                                      "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                                      "type": "string",
                                      "maxLength": 253,
                                      "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                                    },
                                    "except": {
                                      "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                                      "type": "array",
                                      "items": {
                                        "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                        "type": "string",
                                        "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                      }
                                    }
                                  }
                                }
                              },
                              "fromEndpoints": {
                                "description": "FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\".",
                                "type": "array",
                                "items": {
                                  "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                  "type": "object",
                                  "properties": {
                                    "matchExpressions": {
                                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                      "type": "array",
                                      "items": {
                                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                        "type": "object",
                                        "required": [
                                          "key",
                                          "operator"
                                        ],
                                        "properties": {
                                          "key": {
                                            "description": "key is the label key that the selector applies to.",
                                            "type": "string"
                                          },
                                          "operator": {
                                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                            "type": "string",
                                            "enum": [
                                              "In",
                                              "NotIn",
                                              "Exists",
                                              "DoesNotExist"
                                            ]
                                          },
                                          "values": {
                                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "matchLabels": {
                                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                      "type": "object",
                                      "additionalProperties": {
                                        "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                        "type": "string",
                                        "maxLength": 63,
                                        "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                      }
                                    }
                                  }
                                }
                              },
                              "fromEntities": {
                                "description": "FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are `world`, `cluster` and `host`",
                                "type": "array",
                                "items": {
                                  "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                                  "type": "string",
                                  "enum": [
                                    "all",
                                    "world",
                                    "cluster",
                                    "host",
                                    "init",
                                    "ingress",
                                    "unmanaged",
                                    "remote-node",
                                    "health",
                                    "none",
                                    "kube-apiserver"
                                  ]
                                }
                              },
                              "fromRequires": {
                                "description": "FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\".",
                                "type": "array",
                                "items": {
                                  "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                  "type": "object",
                                  "properties": {
                                    "matchExpressions": {
                                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                      "type": "array",
                                      "items": {
                                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                        "type": "object",
                                        "required": [
                                          "key",
                                          "operator"
                                        ],
                                        "properties": {
                                          "key": {
                                            "description": "key is the label key that the selector applies to.",
                                            "type": "string"
                                          },
                                          "operator": {
                                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                            "type": "string",
                                            "enum": [
                                              "In",
                                              "NotIn",
                                              "Exists",
                                              "DoesNotExist"
                                            ]
                                          },
                                          "values": {
                                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "matchLabels": {
                                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                      "type": "object",
                                      "additionalProperties": {
                                        "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                        "type": "string",
                                        "maxLength": 63,
                                        "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                      }
                                    }
                                  }
                                }
                              },
                              "icmps": {
                                "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming type 8 ICMP connections.",
                                "type": "array",
                                "items": {
                                  "description": "ICMPRule is a list of ICMP fields.",
                                  "type": "object",
                                  "properties": {
                                    "fields": {
                                      "description": "Fields is a list of ICMP fields.",
                                      "type": "array",
                                      "items": {
                                        "description": "ICMPField is a ICMP field.",
                                        "type": "object",
                                        "required": [
                                          "type"
                                        ],
                                        "properties": {
                                          "family": {
                                            "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                            "type": "string",
                                            "default": "IPv4",
                                            "enum": [
                                              "IPv4",
                                              "IPv6"
                                            ]
                                          },
                                          "type": {
                                            "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                            "type": "integer",
                                            "maximum": 255,
                                            "minimum": 0
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              },
                              "toPorts": {
                                "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming connections on port 80/tcp.",
                                "type": "array",
                                "items": {
                                  "description": "PortRule is a list of ports/protocol combinations with optional Layer 7 rules which must be met.",
                                  "type": "object",
                                  "properties": {
                                    "listener": {
                                      "description": "listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.",
                                      "type": "object",
                                      "required": [
                                        "envoyConfig",
                                        "name"
                                      ],
                                      "properties": {
                                        "envoyConfig": {
                                          "description": "EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.",
                                          "type": "object",
                                          "required": [
                                            "name"
                                          ],
                                          "properties": {
                                            "kind": {
                                              "description": "Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.",
                                              "type": "string",
                                              "enum": [
                                                "CiliumEnvoyConfig",
                                                "CiliumClusterwideEnvoyConfig"
                                              ]
                                            },
                                            "name": {
                                              "description": "Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where the listener is defined in.",
                                              "type": "string",
                                              "minLength": 1
                                            }
                                          }
                                        },
                                        "name": {
                                          "description": "Name is the name of the listener.",
                                          "type": "string",
                                          "minLength": 1
                                        }
                                      }
                                    },
                                    "originatingTLS": {
                                      "description": "OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.",
                                      "type": "object",
                                      "required": [
                                        "secret"
                                      ],
                                      "properties": {
                                        "certificate": {
                                          "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                          "type": "string"
                                        },
                                        "privateKey": {
                                          "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                          "type": "string"
                                        },
                                        "secret": {
                                          "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                          "type": "object",
                                          "required": [
                                            "name"
                                          ],
                                          "properties": {
                                            "name": {
                                              "description": "Name is the name of the secret.",
                                              "type": "string"
                                            },
                                            "namespace": {
                                              "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "trustedCA": {
                                          "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                          "type": "string"
                                        }
                                      }
                                    },
                                    "ports": {
                                      "description": "Ports is a list of L4 port/protocol",
                                      "type": "array",
                                      "items": {
                                        "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                                        "type": "object",
                                        "required": [
                                          "port"
                                        ],
                                        "properties": {
                                          "port": {
                                            "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                            "type": "string",
                                            "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                          },
                                          "protocol": {
                                            "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                            "type": "string",
                                            "enum": [
                                              "TCP",
                                              "UDP",
                                              "SCTP",
                                              "ANY"
                                            ]
                                          }
                                        }
                                      }
                                    },
                                    "rules": {
                                      "description": "Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.",
                                      "type": "object",
                                      "properties": {
                                        "dns": {
                                          "description": "DNS-specific rules.",
                                          "type": "array",
                                          "items": {
                                            "description": "PortRuleDNS is a list of allowed DNS lookups.",
                                            "type": "object",
                                            "properties": {
                                              "matchName": {
                                                "description": "MatchName matches literal DNS names. A trailing \".\" is automatically added when missing.",
                                                "type": "string",
                                                "pattern": "^([-a-zA-Z0-9_]+[.]?)+$"
                                              },
                                              "matchPattern": {
                                                "description": "MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"*\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"*\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: `*.cilium.io` matches subomains of cilium at that level   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with \"cilium.io\"   except those containing \".\" separator, subcilium.io and sub-cilium.io match,   www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\"   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,   blog.cilium.io, cilium.io and google.com do not",
                                                "type": "string",
                                                "pattern": "^([-a-zA-Z0-9_*]+[.]?)+$"
                                              }
                                            }
                                          }
                                        },
                                        "http": {
                                          "description": "HTTP specific rules.",
                                          "type": "array",
                                          "items": {
                                            "description": "PortRuleHTTP is a list of HTTP protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect. \n All fields of this type are extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986.",
                                            "type": "object",
                                            "properties": {
                                              "headerMatches": {
                                                "description": "HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match.",
                                                "type": "array",
                                                "items": {
                                                  "description": "HeaderMatch extends the HeaderValue for matching requirement of a named header field against an immediate string, a secret value, or a regex.  If none of the optional fields is present, then the header value is not matched, only presence of the header is enough.",
                                                  "type": "object",
                                                  "required": [
                                                    "name"
                                                  ],
                                                  "properties": {
                                                    "mismatch": {
                                                      "description": "Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.",
                                                      "type": "string",
                                                      "enum": [
                                                        "LOG",
                                                        "ADD",
                                                        "DELETE",
                                                        "REPLACE"
                                                      ]
                                                    },
                                                    "name": {
                                                      "description": "Name identifies the header.",
                                                      "type": "string"
                                                    },
                                                    "secret": {
                                                      "description": "Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no \"Value\" specified, the match will fail.",
                                                      "type": "object",
                                                      "required": [
                                                        "name"
                                                      ],
                                                      "properties": {
                                                        "name": {
                                                          "description": "Name is the name of the secret.",
                                                          "type": "string"
                                                        },
                                                        "namespace": {
                                                          "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                                          "type": "string"
                                                        }
                                                      }
                                                    },
                                                    "value": {
                                                      "description": "Value matches the exact value of the header. Can be specified either alone or together with \"Secret\"; will be used as the header value if the secret can not be found in the latter case.",
                                                      "type": "string"
                                                    }
                                                  }
                                                }
                                              },
                                              "headers": {
                                                "description": "Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present.",
                                                "type": "array",
                                                "items": {
                                                  "type": "string"
                                                }
                                              },
                                              "host": {
                                                "description": "Host is an extended POSIX regex matched against the host header of a request, e.g. \"foo.com\" \n If omitted or empty, the value of the host header is ignored.",
                                                "type": "string",
                                                "format": "idn-hostname"
                                              },
                                              "method": {
                                                "description": "Method is an extended POSIX regex matched against the method of a request, e.g. \"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\", ... \n If omitted or empty, all methods are allowed.",
                                                "type": "string"
                                              },
                                              "path": {
                                                "description": "Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986. \n If omitted or empty, all paths are all allowed.",
                                                "type": "string"
                                              }
                                            }
                                          }
                                        },
                                        "kafka": {
                                          "description": "Kafka-specific rules.",
                                          "type": "array",
                                          "items": {
                                            "description": "PortRule is a list of Kafka protocol constraints. All fields are optional, if all fields are empty or missing, the rule will match all Kafka messages.",
                                            "type": "object",
                                            "properties": {
                                              "apiKey": {
                                                "description": "APIKey is a case-insensitive string matched against the key of a request, e.g. \"produce\", \"fetch\", \"createtopic\", \"deletetopic\", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys \n If omitted or empty, and if Role is not specified, then all keys are allowed.",
                                                "type": "string"
                                              },
                                              "apiVersion": {
                                                "description": "APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer. \n If omitted or empty, all versions are allowed.",
                                                "type": "string"
                                              },
                                              "clientID": {
                                                "description": "ClientID is the client identifier as provided in the request. \n From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client. \n If omitted or empty, all client identifiers are allowed.",
                                                "type": "string"
                                              },
                                              "role": {
                                                "description": "Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as \"produce\" or \"consume\". A Role automatically expands into all APIKeys required to perform the specified higher-level operation. \n The following values are supported:  - \"produce\": Allow producing to the topics specified in the rule  - \"consume\": Allow consuming from the topics specified in the rule \n This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule. \n If omitted or empty, and if APIKey is not specified, then all keys are allowed.",
                                                "type": "string",
                                                "enum": [
                                                  "produce",
                                                  "consume"
                                                ]
                                              },
                                              "topic": {
                                                "description": "Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected. \n This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _. \n Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255. \n If omitted or empty, all topics are allowed.",
                                                "type": "string",
                                                "maxLength": 255
                                              }
                                            }
                                          }
                                        },
                                        "l7": {
                                          "description": "Key-value pair rules.",
                                          "type": "array",
                                          "items": {
                                            "description": "PortRuleL7 is a list of key-value pairs interpreted by a L7 protocol as protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect.",
                                            "type": "object",
                                            "additionalProperties": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "l7proto": {
                                          "description": "Name of the L7 protocol for which the Key-value pair rules apply.",
                                          "type": "string"
                                        }
                                      }
                                    },
                                    "serverNames": {
                                      "description": "ServerNames is a list of allowed TLS SNI values. If not empty, then TLS must be present and one of the provided SNIs must be indicated in the TLS handshake.",
                                      "type": "array",
                                      "items": {
                                        "type": "string"
                                      }
                                    },
                                    "terminatingTLS": {
                                      "description": "TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.",
                                      "type": "object",
                                      "required": [
                                        "secret"
                                      ],
                                      "properties": {
                                        "certificate": {
                                          "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                          "type": "string"
                                        },
                                        "privateKey": {
                                          "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                          "type": "string"
                                        },
                                        "secret": {
                                          "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                          "type": "object",
                                          "required": [
                                            "name"
                                          ],
                                          "properties": {
                                            "name": {
                                              "description": "Name is the name of the secret.",
                                              "type": "string"
                                            },
                                            "namespace": {
                                              "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "trustedCA": {
                                          "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                          "type": "string"
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        "ingressDeny": {
                          "description": "IngressDeny is a list of IngressDenyRule which are enforced at ingress. Any rule inserted here will be denied regardless of the allowed ingress rules in the 'ingress' field. If omitted or empty, this rule does not apply at ingress.",
                          "type": "array",
                          "items": {
                            "description": "IngressDenyRule contains all rule types which can be applied at ingress, i.e. network traffic that originates outside of the endpoint and is entering the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members are set, all of them need to match in order for     the rule to take effect. The exception to this rule is FromRequires field;     the effects of any Requires field in any rule will apply to all other     rules as well. \n   - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually     exclusive. Only one of these members may be present within an individual     rule.",
                            "type": "object",
                            "properties": {
                              "fromCIDR": {
                                "description": "FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do *not* originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field.  This will match on the source IP address of incoming connections. Adding  a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.3.9.1",
                                "type": "array",
                                "items": {
                                  "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                  "type": "string",
                                  "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                }
                              },
                              "fromCIDRSet": {
                                "description": "FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.",
                                "type": "array",
                                "items": {
                                  "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                                  "type": "object",
                                  "oneOf": [
                                    {
                                      "required": [
                                        "cidr"
                                      ],
                                      "properties": {
                                        "cidr": {}
                                      }
                                    },
                                    {
                                      "required": [
                                        "cidrGroupRef"
                                      ],
                                      "properties": {
                                        "cidrGroupRef": {}
                                      }
                                    }
                                  ],
                                  "properties": {
                                    "cidr": {
                                      "description": "CIDR is a CIDR prefix / IP Block.",
                                      "type": "string",
                                      "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                    },
                                    "cidrGroupRef": {
                                      "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                                      "type": "string",
                                      "maxLength": 253,
                                      "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                                    },
                                    "except": {
                                      "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                                      "type": "array",
                                      "items": {
                                        "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                        "type": "string",
                                        "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                      }
                                    }
                                  }
                                }
                              },
                              "fromEndpoints": {
                                "description": "FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\".",
                                "type": "array",
                                "items": {
                                  "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                  "type": "object",
                                  "properties": {
                                    "matchExpressions": {
                                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                      "type": "array",
                                      "items": {
                                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                        "type": "object",
                                        "required": [
                                          "key",
                                          "operator"
                                        ],
                                        "properties": {
                                          "key": {
                                            "description": "key is the label key that the selector applies to.",
                                            "type": "string"
                                          },
                                          "operator": {
                                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                            "type": "string",
                                            "enum": [
                                              "In",
                                              "NotIn",
                                              "Exists",
                                              "DoesNotExist"
                                            ]
                                          },
                                          "values": {
                                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "matchLabels": {
                                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                      "type": "object",
                                      "additionalProperties": {
                                        "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                        "type": "string",
                                        "maxLength": 63,
                                        "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                      }
                                    }
                                  }
                                }
                              },
                              "fromEntities": {
                                "description": "FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are `world`, `cluster` and `host`",
                                "type": "array",
                                "items": {
                                  "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                                  "type": "string",
                                  "enum": [
                                    "all",
                                    "world",
                                    "cluster",
                                    "host",
                                    "init",
                                    "ingress",
                                    "unmanaged",
                                    "remote-node",
                                    "health",
                                    "none",
                                    "kube-apiserver"
                                  ]
                                }
                              },
                              "fromRequires": {
                                "description": "FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\".",
                                "type": "array",
                                "items": {
                                  "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                  "type": "object",
                                  "properties": {
                                    "matchExpressions": {
                                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                      "type": "array",
                                      "items": {
                                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                        "type": "object",
                                        "required": [
                                          "key",
                                          "operator"
                                        ],
                                        "properties": {
                                          "key": {
                                            "description": "key is the label key that the selector applies to.",
                                            "type": "string"
                                          },
                                          "operator": {
                                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                            "type": "string",
                                            "enum": [
                                              "In",
                                              "NotIn",
                                              "Exists",
                                              "DoesNotExist"
                                            ]
                                          },
                                          "values": {
                                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "matchLabels": {
                                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                      "type": "object",
                                      "additionalProperties": {
                                        "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                        "type": "string",
                                        "maxLength": 63,
                                        "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                      }
                                    }
                                  }
                                }
                              },
                              "icmps": {
                                "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming type 8 ICMP connections.",
                                "type": "array",
                                "items": {
                                  "description": "ICMPRule is a list of ICMP fields.",
                                  "type": "object",
                                  "properties": {
                                    "fields": {
                                      "description": "Fields is a list of ICMP fields.",
                                      "type": "array",
                                      "items": {
                                        "description": "ICMPField is a ICMP field.",
                                        "type": "object",
                                        "required": [
                                          "type"
                                        ],
                                        "properties": {
                                          "family": {
                                            "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                            "type": "string",
                                            "default": "IPv4",
                                            "enum": [
                                              "IPv4",
                                              "IPv6"
                                            ]
                                          },
                                          "type": {
                                            "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                            "type": "integer",
                                            "maximum": 255,
                                            "minimum": 0
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              },
                              "toPorts": {
                                "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming connections on port 80/tcp.",
                                "type": "array",
                                "items": {
                                  "description": "PortDenyRule is a list of ports/protocol that should be used for deny policies. This structure lacks the L7Rules since it's not supported in deny policies.",
                                  "type": "object",
                                  "properties": {
                                    "ports": {
                                      "description": "Ports is a list of L4 port/protocol",
                                      "type": "array",
                                      "items": {
                                        "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                                        "type": "object",
                                        "required": [
                                          "port"
                                        ],
                                        "properties": {
                                          "port": {
                                            "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                            "type": "string",
                                            "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                          },
                                          "protocol": {
                                            "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                            "type": "string",
                                            "enum": [
                                              "TCP",
                                              "UDP",
                                              "SCTP",
                                              "ANY"
                                            ]
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        "labels": {
                          "description": "Labels is a list of optional strings which can be used to re-identify the rule or to store metadata. It is possible to lookup or delete strings based on labels. Labels are not required to be unique, multiple rules can have overlapping or identical labels.",
                          "type": "array",
                          "items": {
                            "description": "Label is the Cilium's representation of a container label.",
                            "type": "object",
                            "required": [
                              "key"
                            ],
                            "properties": {
                              "key": {
                                "type": "string"
                              },
                              "source": {
                                "description": "Source can be one of the above values (e.g.: LabelSourceContainer).",
                                "type": "string"
                              },
                              "value": {
                                "type": "string"
                              }
                            }
                          }
                        },
                        "nodeSelector": {
                          "description": "NodeSelector selects all nodes which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive. Can only be used in CiliumClusterwideNetworkPolicies.",
                          "type": "object",
                          "properties": {
                            "matchExpressions": {
                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                              "type": "array",
                              "items": {
                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "key is the label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                    "type": "string",
                                    "enum": [
                                      "In",
                                      "NotIn",
                                      "Exists",
                                      "DoesNotExist"
                                    ]
                                  },
                                  "values": {
                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "matchLabels": {
                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                              "type": "object",
                              "additionalProperties": {
                                "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                "type": "string",
                                "maxLength": 63,
                                "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                              }
                            }
                          }
                        }
                      }
                    },
                    "specs": {
                      "description": "Specs is a list of desired Cilium specific rule specification.",
                      "type": "array",
                      "items": {
                        "description": "Rule is a policy rule which must be applied to all endpoints which match the labels contained in the endpointSelector \n Each rule is split into an ingress section which contains all rules applicable at ingress, and an egress section applicable at egress. For rule types such as `L4Rule` and `CIDR` which can be applied at both ingress and egress, both ingress and egress side have to either specifically allow the connection or one side has to be omitted. \n Either ingress, egress, or both can be provided. If both ingress and egress are omitted, the rule has no effect.",
                        "type": "object",
                        "oneOf": [
                          {
                            "required": [
                              "endpointSelector"
                            ],
                            "properties": {
                              "endpointSelector": {}
                            }
                          },
                          {
                            "required": [
                              "nodeSelector"
                            ],
                            "properties": {
                              "nodeSelector": {}
                            }
                          }
                        ],
                        "properties": {
                          "description": {
                            "description": "Description is a free form string, it can be used by the creator of the rule to store human readable explanation of the purpose of this rule. Rules cannot be identified by comment.",
                            "type": "string"
                          },
                          "egress": {
                            "description": "Egress is a list of EgressRule which are enforced at egress. If omitted or empty, this rule does not apply at egress.",
                            "type": "array",
                            "items": {
                              "description": "EgressRule contains all rule types which can be applied at egress, i.e. network traffic that originates inside the endpoint and exits the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members of the structure are specified, then all members     must match in order for the rule to take effect. The exception to this     rule is the ToRequires member; the effects of any Requires field in any     rule will apply to all other rules as well. \n   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are     mutually exclusive. Only one of these members may be present within an     individual rule.",
                              "type": "object",
                              "properties": {
                                "authentication": {
                                  "description": "Authentication is the required authentication type for the allowed traffic, if any.",
                                  "type": "object",
                                  "required": [
                                    "mode"
                                  ],
                                  "properties": {
                                    "mode": {
                                      "description": "Mode is the required authentication mode for the allowed traffic, if any.",
                                      "type": "string",
                                      "enum": [
                                        "disabled",
                                        "required",
                                        "test-always-fail"
                                      ]
                                    }
                                  }
                                },
                                "icmps": {
                                  "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is allowed to initiate type 8 ICMP connections.",
                                  "type": "array",
                                  "items": {
                                    "description": "ICMPRule is a list of ICMP fields.",
                                    "type": "object",
                                    "properties": {
                                      "fields": {
                                        "description": "Fields is a list of ICMP fields.",
                                        "type": "array",
                                        "items": {
                                          "description": "ICMPField is a ICMP field.",
                                          "type": "object",
                                          "required": [
                                            "type"
                                          ],
                                          "properties": {
                                            "family": {
                                              "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                              "type": "string",
                                              "default": "IPv4",
                                              "enum": [
                                                "IPv4",
                                                "IPv6"
                                              ]
                                            },
                                            "type": {
                                              "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                              "type": "integer",
                                              "maximum": 255,
                                              "minimum": 0
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                "toCIDR": {
                                  "description": "ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules.  This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24",
                                  "type": "array",
                                  "items": {
                                    "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                    "type": "string",
                                    "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                  }
                                },
                                "toCIDRSet": {
                                  "description": "ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.",
                                  "type": "array",
                                  "items": {
                                    "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                                    "type": "object",
                                    "oneOf": [
                                      {
                                        "required": [
                                          "cidr"
                                        ],
                                        "properties": {
                                          "cidr": {}
                                        }
                                      },
                                      {
                                        "required": [
                                          "cidrGroupRef"
                                        ],
                                        "properties": {
                                          "cidrGroupRef": {}
                                        }
                                      }
                                    ],
                                    "properties": {
                                      "cidr": {
                                        "description": "CIDR is a CIDR prefix / IP Block.",
                                        "type": "string",
                                        "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                      },
                                      "cidrGroupRef": {
                                        "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                                        "type": "string",
                                        "maxLength": 253,
                                        "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                                      },
                                      "except": {
                                        "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                                        "type": "array",
                                        "items": {
                                          "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                          "type": "string",
                                          "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                        }
                                      }
                                    }
                                  }
                                },
                                "toEndpoints": {
                                  "description": "ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\".",
                                  "type": "array",
                                  "items": {
                                    "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string",
                                              "enum": [
                                                "In",
                                                "NotIn",
                                                "Exists",
                                                "DoesNotExist"
                                              ]
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                          "type": "string",
                                          "maxLength": 63,
                                          "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                        }
                                      }
                                    }
                                  }
                                },
                                "toEntities": {
                                  "description": "ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`, `health`,`unmanaged` and `all`.",
                                  "type": "array",
                                  "items": {
                                    "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                                    "type": "string",
                                    "enum": [
                                      "all",
                                      "world",
                                      "cluster",
                                      "host",
                                      "init",
                                      "ingress",
                                      "unmanaged",
                                      "remote-node",
                                      "health",
                                      "none",
                                      "kube-apiserver"
                                    ]
                                  }
                                },
                                "toFQDNs": {
                                  "description": "ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result from DNS resolution of `ToFQDN.MatchName`s are added to the same EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and L7 rules within this EgressRule will also apply to these IPs. The DNS -> IP mapping is re-resolved periodically from within the cilium-agent, and the IPs in the DNS response are effected in the policy for selected pods as-is (i.e. the list of IPs is not modified in any way). Note: An explicit rule to allow for DNS traffic is needed for the pods, as ToFQDN counts as an egress rule and will enforce egress policy when PolicyEnforcment=default. Note: If the resolved IPs are IPs within the kubernetes cluster, the ToFQDN rule will not apply to that IP. Note: ToFQDN cannot occur in the same policy as other To* rules.",
                                  "type": "array",
                                  "items": {
                                    "type": "object",
                                    "properties": {
                                      "matchName": {
                                        "description": "MatchName matches literal DNS names. A trailing \".\" is automatically added when missing.",
                                        "type": "string",
                                        "pattern": "^([-a-zA-Z0-9_]+[.]?)+$"
                                      },
                                      "matchPattern": {
                                        "description": "MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"*\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"*\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: `*.cilium.io` matches subomains of cilium at that level   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with \"cilium.io\"   except those containing \".\" separator, subcilium.io and sub-cilium.io match,   www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\"   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,   blog.cilium.io, cilium.io and google.com do not",
                                        "type": "string",
                                        "pattern": "^([-a-zA-Z0-9_*]+[.]?)+$"
                                      }
                                    }
                                  }
                                },
                                "toGroups": {
                                  "description": "ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws:     securityGroupsIds:     - 'sg-XXXXXXXXXXXXX'",
                                  "type": "array",
                                  "items": {
                                    "description": "ToGroups structure to store all kinds of new integrations that needs a new derivative policy.",
                                    "type": "object",
                                    "properties": {
                                      "aws": {
                                        "description": "AWSGroup is an structure that can be used to whitelisting information from AWS integration",
                                        "type": "object",
                                        "properties": {
                                          "labels": {
                                            "type": "object",
                                            "additionalProperties": {
                                              "type": "string"
                                            }
                                          },
                                          "region": {
                                            "type": "string"
                                          },
                                          "securityGroupsIds": {
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          },
                                          "securityGroupsNames": {
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                "toPorts": {
                                  "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is allowed to initiate connections to destination port 8080/tcp",
                                  "type": "array",
                                  "items": {
                                    "description": "PortRule is a list of ports/protocol combinations with optional Layer 7 rules which must be met.",
                                    "type": "object",
                                    "properties": {
                                      "listener": {
                                        "description": "listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.",
                                        "type": "object",
                                        "required": [
                                          "envoyConfig",
                                          "name"
                                        ],
                                        "properties": {
                                          "envoyConfig": {
                                            "description": "EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.",
                                            "type": "object",
                                            "required": [
                                              "name"
                                            ],
                                            "properties": {
                                              "kind": {
                                                "description": "Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.",
                                                "type": "string",
                                                "enum": [
                                                  "CiliumEnvoyConfig",
                                                  "CiliumClusterwideEnvoyConfig"
                                                ]
                                              },
                                              "name": {
                                                "description": "Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where the listener is defined in.",
                                                "type": "string",
                                                "minLength": 1
                                              }
                                            }
                                          },
                                          "name": {
                                            "description": "Name is the name of the listener.",
                                            "type": "string",
                                            "minLength": 1
                                          }
                                        }
                                      },
                                      "originatingTLS": {
                                        "description": "OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.",
                                        "type": "object",
                                        "required": [
                                          "secret"
                                        ],
                                        "properties": {
                                          "certificate": {
                                            "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                            "type": "string"
                                          },
                                          "privateKey": {
                                            "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                            "type": "string"
                                          },
                                          "secret": {
                                            "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                            "type": "object",
                                            "required": [
                                              "name"
                                            ],
                                            "properties": {
                                              "name": {
                                                "description": "Name is the name of the secret.",
                                                "type": "string"
                                              },
                                              "namespace": {
                                                "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                                "type": "string"
                                              }
                                            }
                                          },
                                          "trustedCA": {
                                            "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                            "type": "string"
                                          }
                                        }
                                      },
                                      "ports": {
                                        "description": "Ports is a list of L4 port/protocol",
                                        "type": "array",
                                        "items": {
                                          "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                                          "type": "object",
                                          "required": [
                                            "port"
                                          ],
                                          "properties": {
                                            "port": {
                                              "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                              "type": "string",
                                              "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                            },
                                            "protocol": {
                                              "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                              "type": "string",
                                              "enum": [
                                                "TCP",
                                                "UDP",
                                                "SCTP",
                                                "ANY"
                                              ]
                                            }
                                          }
                                        }
                                      },
                                      "rules": {
                                        "description": "Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.",
                                        "type": "object",
                                        "properties": {
                                          "dns": {
                                            "description": "DNS-specific rules.",
                                            "type": "array",
                                            "items": {
                                              "description": "PortRuleDNS is a list of allowed DNS lookups.",
                                              "type": "object",
                                              "properties": {
                                                "matchName": {
                                                  "description": "MatchName matches literal DNS names. A trailing \".\" is automatically added when missing.",
                                                  "type": "string",
                                                  "pattern": "^([-a-zA-Z0-9_]+[.]?)+$"
                                                },
                                                "matchPattern": {
                                                  "description": "MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"*\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"*\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: `*.cilium.io` matches subomains of cilium at that level   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with \"cilium.io\"   except those containing \".\" separator, subcilium.io and sub-cilium.io match,   www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\"   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,   blog.cilium.io, cilium.io and google.com do not",
                                                  "type": "string",
                                                  "pattern": "^([-a-zA-Z0-9_*]+[.]?)+$"
                                                }
                                              }
                                            }
                                          },
                                          "http": {
                                            "description": "HTTP specific rules.",
                                            "type": "array",
                                            "items": {
                                              "description": "PortRuleHTTP is a list of HTTP protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect. \n All fields of this type are extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986.",
                                              "type": "object",
                                              "properties": {
                                                "headerMatches": {
                                                  "description": "HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match.",
                                                  "type": "array",
                                                  "items": {
                                                    "description": "HeaderMatch extends the HeaderValue for matching requirement of a named header field against an immediate string, a secret value, or a regex.  If none of the optional fields is present, then the header value is not matched, only presence of the header is enough.",
                                                    "type": "object",
                                                    "required": [
                                                      "name"
                                                    ],
                                                    "properties": {
                                                      "mismatch": {
                                                        "description": "Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.",
                                                        "type": "string",
                                                        "enum": [
                                                          "LOG",
                                                          "ADD",
                                                          "DELETE",
                                                          "REPLACE"
                                                        ]
                                                      },
                                                      "name": {
                                                        "description": "Name identifies the header.",
                                                        "type": "string"
                                                      },
                                                      "secret": {
                                                        "description": "Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no \"Value\" specified, the match will fail.",
                                                        "type": "object",
                                                        "required": [
                                                          "name"
                                                        ],
                                                        "properties": {
                                                          "name": {
                                                            "description": "Name is the name of the secret.",
                                                            "type": "string"
                                                          },
                                                          "namespace": {
                                                            "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                                            "type": "string"
                                                          }
                                                        }
                                                      },
                                                      "value": {
                                                        "description": "Value matches the exact value of the header. Can be specified either alone or together with \"Secret\"; will be used as the header value if the secret can not be found in the latter case.",
                                                        "type": "string"
                                                      }
                                                    }
                                                  }
                                                },
                                                "headers": {
                                                  "description": "Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present.",
                                                  "type": "array",
                                                  "items": {
                                                    "type": "string"
                                                  }
                                                },
                                                "host": {
                                                  "description": "Host is an extended POSIX regex matched against the host header of a request, e.g. \"foo.com\" \n If omitted or empty, the value of the host header is ignored.",
                                                  "type": "string",
                                                  "format": "idn-hostname"
                                                },
                                                "method": {
                                                  "description": "Method is an extended POSIX regex matched against the method of a request, e.g. \"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\", ... \n If omitted or empty, all methods are allowed.",
                                                  "type": "string"
                                                },
                                                "path": {
                                                  "description": "Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986. \n If omitted or empty, all paths are all allowed.",
                                                  "type": "string"
                                                }
                                              }
                                            }
                                          },
                                          "kafka": {
                                            "description": "Kafka-specific rules.",
                                            "type": "array",
                                            "items": {
                                              "description": "PortRule is a list of Kafka protocol constraints. All fields are optional, if all fields are empty or missing, the rule will match all Kafka messages.",
                                              "type": "object",
                                              "properties": {
                                                "apiKey": {
                                                  "description": "APIKey is a case-insensitive string matched against the key of a request, e.g. \"produce\", \"fetch\", \"createtopic\", \"deletetopic\", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys \n If omitted or empty, and if Role is not specified, then all keys are allowed.",
                                                  "type": "string"
                                                },
                                                "apiVersion": {
                                                  "description": "APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer. \n If omitted or empty, all versions are allowed.",
                                                  "type": "string"
                                                },
                                                "clientID": {
                                                  "description": "ClientID is the client identifier as provided in the request. \n From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client. \n If omitted or empty, all client identifiers are allowed.",
                                                  "type": "string"
                                                },
                                                "role": {
                                                  "description": "Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as \"produce\" or \"consume\". A Role automatically expands into all APIKeys required to perform the specified higher-level operation. \n The following values are supported:  - \"produce\": Allow producing to the topics specified in the rule  - \"consume\": Allow consuming from the topics specified in the rule \n This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule. \n If omitted or empty, and if APIKey is not specified, then all keys are allowed.",
                                                  "type": "string",
                                                  "enum": [
                                                    "produce",
                                                    "consume"
                                                  ]
                                                },
                                                "topic": {
                                                  "description": "Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected. \n This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _. \n Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255. \n If omitted or empty, all topics are allowed.",
                                                  "type": "string",
                                                  "maxLength": 255
                                                }
                                              }
                                            }
                                          },
                                          "l7": {
                                            "description": "Key-value pair rules.",
                                            "type": "array",
                                            "items": {
                                              "description": "PortRuleL7 is a list of key-value pairs interpreted by a L7 protocol as protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect.",
                                              "type": "object",
                                              "additionalProperties": {
                                                "type": "string"
                                              }
                                            }
                                          },
                                          "l7proto": {
                                            "description": "Name of the L7 protocol for which the Key-value pair rules apply.",
                                            "type": "string"
                                          }
                                        }
                                      },
                                      "serverNames": {
                                        "description": "ServerNames is a list of allowed TLS SNI values. If not empty, then TLS must be present and one of the provided SNIs must be indicated in the TLS handshake.",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        }
                                      },
                                      "terminatingTLS": {
                                        "description": "TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.",
                                        "type": "object",
                                        "required": [
                                          "secret"
                                        ],
                                        "properties": {
                                          "certificate": {
                                            "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                            "type": "string"
                                          },
                                          "privateKey": {
                                            "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                            "type": "string"
                                          },
                                          "secret": {
                                            "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                            "type": "object",
                                            "required": [
                                              "name"
                                            ],
                                            "properties": {
                                              "name": {
                                                "description": "Name is the name of the secret.",
                                                "type": "string"
                                              },
                                              "namespace": {
                                                "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                                "type": "string"
                                              }
                                            }
                                          },
                                          "trustedCA": {
                                            "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                "toRequires": {
                                  "description": "ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\".",
                                  "type": "array",
                                  "items": {
                                    "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string",
                                              "enum": [
                                                "In",
                                                "NotIn",
                                                "Exists",
                                                "DoesNotExist"
                                              ]
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                          "type": "string",
                                          "maxLength": 63,
                                          "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                        }
                                      }
                                    }
                                  }
                                },
                                "toServices": {
                                  "description": "ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service",
                                  "type": "array",
                                  "items": {
                                    "description": "Service wraps around selectors for services",
                                    "type": "object",
                                    "properties": {
                                      "k8sService": {
                                        "description": "K8sService selects service by name and namespace pair",
                                        "type": "object",
                                        "properties": {
                                          "namespace": {
                                            "type": "string"
                                          },
                                          "serviceName": {
                                            "type": "string"
                                          }
                                        }
                                      },
                                      "k8sServiceSelector": {
                                        "description": "K8sServiceSelector selects services by k8s labels and namespace",
                                        "type": "object",
                                        "required": [
                                          "selector"
                                        ],
                                        "properties": {
                                          "namespace": {
                                            "type": "string"
                                          },
                                          "selector": {
                                            "description": "ServiceSelector is a label selector for k8s services",
                                            "type": "object",
                                            "properties": {
                                              "matchExpressions": {
                                                "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                                "type": "array",
                                                "items": {
                                                  "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                                  "type": "object",
                                                  "required": [
                                                    "key",
                                                    "operator"
                                                  ],
                                                  "properties": {
                                                    "key": {
                                                      "description": "key is the label key that the selector applies to.",
                                                      "type": "string"
                                                    },
                                                    "operator": {
                                                      "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                                      "type": "string",
                                                      "enum": [
                                                        "In",
                                                        "NotIn",
                                                        "Exists",
                                                        "DoesNotExist"
                                                      ]
                                                    },
                                                    "values": {
                                                      "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                                      "type": "array",
                                                      "items": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  }
                                                }
                                              },
                                              "matchLabels": {
                                                "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                                "type": "object",
                                                "additionalProperties": {
                                                  "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                                  "type": "string",
                                                  "maxLength": 63,
                                                  "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          "egressDeny": {
                            "description": "EgressDeny is a list of EgressDenyRule which are enforced at egress. Any rule inserted here will be denied regardless of the allowed egress rules in the 'egress' field. If omitted or empty, this rule does not apply at egress.",
                            "type": "array",
                            "items": {
                              "description": "EgressDenyRule contains all rule types which can be applied at egress, i.e. network traffic that originates inside the endpoint and exits the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members of the structure are specified, then all members     must match in order for the rule to take effect. The exception to this     rule is the ToRequires member; the effects of any Requires field in any     rule will apply to all other rules as well. \n   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are     mutually exclusive. Only one of these members may be present within an     individual rule.",
                              "type": "object",
                              "properties": {
                                "icmps": {
                                  "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is not allowed to initiate type 8 ICMP connections.",
                                  "type": "array",
                                  "items": {
                                    "description": "ICMPRule is a list of ICMP fields.",
                                    "type": "object",
                                    "properties": {
                                      "fields": {
                                        "description": "Fields is a list of ICMP fields.",
                                        "type": "array",
                                        "items": {
                                          "description": "ICMPField is a ICMP field.",
                                          "type": "object",
                                          "required": [
                                            "type"
                                          ],
                                          "properties": {
                                            "family": {
                                              "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                              "type": "string",
                                              "default": "IPv4",
                                              "enum": [
                                                "IPv4",
                                                "IPv6"
                                              ]
                                            },
                                            "type": {
                                              "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                              "type": "integer",
                                              "maximum": 255,
                                              "minimum": 0
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                "toCIDR": {
                                  "description": "ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules.  This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24",
                                  "type": "array",
                                  "items": {
                                    "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                    "type": "string",
                                    "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                  }
                                },
                                "toCIDRSet": {
                                  "description": "ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.",
                                  "type": "array",
                                  "items": {
                                    "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                                    "type": "object",
                                    "oneOf": [
                                      {
                                        "required": [
                                          "cidr"
                                        ],
                                        "properties": {
                                          "cidr": {}
                                        }
                                      },
                                      {
                                        "required": [
                                          "cidrGroupRef"
                                        ],
                                        "properties": {
                                          "cidrGroupRef": {}
                                        }
                                      }
                                    ],
                                    "properties": {
                                      "cidr": {
                                        "description": "CIDR is a CIDR prefix / IP Block.",
                                        "type": "string",
                                        "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                      },
                                      "cidrGroupRef": {
                                        "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                                        "type": "string",
                                        "maxLength": 253,
                                        "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                                      },
                                      "except": {
                                        "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                                        "type": "array",
                                        "items": {
                                          "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                          "type": "string",
                                          "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                        }
                                      }
                                    }
                                  }
                                },
                                "toEndpoints": {
                                  "description": "ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\".",
                                  "type": "array",
                                  "items": {
                                    "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string",
                                              "enum": [
                                                "In",
                                                "NotIn",
                                                "Exists",
                                                "DoesNotExist"
                                              ]
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                          "type": "string",
                                          "maxLength": 63,
                                          "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                        }
                                      }
                                    }
                                  }
                                },
                                "toEntities": {
                                  "description": "ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`, `health`,`unmanaged` and `all`.",
                                  "type": "array",
                                  "items": {
                                    "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                                    "type": "string",
                                    "enum": [
                                      "all",
                                      "world",
                                      "cluster",
                                      "host",
                                      "init",
                                      "ingress",
                                      "unmanaged",
                                      "remote-node",
                                      "health",
                                      "none",
                                      "kube-apiserver"
                                    ]
                                  }
                                },
                                "toGroups": {
                                  "description": "ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws:     securityGroupsIds:     - 'sg-XXXXXXXXXXXXX'",
                                  "type": "array",
                                  "items": {
                                    "description": "ToGroups structure to store all kinds of new integrations that needs a new derivative policy.",
                                    "type": "object",
                                    "properties": {
                                      "aws": {
                                        "description": "AWSGroup is an structure that can be used to whitelisting information from AWS integration",
                                        "type": "object",
                                        "properties": {
                                          "labels": {
                                            "type": "object",
                                            "additionalProperties": {
                                              "type": "string"
                                            }
                                          },
                                          "region": {
                                            "type": "string"
                                          },
                                          "securityGroupsIds": {
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          },
                                          "securityGroupsNames": {
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                "toPorts": {
                                  "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is not allowed to initiate connections to destination port 8080/tcp",
                                  "type": "array",
                                  "items": {
                                    "description": "PortDenyRule is a list of ports/protocol that should be used for deny policies. This structure lacks the L7Rules since it's not supported in deny policies.",
                                    "type": "object",
                                    "properties": {
                                      "ports": {
                                        "description": "Ports is a list of L4 port/protocol",
                                        "type": "array",
                                        "items": {
                                          "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                                          "type": "object",
                                          "required": [
                                            "port"
                                          ],
                                          "properties": {
                                            "port": {
                                              "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                              "type": "string",
                                              "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                            },
                                            "protocol": {
                                              "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                              "type": "string",
                                              "enum": [
                                                "TCP",
                                                "UDP",
                                                "SCTP",
                                                "ANY"
                                              ]
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                "toRequires": {
                                  "description": "ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\".",
                                  "type": "array",
                                  "items": {
                                    "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string",
                                              "enum": [
                                                "In",
                                                "NotIn",
                                                "Exists",
                                                "DoesNotExist"
                                              ]
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                          "type": "string",
                                          "maxLength": 63,
                                          "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                        }
                                      }
                                    }
                                  }
                                },
                                "toServices": {
                                  "description": "ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service",
                                  "type": "array",
                                  "items": {
                                    "description": "Service wraps around selectors for services",
                                    "type": "object",
                                    "properties": {
                                      "k8sService": {
                                        "description": "K8sService selects service by name and namespace pair",
                                        "type": "object",
                                        "properties": {
                                          "namespace": {
                                            "type": "string"
                                          },
                                          "serviceName": {
                                            "type": "string"
                                          }
                                        }
                                      },
                                      "k8sServiceSelector": {
                                        "description": "K8sServiceSelector selects services by k8s labels and namespace",
                                        "type": "object",
                                        "required": [
                                          "selector"
                                        ],
                                        "properties": {
                                          "namespace": {
                                            "type": "string"
                                          },
                                          "selector": {
                                            "description": "ServiceSelector is a label selector for k8s services",
                                            "type": "object",
                                            "properties": {
                                              "matchExpressions": {
                                                "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                                "type": "array",
                                                "items": {
                                                  "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                                  "type": "object",
                                                  "required": [
                                                    "key",
                                                    "operator"
                                                  ],
                                                  "properties": {
                                                    "key": {
                                                      "description": "key is the label key that the selector applies to.",
                                                      "type": "string"
                                                    },
                                                    "operator": {
                                                      "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                                      "type": "string",
                                                      "enum": [
                                                        "In",
                                                        "NotIn",
                                                        "Exists",
                                                        "DoesNotExist"
                                                      ]
                                                    },
                                                    "values": {
                                                      "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                                      "type": "array",
                                                      "items": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  }
                                                }
                                              },
                                              "matchLabels": {
                                                "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                                "type": "object",
                                                "additionalProperties": {
                                                  "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                                  "type": "string",
                                                  "maxLength": 63,
                                                  "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          "endpointSelector": {
                            "description": "EndpointSelector selects all endpoints which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive.",
                            "type": "object",
                            "properties": {
                              "matchExpressions": {
                                "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                "type": "array",
                                "items": {
                                  "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                  "type": "object",
                                  "required": [
                                    "key",
                                    "operator"
                                  ],
                                  "properties": {
                                    "key": {
                                      "description": "key is the label key that the selector applies to.",
                                      "type": "string"
                                    },
                                    "operator": {
                                      "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                      "type": "string",
                                      "enum": [
                                        "In",
                                        "NotIn",
                                        "Exists",
                                        "DoesNotExist"
                                      ]
                                    },
                                    "values": {
                                      "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                      "type": "array",
                                      "items": {
                                        "type": "string"
                                      }
                                    }
                                  }
                                }
                              },
                              "matchLabels": {
                                "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                "type": "object",
                                "additionalProperties": {
                                  "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                  "type": "string",
                                  "maxLength": 63,
                                  "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                }
                              }
                            }
                          },
                          "ingress": {
                            "description": "Ingress is a list of IngressRule which are enforced at ingress. If omitted or empty, this rule does not apply at ingress.",
                            "type": "array",
                            "items": {
                              "description": "IngressRule contains all rule types which can be applied at ingress, i.e. network traffic that originates outside of the endpoint and is entering the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members are set, all of them need to match in order for     the rule to take effect. The exception to this rule is FromRequires field;     the effects of any Requires field in any rule will apply to all other     rules as well. \n   - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually     exclusive. Only one of these members may be present within an individual     rule.",
                              "type": "object",
                              "properties": {
                                "authentication": {
                                  "description": "Authentication is the required authentication type for the allowed traffic, if any.",
                                  "type": "object",
                                  "required": [
                                    "mode"
                                  ],
                                  "properties": {
                                    "mode": {
                                      "description": "Mode is the required authentication mode for the allowed traffic, if any.",
                                      "type": "string",
                                      "enum": [
                                        "disabled",
                                        "required",
                                        "test-always-fail"
                                      ]
                                    }
                                  }
                                },
                                "fromCIDR": {
                                  "description": "FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do *not* originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field.  This will match on the source IP address of incoming connections. Adding  a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.3.9.1",
                                  "type": "array",
                                  "items": {
                                    "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                    "type": "string",
                                    "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                  }
                                },
                                "fromCIDRSet": {
                                  "description": "FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.",
                                  "type": "array",
                                  "items": {
                                    "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                                    "type": "object",
                                    "oneOf": [
                                      {
                                        "required": [
                                          "cidr"
                                        ],
                                        "properties": {
                                          "cidr": {}
                                        }
                                      },
                                      {
                                        "required": [
                                          "cidrGroupRef"
                                        ],
                                        "properties": {
                                          "cidrGroupRef": {}
                                        }
                                      }
                                    ],
                                    "properties": {
                                      "cidr": {
                                        "description": "CIDR is a CIDR prefix / IP Block.",
                                        "type": "string",
                                        "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                      },
                                      "cidrGroupRef": {
                                        "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                                        "type": "string",
                                        "maxLength": 253,
                                        "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                                      },
                                      "except": {
                                        "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                                        "type": "array",
                                        "items": {
                                          "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                          "type": "string",
                                          "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                        }
                                      }
                                    }
                                  }
                                },
                                "fromEndpoints": {
                                  "description": "FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\".",
                                  "type": "array",
                                  "items": {
                                    "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string",
                                              "enum": [
                                                "In",
                                                "NotIn",
                                                "Exists",
                                                "DoesNotExist"
                                              ]
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                          "type": "string",
                                          "maxLength": 63,
                                          "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                        }
                                      }
                                    }
                                  }
                                },
                                "fromEntities": {
                                  "description": "FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are `world`, `cluster` and `host`",
                                  "type": "array",
                                  "items": {
                                    "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                                    "type": "string",
                                    "enum": [
                                      "all",
                                      "world",
                                      "cluster",
                                      "host",
                                      "init",
                                      "ingress",
                                      "unmanaged",
                                      "remote-node",
                                      "health",
                                      "none",
                                      "kube-apiserver"
                                    ]
                                  }
                                },
                                "fromRequires": {
                                  "description": "FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\".",
                                  "type": "array",
                                  "items": {
                                    "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string",
                                              "enum": [
                                                "In",
                                                "NotIn",
                                                "Exists",
                                                "DoesNotExist"
                                              ]
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                          "type": "string",
                                          "maxLength": 63,
                                          "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                        }
                                      }
                                    }
                                  }
                                },
                                "icmps": {
                                  "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming type 8 ICMP connections.",
                                  "type": "array",
                                  "items": {
                                    "description": "ICMPRule is a list of ICMP fields.",
                                    "type": "object",
                                    "properties": {
                                      "fields": {
                                        "description": "Fields is a list of ICMP fields.",
                                        "type": "array",
                                        "items": {
                                          "description": "ICMPField is a ICMP field.",
                                          "type": "object",
                                          "required": [
                                            "type"
                                          ],
                                          "properties": {
                                            "family": {
                                              "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                              "type": "string",
                                              "default": "IPv4",
                                              "enum": [
                                                "IPv4",
                                                "IPv6"
                                              ]
                                            },
                                            "type": {
                                              "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                              "type": "integer",
                                              "maximum": 255,
                                              "minimum": 0
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                "toPorts": {
                                  "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming connections on port 80/tcp.",
                                  "type": "array",
                                  "items": {
                                    "description": "PortRule is a list of ports/protocol combinations with optional Layer 7 rules which must be met.",
                                    "type": "object",
                                    "properties": {
                                      "listener": {
                                        "description": "listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.",
                                        "type": "object",
                                        "required": [
                                          "envoyConfig",
                                          "name"
                                        ],
                                        "properties": {
                                          "envoyConfig": {
                                            "description": "EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.",
                                            "type": "object",
                                            "required": [
                                              "name"
                                            ],
                                            "properties": {
                                              "kind": {
                                                "description": "Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.",
                                                "type": "string",
                                                "enum": [
                                                  "CiliumEnvoyConfig",
                                                  "CiliumClusterwideEnvoyConfig"
                                                ]
                                              },
                                              "name": {
                                                "description": "Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where the listener is defined in.",
                                                "type": "string",
                                                "minLength": 1
                                              }
                                            }
                                          },
                                          "name": {
                                            "description": "Name is the name of the listener.",
                                            "type": "string",
                                            "minLength": 1
                                          }
                                        }
                                      },
                                      "originatingTLS": {
                                        "description": "OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.",
                                        "type": "object",
                                        "required": [
                                          "secret"
                                        ],
                                        "properties": {
                                          "certificate": {
                                            "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                            "type": "string"
                                          },
                                          "privateKey": {
                                            "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                            "type": "string"
                                          },
                                          "secret": {
                                            "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                            "type": "object",
                                            "required": [
                                              "name"
                                            ],
                                            "properties": {
                                              "name": {
                                                "description": "Name is the name of the secret.",
                                                "type": "string"
                                              },
                                              "namespace": {
                                                "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                                "type": "string"
                                              }
                                            }
                                          },
                                          "trustedCA": {
                                            "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                            "type": "string"
                                          }
                                        }
                                      },
                                      "ports": {
                                        "description": "Ports is a list of L4 port/protocol",
                                        "type": "array",
                                        "items": {
                                          "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                                          "type": "object",
                                          "required": [
                                            "port"
                                          ],
                                          "properties": {
                                            "port": {
                                              "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                              "type": "string",
                                              "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                            },
                                            "protocol": {
                                              "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                              "type": "string",
                                              "enum": [
                                                "TCP",
                                                "UDP",
                                                "SCTP",
                                                "ANY"
                                              ]
                                            }
                                          }
                                        }
                                      },
                                      "rules": {
                                        "description": "Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.",
                                        "type": "object",
                                        "properties": {
                                          "dns": {
                                            "description": "DNS-specific rules.",
                                            "type": "array",
                                            "items": {
                                              "description": "PortRuleDNS is a list of allowed DNS lookups.",
                                              "type": "object",
                                              "properties": {
                                                "matchName": {
                                                  "description": "MatchName matches literal DNS names. A trailing \".\" is automatically added when missing.",
                                                  "type": "string",
                                                  "pattern": "^([-a-zA-Z0-9_]+[.]?)+$"
                                                },
                                                "matchPattern": {
                                                  "description": "MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"*\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"*\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: `*.cilium.io` matches subomains of cilium at that level   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with \"cilium.io\"   except those containing \".\" separator, subcilium.io and sub-cilium.io match,   www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\"   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,   blog.cilium.io, cilium.io and google.com do not",
                                                  "type": "string",
                                                  "pattern": "^([-a-zA-Z0-9_*]+[.]?)+$"
                                                }
                                              }
                                            }
                                          },
                                          "http": {
                                            "description": "HTTP specific rules.",
                                            "type": "array",
                                            "items": {
                                              "description": "PortRuleHTTP is a list of HTTP protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect. \n All fields of this type are extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986.",
                                              "type": "object",
                                              "properties": {
                                                "headerMatches": {
                                                  "description": "HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match.",
                                                  "type": "array",
                                                  "items": {
                                                    "description": "HeaderMatch extends the HeaderValue for matching requirement of a named header field against an immediate string, a secret value, or a regex.  If none of the optional fields is present, then the header value is not matched, only presence of the header is enough.",
                                                    "type": "object",
                                                    "required": [
                                                      "name"
                                                    ],
                                                    "properties": {
                                                      "mismatch": {
                                                        "description": "Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.",
                                                        "type": "string",
                                                        "enum": [
                                                          "LOG",
                                                          "ADD",
                                                          "DELETE",
                                                          "REPLACE"
                                                        ]
                                                      },
                                                      "name": {
                                                        "description": "Name identifies the header.",
                                                        "type": "string"
                                                      },
                                                      "secret": {
                                                        "description": "Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no \"Value\" specified, the match will fail.",
                                                        "type": "object",
                                                        "required": [
                                                          "name"
                                                        ],
                                                        "properties": {
                                                          "name": {
                                                            "description": "Name is the name of the secret.",
                                                            "type": "string"
                                                          },
                                                          "namespace": {
                                                            "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                                            "type": "string"
                                                          }
                                                        }
                                                      },
                                                      "value": {
                                                        "description": "Value matches the exact value of the header. Can be specified either alone or together with \"Secret\"; will be used as the header value if the secret can not be found in the latter case.",
                                                        "type": "string"
                                                      }
                                                    }
                                                  }
                                                },
                                                "headers": {
                                                  "description": "Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present.",
                                                  "type": "array",
                                                  "items": {
                                                    "type": "string"
                                                  }
                                                },
                                                "host": {
                                                  "description": "Host is an extended POSIX regex matched against the host header of a request, e.g. \"foo.com\" \n If omitted or empty, the value of the host header is ignored.",
                                                  "type": "string",
                                                  "format": "idn-hostname"
                                                },
                                                "method": {
                                                  "description": "Method is an extended POSIX regex matched against the method of a request, e.g. \"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\", ... \n If omitted or empty, all methods are allowed.",
                                                  "type": "string"
                                                },
                                                "path": {
                                                  "description": "Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986. \n If omitted or empty, all paths are all allowed.",
                                                  "type": "string"
                                                }
                                              }
                                            }
                                          },
                                          "kafka": {
                                            "description": "Kafka-specific rules.",
                                            "type": "array",
                                            "items": {
                                              "description": "PortRule is a list of Kafka protocol constraints. All fields are optional, if all fields are empty or missing, the rule will match all Kafka messages.",
                                              "type": "object",
                                              "properties": {
                                                "apiKey": {
                                                  "description": "APIKey is a case-insensitive string matched against the key of a request, e.g. \"produce\", \"fetch\", \"createtopic\", \"deletetopic\", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys \n If omitted or empty, and if Role is not specified, then all keys are allowed.",
                                                  "type": "string"
                                                },
                                                "apiVersion": {
                                                  "description": "APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer. \n If omitted or empty, all versions are allowed.",
                                                  "type": "string"
                                                },
                                                "clientID": {
                                                  "description": "ClientID is the client identifier as provided in the request. \n From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client. \n If omitted or empty, all client identifiers are allowed.",
                                                  "type": "string"
                                                },
                                                "role": {
                                                  "description": "Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as \"produce\" or \"consume\". A Role automatically expands into all APIKeys required to perform the specified higher-level operation. \n The following values are supported:  - \"produce\": Allow producing to the topics specified in the rule  - \"consume\": Allow consuming from the topics specified in the rule \n This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule. \n If omitted or empty, and if APIKey is not specified, then all keys are allowed.",
                                                  "type": "string",
                                                  "enum": [
                                                    "produce",
                                                    "consume"
                                                  ]
                                                },
                                                "topic": {
                                                  "description": "Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected. \n This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _. \n Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255. \n If omitted or empty, all topics are allowed.",
                                                  "type": "string",
                                                  "maxLength": 255
                                                }
                                              }
                                            }
                                          },
                                          "l7": {
                                            "description": "Key-value pair rules.",
                                            "type": "array",
                                            "items": {
                                              "description": "PortRuleL7 is a list of key-value pairs interpreted by a L7 protocol as protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect.",
                                              "type": "object",
                                              "additionalProperties": {
                                                "type": "string"
                                              }
                                            }
                                          },
                                          "l7proto": {
                                            "description": "Name of the L7 protocol for which the Key-value pair rules apply.",
                                            "type": "string"
                                          }
                                        }
                                      },
                                      "serverNames": {
                                        "description": "ServerNames is a list of allowed TLS SNI values. If not empty, then TLS must be present and one of the provided SNIs must be indicated in the TLS handshake.",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        }
                                      },
                                      "terminatingTLS": {
                                        "description": "TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.",
                                        "type": "object",
                                        "required": [
                                          "secret"
                                        ],
                                        "properties": {
                                          "certificate": {
                                            "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                            "type": "string"
                                          },
                                          "privateKey": {
                                            "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                            "type": "string"
                                          },
                                          "secret": {
                                            "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                            "type": "object",
                                            "required": [
                                              "name"
                                            ],
                                            "properties": {
                                              "name": {
                                                "description": "Name is the name of the secret.",
                                                "type": "string"
                                              },
                                              "namespace": {
                                                "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                                "type": "string"
                                              }
                                            }
                                          },
                                          "trustedCA": {
                                            "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          "ingressDeny": {
                            "description": "IngressDeny is a list of IngressDenyRule which are enforced at ingress. Any rule inserted here will be denied regardless of the allowed ingress rules in the 'ingress' field. If omitted or empty, this rule does not apply at ingress.",
                            "type": "array",
                            "items": {
                              "description": "IngressDenyRule contains all rule types which can be applied at ingress, i.e. network traffic that originates outside of the endpoint and is entering the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members are set, all of them need to match in order for     the rule to take effect. The exception to this rule is FromRequires field;     the effects of any Requires field in any rule will apply to all other     rules as well. \n   - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually     exclusive. Only one of these members may be present within an individual     rule.",
                              "type": "object",
                              "properties": {
                                "fromCIDR": {
                                  "description": "FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do *not* originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field.  This will match on the source IP address of incoming connections. Adding  a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.3.9.1",
                                  "type": "array",
                                  "items": {
                                    "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                    "type": "string",
                                    "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                  }
                                },
                                "fromCIDRSet": {
                                  "description": "FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.",
                                  "type": "array",
                                  "items": {
                                    "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                                    "type": "object",
                                    "oneOf": [
                                      {
                                        "required": [
                                          "cidr"
                                        ],
                                        "properties": {
                                          "cidr": {}
                                        }
                                      },
                                      {
                                        "required": [
                                          "cidrGroupRef"
                                        ],
                                        "properties": {
                                          "cidrGroupRef": {}
                                        }
                                      }
                                    ],
                                    "properties": {
                                      "cidr": {
                                        "description": "CIDR is a CIDR prefix / IP Block.",
                                        "type": "string",
                                        "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                      },
                                      "cidrGroupRef": {
                                        "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                                        "type": "string",
                                        "maxLength": 253,
                                        "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                                      },
                                      "except": {
                                        "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                                        "type": "array",
                                        "items": {
                                          "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                          "type": "string",
                                          "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                        }
                                      }
                                    }
                                  }
                                },
                                "fromEndpoints": {
                                  "description": "FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\".",
                                  "type": "array",
                                  "items": {
                                    "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string",
                                              "enum": [
                                                "In",
                                                "NotIn",
                                                "Exists",
                                                "DoesNotExist"
                                              ]
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                          "type": "string",
                                          "maxLength": 63,
                                          "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                        }
                                      }
                                    }
                                  }
                                },
                                "fromEntities": {
                                  "description": "FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are `world`, `cluster` and `host`",
                                  "type": "array",
                                  "items": {
                                    "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                                    "type": "string",
                                    "enum": [
                                      "all",
                                      "world",
                                      "cluster",
                                      "host",
                                      "init",
                                      "ingress",
                                      "unmanaged",
                                      "remote-node",
                                      "health",
                                      "none",
                                      "kube-apiserver"
                                    ]
                                  }
                                },
                                "fromRequires": {
                                  "description": "FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\".",
                                  "type": "array",
                                  "items": {
                                    "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string",
                                              "enum": [
                                                "In",
                                                "NotIn",
                                                "Exists",
                                                "DoesNotExist"
                                              ]
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                          "type": "string",
                                          "maxLength": 63,
                                          "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                        }
                                      }
                                    }
                                  }
                                },
                                "icmps": {
                                  "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming type 8 ICMP connections.",
                                  "type": "array",
                                  "items": {
                                    "description": "ICMPRule is a list of ICMP fields.",
                                    "type": "object",
                                    "properties": {
                                      "fields": {
                                        "description": "Fields is a list of ICMP fields.",
                                        "type": "array",
                                        "items": {
                                          "description": "ICMPField is a ICMP field.",
                                          "type": "object",
                                          "required": [
                                            "type"
                                          ],
                                          "properties": {
                                            "family": {
                                              "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                              "type": "string",
                                              "default": "IPv4",
                                              "enum": [
                                                "IPv4",
                                                "IPv6"
                                              ]
                                            },
                                            "type": {
                                              "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                              "type": "integer",
                                              "maximum": 255,
                                              "minimum": 0
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                "toPorts": {
                                  "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming connections on port 80/tcp.",
                                  "type": "array",
                                  "items": {
                                    "description": "PortDenyRule is a list of ports/protocol that should be used for deny policies. This structure lacks the L7Rules since it's not supported in deny policies.",
                                    "type": "object",
                                    "properties": {
                                      "ports": {
                                        "description": "Ports is a list of L4 port/protocol",
                                        "type": "array",
                                        "items": {
                                          "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                                          "type": "object",
                                          "required": [
                                            "port"
                                          ],
                                          "properties": {
                                            "port": {
                                              "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                              "type": "string",
                                              "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                            },
                                            "protocol": {
                                              "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                              "type": "string",
                                              "enum": [
                                                "TCP",
                                                "UDP",
                                                "SCTP",
                                                "ANY"
                                              ]
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          "labels": {
                            "description": "Labels is a list of optional strings which can be used to re-identify the rule or to store metadata. It is possible to lookup or delete strings based on labels. Labels are not required to be unique, multiple rules can have overlapping or identical labels.",
                            "type": "array",
                            "items": {
                              "description": "Label is the Cilium's representation of a container label.",
                              "type": "object",
                              "required": [
                                "key"
                              ],
                              "properties": {
                                "key": {
                                  "type": "string"
                                },
                                "source": {
                                  "description": "Source can be one of the above values (e.g.: LabelSourceContainer).",
                                  "type": "string"
                                },
                                "value": {
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "nodeSelector": {
                            "description": "NodeSelector selects all nodes which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive. Can only be used in CiliumClusterwideNetworkPolicies.",
                            "type": "object",
                            "properties": {
                              "matchExpressions": {
                                "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                "type": "array",
                                "items": {
                                  "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                  "type": "object",
                                  "required": [
                                    "key",
                                    "operator"
                                  ],
                                  "properties": {
                                    "key": {
                                      "description": "key is the label key that the selector applies to.",
                                      "type": "string"
                                    },
                                    "operator": {
                                      "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                      "type": "string",
                                      "enum": [
                                        "In",
                                        "NotIn",
                                        "Exists",
                                        "DoesNotExist"
                                      ]
                                    },
                                    "values": {
                                      "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                      "type": "array",
                                      "items": {
                                        "type": "string"
                                      }
                                    }
                                  }
                                }
                              },
                              "matchLabels": {
                                "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                "type": "object",
                                "additionalProperties": {
                                  "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                  "type": "string",
                                  "maxLength": 63,
                                  "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "status": {
                      "description": "Status is the status of the Cilium policy rule. \n The reason this field exists in this structure is due a bug in the k8s code-generator that doesn't create a `UpdateStatus` method because the field does not exist in the structure.",
                      "type": "object",
                      "properties": {
                        "derivativePolicies": {
                          "description": "DerivativePolicies is the status of all policies derived from the Cilium policy",
                          "type": "object",
                          "additionalProperties": {
                            "description": "CiliumNetworkPolicyNodeStatus is the status of a Cilium policy rule for a specific node.",
                            "type": "object",
                            "properties": {
                              "annotations": {
                                "description": "Annotations corresponds to the Annotations in the ObjectMeta of the CNP that have been realized on the node for CNP. That is, if a CNP has been imported and has been assigned annotation X=Y by the user, Annotations in CiliumNetworkPolicyNodeStatus will be X=Y once the CNP that was imported corresponding to Annotation X=Y has been realized on the node.",
                                "type": "object",
                                "additionalProperties": {
                                  "type": "string"
                                }
                              },
                              "enforcing": {
                                "description": "Enforcing is set to true once all endpoints present at the time the policy has been imported are enforcing this policy.",
                                "type": "boolean"
                              },
                              "error": {
                                "description": "Error describes any error that occurred when parsing or importing the policy, or realizing the policy for the endpoints to which it applies on the node.",
                                "type": "string"
                              },
                              "lastUpdated": {
                                "description": "LastUpdated contains the last time this status was updated",
                                "type": "string",
                                "format": "date-time"
                              },
                              "localPolicyRevision": {
                                "description": "Revision is the policy revision of the repository which first implemented this policy.",
                                "type": "integer",
                                "format": "int64"
                              },
                              "ok": {
                                "description": "OK is true when the policy has been parsed and imported successfully into the in-memory policy repository on the node.",
                                "type": "boolean"
                              }
                            }
                          }
                        },
                        "nodes": {
                          "description": "Nodes is the Cilium policy status for each node",
                          "type": "object",
                          "additionalProperties": {
                            "description": "CiliumNetworkPolicyNodeStatus is the status of a Cilium policy rule for a specific node.",
                            "type": "object",
                            "properties": {
                              "annotations": {
                                "description": "Annotations corresponds to the Annotations in the ObjectMeta of the CNP that have been realized on the node for CNP. That is, if a CNP has been imported and has been assigned annotation X=Y by the user, Annotations in CiliumNetworkPolicyNodeStatus will be X=Y once the CNP that was imported corresponding to Annotation X=Y has been realized on the node.",
                                "type": "object",
                                "additionalProperties": {
                                  "type": "string"
                                }
                              },
                              "enforcing": {
                                "description": "Enforcing is set to true once all endpoints present at the time the policy has been imported are enforcing this policy.",
                                "type": "boolean"
                              },
                              "error": {
                                "description": "Error describes any error that occurred when parsing or importing the policy, or realizing the policy for the endpoints to which it applies on the node.",
                                "type": "string"
                              },
                              "lastUpdated": {
                                "description": "LastUpdated contains the last time this status was updated",
                                "type": "string",
                                "format": "date-time"
                              },
                              "localPolicyRevision": {
                                "description": "Revision is the policy revision of the repository which first implemented this policy.",
                                "type": "integer",
                                "format": "int64"
                              },
                              "ok": {
                                "description": "OK is true when the policy has been parsed and imported successfully into the in-memory policy repository on the node.",
                                "type": "boolean"
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              },
              "subresources": {
                "status": {}
              }
            }
          ],
          "conversion": {
            "strategy": "None"
          }
        },
        "status": {
          "conditions": [
            {
              "type": "NamesAccepted",
              "status": "True",
              "lastTransitionTime": "2023-11-21T10:47:05Z",
              "reason": "NoConflicts",
              "message": "no conflicts found"
            },
            {
              "type": "Established",
              "status": "True",
              "lastTransitionTime": "2023-11-21T10:47:05Z",
              "reason": "InitialNamesAccepted",
              "message": "the initial names have been accepted"
            }
          ],
          "acceptedNames": {
            "plural": "ciliumclusterwidenetworkpolicies",
            "singular": "ciliumclusterwidenetworkpolicy",
            "shortNames": [
              "ccnp"
            ],
            "kind": "CiliumClusterwideNetworkPolicy",
            "listKind": "CiliumClusterwideNetworkPolicyList"
          },
          "storedVersions": [
            "v2"
          ]
        }
      },
      "short": "CiliumClusterwideNetworkPolicy",
      "apiGroup": "cilium.io",
      "apiKind": "CiliumClusterwideNetworkPolicy",
      "apiVersion": "v2",
      "readProperties": {
        "spec": "spec",
        "specs": "specs",
        "status": "status"
      },
      "writeProperties": {
        "spec": "spec",
        "specs": "specs"
      },
      "group": "cilium",
      "sub": "cilium",
      "listExcludes": [],
      "readExcludes": [],
      "simpleExcludes": [],
      "gqlDefs": {
        "metadata": "metadata!",
        "spec": "JSONObject",
        "specs": "[JSONObject]",
        "status": "JSONObject"
      },
      "namespaced": false
    },
    {
      "alternatives": [],
      "name": "io.cilium.v2.CiliumEndpoint",
      "definition": {
        "description": "CiliumEndpoint is the status of a Cilium policy rule.",
        "type": "object",
        "required": [
          "metadata"
        ],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "status": {
            "description": "EndpointStatus is the status of a Cilium endpoint.",
            "type": "object",
            "properties": {
              "controllers": {
                "description": "Controllers is the list of failing controllers for this endpoint.",
                "type": "array",
                "items": {
                  "description": "ControllerStatus is the status of a failing controller.",
                  "type": "object",
                  "properties": {
                    "configuration": {
                      "description": "Configuration is the controller configuration",
                      "type": "object",
                      "properties": {
                        "error-retry": {
                          "description": "Retry on error",
                          "type": "boolean"
                        },
                        "error-retry-base": {
                          "description": "Base error retry back-off time Format: duration",
                          "type": "integer",
                          "format": "int64"
                        },
                        "interval": {
                          "description": "Regular synchronization interval Format: duration",
                          "type": "integer",
                          "format": "int64"
                        }
                      }
                    },
                    "name": {
                      "description": "Name is the name of the controller",
                      "type": "string"
                    },
                    "status": {
                      "description": "Status is the status of the controller",
                      "type": "object",
                      "properties": {
                        "consecutive-failure-count": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "failure-count": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "last-failure-msg": {
                          "type": "string"
                        },
                        "last-failure-timestamp": {
                          "type": "string"
                        },
                        "last-success-timestamp": {
                          "type": "string"
                        },
                        "success-count": {
                          "type": "integer",
                          "format": "int64"
                        }
                      }
                    },
                    "uuid": {
                      "description": "UUID is the UUID of the controller",
                      "type": "string"
                    }
                  }
                }
              },
              "encryption": {
                "description": "Encryption is the encryption configuration of the node",
                "type": "object",
                "properties": {
                  "key": {
                    "description": "Key is the index to the key to use for encryption or 0 if encryption is disabled.",
                    "type": "integer"
                  }
                }
              },
              "external-identifiers": {
                "description": "ExternalIdentifiers is a set of identifiers to identify the endpoint apart from the pod name. This includes container runtime IDs.",
                "type": "object",
                "properties": {
                  "container-id": {
                    "description": "ID assigned by container runtime",
                    "type": "string"
                  },
                  "container-name": {
                    "description": "Name assigned to container",
                    "type": "string"
                  },
                  "docker-endpoint-id": {
                    "description": "Docker endpoint ID",
                    "type": "string"
                  },
                  "docker-network-id": {
                    "description": "Docker network ID",
                    "type": "string"
                  },
                  "k8s-namespace": {
                    "description": "K8s namespace for this endpoint",
                    "type": "string"
                  },
                  "k8s-pod-name": {
                    "description": "K8s pod name for this endpoint",
                    "type": "string"
                  },
                  "pod-name": {
                    "description": "K8s pod for this endpoint(Deprecated, use K8sPodName and K8sNamespace instead)",
                    "type": "string"
                  }
                }
              },
              "health": {
                "description": "Health is the overall endpoint & subcomponent health.",
                "type": "object",
                "properties": {
                  "bpf": {
                    "description": "bpf",
                    "type": "string"
                  },
                  "connected": {
                    "description": "Is this endpoint reachable",
                    "type": "boolean"
                  },
                  "overallHealth": {
                    "description": "overall health",
                    "type": "string"
                  },
                  "policy": {
                    "description": "policy",
                    "type": "string"
                  }
                }
              },
              "id": {
                "description": "ID is the cilium-agent-local ID of the endpoint.",
                "type": "integer",
                "format": "int64"
              },
              "identity": {
                "description": "Identity is the security identity associated with the endpoint",
                "type": "object",
                "properties": {
                  "id": {
                    "description": "ID is the numeric identity of the endpoint",
                    "type": "integer",
                    "format": "int64"
                  },
                  "labels": {
                    "description": "Labels is the list of labels associated with the identity",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              },
              "log": {
                "description": "Log is the list of the last few warning and error log entries",
                "type": "array",
                "items": {
                  "description": "EndpointStatusChange Indication of a change of status \n swagger:model EndpointStatusChange",
                  "type": "object",
                  "properties": {
                    "code": {
                      "description": "Code indicate type of status change Enum: [ok failed]",
                      "type": "string"
                    },
                    "message": {
                      "description": "Status message",
                      "type": "string"
                    },
                    "state": {
                      "description": "state",
                      "type": "string"
                    },
                    "timestamp": {
                      "description": "Timestamp when status change occurred",
                      "type": "string"
                    }
                  }
                }
              },
              "named-ports": {
                "description": "NamedPorts List of named Layer 4 port and protocol pairs which will be used in Network Policy specs. \n swagger:model NamedPorts",
                "type": "array",
                "items": {
                  "description": "Port Layer 4 port / protocol pair \n swagger:model Port",
                  "type": "object",
                  "properties": {
                    "name": {
                      "description": "Optional layer 4 port name",
                      "type": "string"
                    },
                    "port": {
                      "description": "Layer 4 port number",
                      "type": "integer"
                    },
                    "protocol": {
                      "description": "Layer 4 protocol Enum: [TCP UDP SCTP ICMP ICMPV6 ANY]",
                      "type": "string"
                    }
                  }
                }
              },
              "networking": {
                "description": "Networking is the networking properties of the endpoint.",
                "type": "object",
                "required": [
                  "addressing"
                ],
                "properties": {
                  "addressing": {
                    "description": "IP4/6 addresses assigned to this Endpoint",
                    "type": "array",
                    "items": {
                      "description": "AddressPair is a pair of IPv4 and/or IPv6 address.",
                      "type": "object",
                      "properties": {
                        "ipv4": {
                          "type": "string"
                        },
                        "ipv6": {
                          "type": "string"
                        }
                      }
                    }
                  },
                  "node": {
                    "description": "NodeIP is the IP of the node the endpoint is running on. The IP must be reachable between nodes.",
                    "type": "string"
                  }
                }
              },
              "policy": {
                "description": "EndpointPolicy represents the endpoint's policy by listing all allowed ingress and egress identities in combination with L4 port and protocol.",
                "type": "object",
                "properties": {
                  "egress": {
                    "description": "EndpointPolicyDirection is the list of allowed identities per direction.",
                    "type": "object",
                    "required": [
                      "enforcing"
                    ],
                    "properties": {
                      "adding": {
                        "description": "Deprecated",
                        "type": "array",
                        "items": {
                          "description": "IdentityTuple specifies a peer by identity, destination port and protocol.",
                          "type": "object",
                          "properties": {
                            "dest-port": {
                              "type": "integer"
                            },
                            "identity": {
                              "type": "integer",
                              "format": "int64"
                            },
                            "identity-labels": {
                              "type": "object",
                              "additionalProperties": {
                                "type": "string"
                              }
                            },
                            "protocol": {
                              "type": "integer"
                            }
                          }
                        }
                      },
                      "allowed": {
                        "description": "AllowedIdentityList is a list of IdentityTuples that species peers that are allowed.",
                        "type": "array",
                        "items": {
                          "description": "IdentityTuple specifies a peer by identity, destination port and protocol.",
                          "type": "object",
                          "properties": {
                            "dest-port": {
                              "type": "integer"
                            },
                            "identity": {
                              "type": "integer",
                              "format": "int64"
                            },
                            "identity-labels": {
                              "type": "object",
                              "additionalProperties": {
                                "type": "string"
                              }
                            },
                            "protocol": {
                              "type": "integer"
                            }
                          }
                        }
                      },
                      "denied": {
                        "description": "DenyIdentityList is a list of IdentityTuples that species peers that are denied.",
                        "type": "array",
                        "items": {
                          "description": "IdentityTuple specifies a peer by identity, destination port and protocol.",
                          "type": "object",
                          "properties": {
                            "dest-port": {
                              "type": "integer"
                            },
                            "identity": {
                              "type": "integer",
                              "format": "int64"
                            },
                            "identity-labels": {
                              "type": "object",
                              "additionalProperties": {
                                "type": "string"
                              }
                            },
                            "protocol": {
                              "type": "integer"
                            }
                          }
                        }
                      },
                      "enforcing": {
                        "type": "boolean"
                      },
                      "removing": {
                        "description": "Deprecated",
                        "type": "array",
                        "items": {
                          "description": "IdentityTuple specifies a peer by identity, destination port and protocol.",
                          "type": "object",
                          "properties": {
                            "dest-port": {
                              "type": "integer"
                            },
                            "identity": {
                              "type": "integer",
                              "format": "int64"
                            },
                            "identity-labels": {
                              "type": "object",
                              "additionalProperties": {
                                "type": "string"
                              }
                            },
                            "protocol": {
                              "type": "integer"
                            }
                          }
                        }
                      },
                      "state": {
                        "description": "EndpointPolicyState defines the state of the Policy mode: \"enforcing\", \"non-enforcing\", \"disabled\"",
                        "type": "string"
                      }
                    }
                  },
                  "ingress": {
                    "description": "EndpointPolicyDirection is the list of allowed identities per direction.",
                    "type": "object",
                    "required": [
                      "enforcing"
                    ],
                    "properties": {
                      "adding": {
                        "description": "Deprecated",
                        "type": "array",
                        "items": {
                          "description": "IdentityTuple specifies a peer by identity, destination port and protocol.",
                          "type": "object",
                          "properties": {
                            "dest-port": {
                              "type": "integer"
                            },
                            "identity": {
                              "type": "integer",
                              "format": "int64"
                            },
                            "identity-labels": {
                              "type": "object",
                              "additionalProperties": {
                                "type": "string"
                              }
                            },
                            "protocol": {
                              "type": "integer"
                            }
                          }
                        }
                      },
                      "allowed": {
                        "description": "AllowedIdentityList is a list of IdentityTuples that species peers that are allowed.",
                        "type": "array",
                        "items": {
                          "description": "IdentityTuple specifies a peer by identity, destination port and protocol.",
                          "type": "object",
                          "properties": {
                            "dest-port": {
                              "type": "integer"
                            },
                            "identity": {
                              "type": "integer",
                              "format": "int64"
                            },
                            "identity-labels": {
                              "type": "object",
                              "additionalProperties": {
                                "type": "string"
                              }
                            },
                            "protocol": {
                              "type": "integer"
                            }
                          }
                        }
                      },
                      "denied": {
                        "description": "DenyIdentityList is a list of IdentityTuples that species peers that are denied.",
                        "type": "array",
                        "items": {
                          "description": "IdentityTuple specifies a peer by identity, destination port and protocol.",
                          "type": "object",
                          "properties": {
                            "dest-port": {
                              "type": "integer"
                            },
                            "identity": {
                              "type": "integer",
                              "format": "int64"
                            },
                            "identity-labels": {
                              "type": "object",
                              "additionalProperties": {
                                "type": "string"
                              }
                            },
                            "protocol": {
                              "type": "integer"
                            }
                          }
                        }
                      },
                      "enforcing": {
                        "type": "boolean"
                      },
                      "removing": {
                        "description": "Deprecated",
                        "type": "array",
                        "items": {
                          "description": "IdentityTuple specifies a peer by identity, destination port and protocol.",
                          "type": "object",
                          "properties": {
                            "dest-port": {
                              "type": "integer"
                            },
                            "identity": {
                              "type": "integer",
                              "format": "int64"
                            },
                            "identity-labels": {
                              "type": "object",
                              "additionalProperties": {
                                "type": "string"
                              }
                            },
                            "protocol": {
                              "type": "integer"
                            }
                          }
                        }
                      },
                      "state": {
                        "description": "EndpointPolicyState defines the state of the Policy mode: \"enforcing\", \"non-enforcing\", \"disabled\"",
                        "type": "string"
                      }
                    }
                  }
                }
              },
              "state": {
                "description": "State is the state of the endpoint.",
                "type": "string",
                "enum": [
                  "creating",
                  "waiting-for-identity",
                  "not-ready",
                  "waiting-to-regenerate",
                  "regenerating",
                  "restoring",
                  "ready",
                  "disconnecting",
                  "disconnected",
                  "invalid"
                ]
              },
              "visibility-policy-status": {
                "type": "string"
              }
            }
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "cilium.io",
            "kind": "CiliumEndpoint",
            "version": "v2"
          }
        ]
      },
      "crd": {
        "metadata": {
          "name": "ciliumendpoints.cilium.io",
          "uid": "d5f73d60-13a4-42c1-a5c5-d457a32c68ce",
          "resourceVersion": "25877237966",
          "generation": 1,
          "creationTimestamp": "2023-11-21T10:47:04Z",
          "labels": {
            "io.cilium.k8s.crd.schema.version": "1.26.11"
          },
          "managedFields": [
            {
              "manager": "cilium-operator-generic",
              "operation": "Update",
              "apiVersion": "apiextensions.k8s.io/v1",
              "time": "2023-11-21T10:47:04Z",
              "fieldsType": "FieldsV1",
              "fieldsV1": {
                "f:metadata": {
                  "f:labels": {
                    ".": {},
                    "f:io.cilium.k8s.crd.schema.version": {}
                  }
                },
                "f:spec": {
                  "f:conversion": {
                    ".": {},
                    "f:strategy": {}
                  },
                  "f:group": {},
                  "f:names": {
                    "f:kind": {},
                    "f:listKind": {},
                    "f:plural": {},
                    "f:shortNames": {},
                    "f:singular": {}
                  },
                  "f:scope": {},
                  "f:versions": {}
                }
              }
            },
            {
              "manager": "kube-apiserver",
              "operation": "Update",
              "apiVersion": "apiextensions.k8s.io/v1",
              "time": "2023-11-21T10:47:04Z",
              "fieldsType": "FieldsV1",
              "fieldsV1": {
                "f:status": {
                  "f:acceptedNames": {
                    "f:kind": {},
                    "f:listKind": {},
                    "f:plural": {},
                    "f:shortNames": {},
                    "f:singular": {}
                  },
                  "f:conditions": {
                    "k:{\"type\":\"Established\"}": {
                      ".": {},
                      "f:lastTransitionTime": {},
                      "f:message": {},
                      "f:reason": {},
                      "f:status": {},
                      "f:type": {}
                    },
                    "k:{\"type\":\"NamesAccepted\"}": {
                      ".": {},
                      "f:lastTransitionTime": {},
                      "f:message": {},
                      "f:reason": {},
                      "f:status": {},
                      "f:type": {}
                    }
                  }
                }
              },
              "subresource": "status"
            }
          ]
        },
        "spec": {
          "group": "cilium.io",
          "names": {
            "plural": "ciliumendpoints",
            "singular": "ciliumendpoint",
            "shortNames": [
              "cep",
              "ciliumep"
            ],
            "kind": "CiliumEndpoint",
            "listKind": "CiliumEndpointList"
          },
          "scope": "Namespaced",
          "versions": [
            {
              "name": "v2",
              "served": true,
              "storage": true,
              "schema": {
                "openAPIV3Schema": {
                  "description": "CiliumEndpoint is the status of a Cilium policy rule.",
                  "type": "object",
                  "required": [
                    "metadata"
                  ],
                  "properties": {
                    "apiVersion": {
                      "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                      "type": "string"
                    },
                    "kind": {
                      "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                      "type": "string"
                    },
                    "metadata": {
                      "type": "object"
                    },
                    "status": {
                      "description": "EndpointStatus is the status of a Cilium endpoint.",
                      "type": "object",
                      "properties": {
                        "controllers": {
                          "description": "Controllers is the list of failing controllers for this endpoint.",
                          "type": "array",
                          "items": {
                            "description": "ControllerStatus is the status of a failing controller.",
                            "type": "object",
                            "properties": {
                              "configuration": {
                                "description": "Configuration is the controller configuration",
                                "type": "object",
                                "properties": {
                                  "error-retry": {
                                    "description": "Retry on error",
                                    "type": "boolean"
                                  },
                                  "error-retry-base": {
                                    "description": "Base error retry back-off time Format: duration",
                                    "type": "integer",
                                    "format": "int64"
                                  },
                                  "interval": {
                                    "description": "Regular synchronization interval Format: duration",
                                    "type": "integer",
                                    "format": "int64"
                                  }
                                }
                              },
                              "name": {
                                "description": "Name is the name of the controller",
                                "type": "string"
                              },
                              "status": {
                                "description": "Status is the status of the controller",
                                "type": "object",
                                "properties": {
                                  "consecutive-failure-count": {
                                    "type": "integer",
                                    "format": "int64"
                                  },
                                  "failure-count": {
                                    "type": "integer",
                                    "format": "int64"
                                  },
                                  "last-failure-msg": {
                                    "type": "string"
                                  },
                                  "last-failure-timestamp": {
                                    "type": "string"
                                  },
                                  "last-success-timestamp": {
                                    "type": "string"
                                  },
                                  "success-count": {
                                    "type": "integer",
                                    "format": "int64"
                                  }
                                }
                              },
                              "uuid": {
                                "description": "UUID is the UUID of the controller",
                                "type": "string"
                              }
                            }
                          }
                        },
                        "encryption": {
                          "description": "Encryption is the encryption configuration of the node",
                          "type": "object",
                          "properties": {
                            "key": {
                              "description": "Key is the index to the key to use for encryption or 0 if encryption is disabled.",
                              "type": "integer"
                            }
                          }
                        },
                        "external-identifiers": {
                          "description": "ExternalIdentifiers is a set of identifiers to identify the endpoint apart from the pod name. This includes container runtime IDs.",
                          "type": "object",
                          "properties": {
                            "container-id": {
                              "description": "ID assigned by container runtime",
                              "type": "string"
                            },
                            "container-name": {
                              "description": "Name assigned to container",
                              "type": "string"
                            },
                            "docker-endpoint-id": {
                              "description": "Docker endpoint ID",
                              "type": "string"
                            },
                            "docker-network-id": {
                              "description": "Docker network ID",
                              "type": "string"
                            },
                            "k8s-namespace": {
                              "description": "K8s namespace for this endpoint",
                              "type": "string"
                            },
                            "k8s-pod-name": {
                              "description": "K8s pod name for this endpoint",
                              "type": "string"
                            },
                            "pod-name": {
                              "description": "K8s pod for this endpoint(Deprecated, use K8sPodName and K8sNamespace instead)",
                              "type": "string"
                            }
                          }
                        },
                        "health": {
                          "description": "Health is the overall endpoint & subcomponent health.",
                          "type": "object",
                          "properties": {
                            "bpf": {
                              "description": "bpf",
                              "type": "string"
                            },
                            "connected": {
                              "description": "Is this endpoint reachable",
                              "type": "boolean"
                            },
                            "overallHealth": {
                              "description": "overall health",
                              "type": "string"
                            },
                            "policy": {
                              "description": "policy",
                              "type": "string"
                            }
                          }
                        },
                        "id": {
                          "description": "ID is the cilium-agent-local ID of the endpoint.",
                          "type": "integer",
                          "format": "int64"
                        },
                        "identity": {
                          "description": "Identity is the security identity associated with the endpoint",
                          "type": "object",
                          "properties": {
                            "id": {
                              "description": "ID is the numeric identity of the endpoint",
                              "type": "integer",
                              "format": "int64"
                            },
                            "labels": {
                              "description": "Labels is the list of labels associated with the identity",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            }
                          }
                        },
                        "log": {
                          "description": "Log is the list of the last few warning and error log entries",
                          "type": "array",
                          "items": {
                            "description": "EndpointStatusChange Indication of a change of status \n swagger:model EndpointStatusChange",
                            "type": "object",
                            "properties": {
                              "code": {
                                "description": "Code indicate type of status change Enum: [ok failed]",
                                "type": "string"
                              },
                              "message": {
                                "description": "Status message",
                                "type": "string"
                              },
                              "state": {
                                "description": "state",
                                "type": "string"
                              },
                              "timestamp": {
                                "description": "Timestamp when status change occurred",
                                "type": "string"
                              }
                            }
                          }
                        },
                        "named-ports": {
                          "description": "NamedPorts List of named Layer 4 port and protocol pairs which will be used in Network Policy specs. \n swagger:model NamedPorts",
                          "type": "array",
                          "items": {
                            "description": "Port Layer 4 port / protocol pair \n swagger:model Port",
                            "type": "object",
                            "properties": {
                              "name": {
                                "description": "Optional layer 4 port name",
                                "type": "string"
                              },
                              "port": {
                                "description": "Layer 4 port number",
                                "type": "integer"
                              },
                              "protocol": {
                                "description": "Layer 4 protocol Enum: [TCP UDP SCTP ICMP ICMPV6 ANY]",
                                "type": "string"
                              }
                            }
                          }
                        },
                        "networking": {
                          "description": "Networking is the networking properties of the endpoint.",
                          "type": "object",
                          "required": [
                            "addressing"
                          ],
                          "properties": {
                            "addressing": {
                              "description": "IP4/6 addresses assigned to this Endpoint",
                              "type": "array",
                              "items": {
                                "description": "AddressPair is a pair of IPv4 and/or IPv6 address.",
                                "type": "object",
                                "properties": {
                                  "ipv4": {
                                    "type": "string"
                                  },
                                  "ipv6": {
                                    "type": "string"
                                  }
                                }
                              }
                            },
                            "node": {
                              "description": "NodeIP is the IP of the node the endpoint is running on. The IP must be reachable between nodes.",
                              "type": "string"
                            }
                          }
                        },
                        "policy": {
                          "description": "EndpointPolicy represents the endpoint's policy by listing all allowed ingress and egress identities in combination with L4 port and protocol.",
                          "type": "object",
                          "properties": {
                            "egress": {
                              "description": "EndpointPolicyDirection is the list of allowed identities per direction.",
                              "type": "object",
                              "required": [
                                "enforcing"
                              ],
                              "properties": {
                                "adding": {
                                  "description": "Deprecated",
                                  "type": "array",
                                  "items": {
                                    "description": "IdentityTuple specifies a peer by identity, destination port and protocol.",
                                    "type": "object",
                                    "properties": {
                                      "dest-port": {
                                        "type": "integer"
                                      },
                                      "identity": {
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "identity-labels": {
                                        "type": "object",
                                        "additionalProperties": {
                                          "type": "string"
                                        }
                                      },
                                      "protocol": {
                                        "type": "integer"
                                      }
                                    }
                                  }
                                },
                                "allowed": {
                                  "description": "AllowedIdentityList is a list of IdentityTuples that species peers that are allowed.",
                                  "type": "array",
                                  "items": {
                                    "description": "IdentityTuple specifies a peer by identity, destination port and protocol.",
                                    "type": "object",
                                    "properties": {
                                      "dest-port": {
                                        "type": "integer"
                                      },
                                      "identity": {
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "identity-labels": {
                                        "type": "object",
                                        "additionalProperties": {
                                          "type": "string"
                                        }
                                      },
                                      "protocol": {
                                        "type": "integer"
                                      }
                                    }
                                  }
                                },
                                "denied": {
                                  "description": "DenyIdentityList is a list of IdentityTuples that species peers that are denied.",
                                  "type": "array",
                                  "items": {
                                    "description": "IdentityTuple specifies a peer by identity, destination port and protocol.",
                                    "type": "object",
                                    "properties": {
                                      "dest-port": {
                                        "type": "integer"
                                      },
                                      "identity": {
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "identity-labels": {
                                        "type": "object",
                                        "additionalProperties": {
                                          "type": "string"
                                        }
                                      },
                                      "protocol": {
                                        "type": "integer"
                                      }
                                    }
                                  }
                                },
                                "enforcing": {
                                  "type": "boolean"
                                },
                                "removing": {
                                  "description": "Deprecated",
                                  "type": "array",
                                  "items": {
                                    "description": "IdentityTuple specifies a peer by identity, destination port and protocol.",
                                    "type": "object",
                                    "properties": {
                                      "dest-port": {
                                        "type": "integer"
                                      },
                                      "identity": {
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "identity-labels": {
                                        "type": "object",
                                        "additionalProperties": {
                                          "type": "string"
                                        }
                                      },
                                      "protocol": {
                                        "type": "integer"
                                      }
                                    }
                                  }
                                },
                                "state": {
                                  "description": "EndpointPolicyState defines the state of the Policy mode: \"enforcing\", \"non-enforcing\", \"disabled\"",
                                  "type": "string"
                                }
                              }
                            },
                            "ingress": {
                              "description": "EndpointPolicyDirection is the list of allowed identities per direction.",
                              "type": "object",
                              "required": [
                                "enforcing"
                              ],
                              "properties": {
                                "adding": {
                                  "description": "Deprecated",
                                  "type": "array",
                                  "items": {
                                    "description": "IdentityTuple specifies a peer by identity, destination port and protocol.",
                                    "type": "object",
                                    "properties": {
                                      "dest-port": {
                                        "type": "integer"
                                      },
                                      "identity": {
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "identity-labels": {
                                        "type": "object",
                                        "additionalProperties": {
                                          "type": "string"
                                        }
                                      },
                                      "protocol": {
                                        "type": "integer"
                                      }
                                    }
                                  }
                                },
                                "allowed": {
                                  "description": "AllowedIdentityList is a list of IdentityTuples that species peers that are allowed.",
                                  "type": "array",
                                  "items": {
                                    "description": "IdentityTuple specifies a peer by identity, destination port and protocol.",
                                    "type": "object",
                                    "properties": {
                                      "dest-port": {
                                        "type": "integer"
                                      },
                                      "identity": {
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "identity-labels": {
                                        "type": "object",
                                        "additionalProperties": {
                                          "type": "string"
                                        }
                                      },
                                      "protocol": {
                                        "type": "integer"
                                      }
                                    }
                                  }
                                },
                                "denied": {
                                  "description": "DenyIdentityList is a list of IdentityTuples that species peers that are denied.",
                                  "type": "array",
                                  "items": {
                                    "description": "IdentityTuple specifies a peer by identity, destination port and protocol.",
                                    "type": "object",
                                    "properties": {
                                      "dest-port": {
                                        "type": "integer"
                                      },
                                      "identity": {
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "identity-labels": {
                                        "type": "object",
                                        "additionalProperties": {
                                          "type": "string"
                                        }
                                      },
                                      "protocol": {
                                        "type": "integer"
                                      }
                                    }
                                  }
                                },
                                "enforcing": {
                                  "type": "boolean"
                                },
                                "removing": {
                                  "description": "Deprecated",
                                  "type": "array",
                                  "items": {
                                    "description": "IdentityTuple specifies a peer by identity, destination port and protocol.",
                                    "type": "object",
                                    "properties": {
                                      "dest-port": {
                                        "type": "integer"
                                      },
                                      "identity": {
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "identity-labels": {
                                        "type": "object",
                                        "additionalProperties": {
                                          "type": "string"
                                        }
                                      },
                                      "protocol": {
                                        "type": "integer"
                                      }
                                    }
                                  }
                                },
                                "state": {
                                  "description": "EndpointPolicyState defines the state of the Policy mode: \"enforcing\", \"non-enforcing\", \"disabled\"",
                                  "type": "string"
                                }
                              }
                            }
                          }
                        },
                        "state": {
                          "description": "State is the state of the endpoint.",
                          "type": "string",
                          "enum": [
                            "creating",
                            "waiting-for-identity",
                            "not-ready",
                            "waiting-to-regenerate",
                            "regenerating",
                            "restoring",
                            "ready",
                            "disconnecting",
                            "disconnected",
                            "invalid"
                          ]
                        },
                        "visibility-policy-status": {
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              },
              "subresources": {},
              "additionalPrinterColumns": [
                {
                  "name": "Endpoint ID",
                  "type": "integer",
                  "description": "Cilium endpoint id",
                  "jsonPath": ".status.id"
                },
                {
                  "name": "Identity ID",
                  "type": "integer",
                  "description": "Cilium identity id",
                  "jsonPath": ".status.identity.id"
                },
                {
                  "name": "Ingress Enforcement",
                  "type": "string",
                  "description": "Ingress enforcement in the endpoint",
                  "jsonPath": ".status.policy.ingress.state"
                },
                {
                  "name": "Egress Enforcement",
                  "type": "string",
                  "description": "Egress enforcement in the endpoint",
                  "jsonPath": ".status.policy.egress.state"
                },
                {
                  "name": "Visibility Policy",
                  "type": "string",
                  "description": "Status of visibility policy in the endpoint",
                  "jsonPath": ".status.visibility-policy-status"
                },
                {
                  "name": "Endpoint State",
                  "type": "string",
                  "description": "Endpoint current state",
                  "jsonPath": ".status.state"
                },
                {
                  "name": "IPv4",
                  "type": "string",
                  "description": "Endpoint IPv4 address",
                  "jsonPath": ".status.networking.addressing[0].ipv4"
                },
                {
                  "name": "IPv6",
                  "type": "string",
                  "description": "Endpoint IPv6 address",
                  "jsonPath": ".status.networking.addressing[0].ipv6"
                }
              ]
            }
          ],
          "conversion": {
            "strategy": "None"
          }
        },
        "status": {
          "conditions": [
            {
              "type": "NamesAccepted",
              "status": "True",
              "lastTransitionTime": "2023-11-21T10:47:04Z",
              "reason": "NoConflicts",
              "message": "no conflicts found"
            },
            {
              "type": "Established",
              "status": "True",
              "lastTransitionTime": "2023-11-21T10:47:04Z",
              "reason": "InitialNamesAccepted",
              "message": "the initial names have been accepted"
            }
          ],
          "acceptedNames": {
            "plural": "ciliumendpoints",
            "singular": "ciliumendpoint",
            "shortNames": [
              "cep",
              "ciliumep"
            ],
            "kind": "CiliumEndpoint",
            "listKind": "CiliumEndpointList"
          },
          "storedVersions": [
            "v2"
          ]
        }
      },
      "additionalColumns": [
        {
          "name": "Endpoint ID",
          "type": "integer",
          "description": "Cilium endpoint id",
          "jsonPath": ".status.id"
        },
        {
          "name": "Identity ID",
          "type": "integer",
          "description": "Cilium identity id",
          "jsonPath": ".status.identity.id"
        },
        {
          "name": "Ingress Enforcement",
          "type": "string",
          "description": "Ingress enforcement in the endpoint",
          "jsonPath": ".status.policy.ingress.state"
        },
        {
          "name": "Egress Enforcement",
          "type": "string",
          "description": "Egress enforcement in the endpoint",
          "jsonPath": ".status.policy.egress.state"
        },
        {
          "name": "Visibility Policy",
          "type": "string",
          "description": "Status of visibility policy in the endpoint",
          "jsonPath": ".status.visibility-policy-status"
        },
        {
          "name": "Endpoint State",
          "type": "string",
          "description": "Endpoint current state",
          "jsonPath": ".status.state"
        },
        {
          "name": "IPv4",
          "type": "string",
          "description": "Endpoint IPv4 address",
          "jsonPath": ".status.networking.addressing[0].ipv4"
        },
        {
          "name": "IPv6",
          "type": "string",
          "description": "Endpoint IPv6 address",
          "jsonPath": ".status.networking.addressing[0].ipv6"
        }
      ],
      "short": "CiliumEndpoint",
      "apiGroup": "cilium.io",
      "apiKind": "CiliumEndpoint",
      "apiVersion": "v2",
      "readProperties": {
        "status": "status"
      },
      "writeProperties": {},
      "group": "cilium",
      "sub": "cilium",
      "listExcludes": [],
      "readExcludes": [],
      "simpleExcludes": [],
      "gqlDefs": {
        "metadata": "metadata!",
        "status": "JSONObject"
      },
      "namespaced": true
    },
    {
      "alternatives": [],
      "name": "io.cilium.v2.CiliumExternalWorkload",
      "definition": {
        "description": "CiliumExternalWorkload is a Kubernetes Custom Resource that contains a specification for an external workload that can join the cluster.  The name of the CRD is the FQDN of the external workload, and it needs to match the name in the workload registration. The labels on the CRD object are the labels that will be used to allocate a Cilium Identity for the external workload. If 'io.kubernetes.pod.namespace' or 'io.kubernetes.pod.name' labels are not explicitly specified, they will be defaulted to 'default' and <workload name>, respectively. 'io.cilium.k8s.policy.cluster' will always be defined as the name of the current cluster, which defaults to \"default\".",
        "type": "object",
        "required": [
          "metadata"
        ],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "spec": {
            "description": "Spec is the desired configuration of the external Cilium workload.",
            "type": "object",
            "properties": {
              "ipv4-alloc-cidr": {
                "description": "IPv4AllocCIDR is the range of IPv4 addresses in the CIDR format that the external workload can use to allocate IP addresses for the tunnel device and the health endpoint.",
                "type": "string",
                "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$"
              },
              "ipv6-alloc-cidr": {
                "description": "IPv6AllocCIDR is the range of IPv6 addresses in the CIDR format that the external workload can use to allocate IP addresses for the tunnel device and the health endpoint.",
                "type": "string",
                "pattern": "^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
              }
            }
          },
          "status": {
            "description": "Status is the most recent status of the external Cilium workload. It is a read-only field.",
            "type": "object",
            "properties": {
              "id": {
                "description": "ID is the numeric identity allocated for the external workload.",
                "type": "integer",
                "format": "int64"
              },
              "ip": {
                "description": "IP is the IP address of the workload. Empty if the workload has not registered.",
                "type": "string"
              }
            }
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "cilium.io",
            "kind": "CiliumExternalWorkload",
            "version": "v2"
          }
        ]
      },
      "crd": {
        "metadata": {
          "name": "ciliumexternalworkloads.cilium.io",
          "uid": "38cadee6-0b6a-449b-81be-b21f6f73259b",
          "resourceVersion": "25877237570",
          "generation": 1,
          "creationTimestamp": "2023-11-21T10:47:02Z",
          "labels": {
            "io.cilium.k8s.crd.schema.version": "1.26.11"
          },
          "managedFields": [
            {
              "manager": "cilium-operator-generic",
              "operation": "Update",
              "apiVersion": "apiextensions.k8s.io/v1",
              "time": "2023-11-21T10:47:02Z",
              "fieldsType": "FieldsV1",
              "fieldsV1": {
                "f:metadata": {
                  "f:labels": {
                    ".": {},
                    "f:io.cilium.k8s.crd.schema.version": {}
                  }
                },
                "f:spec": {
                  "f:conversion": {
                    ".": {},
                    "f:strategy": {}
                  },
                  "f:group": {},
                  "f:names": {
                    "f:kind": {},
                    "f:listKind": {},
                    "f:plural": {},
                    "f:shortNames": {},
                    "f:singular": {}
                  },
                  "f:scope": {},
                  "f:versions": {}
                }
              }
            },
            {
              "manager": "kube-apiserver",
              "operation": "Update",
              "apiVersion": "apiextensions.k8s.io/v1",
              "time": "2023-11-21T10:47:02Z",
              "fieldsType": "FieldsV1",
              "fieldsV1": {
                "f:status": {
                  "f:acceptedNames": {
                    "f:kind": {},
                    "f:listKind": {},
                    "f:plural": {},
                    "f:shortNames": {},
                    "f:singular": {}
                  },
                  "f:conditions": {
                    "k:{\"type\":\"Established\"}": {
                      ".": {},
                      "f:lastTransitionTime": {},
                      "f:message": {},
                      "f:reason": {},
                      "f:status": {},
                      "f:type": {}
                    },
                    "k:{\"type\":\"NamesAccepted\"}": {
                      ".": {},
                      "f:lastTransitionTime": {},
                      "f:message": {},
                      "f:reason": {},
                      "f:status": {},
                      "f:type": {}
                    }
                  }
                }
              },
              "subresource": "status"
            }
          ]
        },
        "spec": {
          "group": "cilium.io",
          "names": {
            "plural": "ciliumexternalworkloads",
            "singular": "ciliumexternalworkload",
            "shortNames": [
              "cew"
            ],
            "kind": "CiliumExternalWorkload",
            "listKind": "CiliumExternalWorkloadList"
          },
          "scope": "Cluster",
          "versions": [
            {
              "name": "v2",
              "served": true,
              "storage": true,
              "schema": {
                "openAPIV3Schema": {
                  "description": "CiliumExternalWorkload is a Kubernetes Custom Resource that contains a specification for an external workload that can join the cluster.  The name of the CRD is the FQDN of the external workload, and it needs to match the name in the workload registration. The labels on the CRD object are the labels that will be used to allocate a Cilium Identity for the external workload. If 'io.kubernetes.pod.namespace' or 'io.kubernetes.pod.name' labels are not explicitly specified, they will be defaulted to 'default' and <workload name>, respectively. 'io.cilium.k8s.policy.cluster' will always be defined as the name of the current cluster, which defaults to \"default\".",
                  "type": "object",
                  "required": [
                    "metadata"
                  ],
                  "properties": {
                    "apiVersion": {
                      "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                      "type": "string"
                    },
                    "kind": {
                      "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                      "type": "string"
                    },
                    "metadata": {
                      "type": "object"
                    },
                    "spec": {
                      "description": "Spec is the desired configuration of the external Cilium workload.",
                      "type": "object",
                      "properties": {
                        "ipv4-alloc-cidr": {
                          "description": "IPv4AllocCIDR is the range of IPv4 addresses in the CIDR format that the external workload can use to allocate IP addresses for the tunnel device and the health endpoint.",
                          "type": "string",
                          "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$"
                        },
                        "ipv6-alloc-cidr": {
                          "description": "IPv6AllocCIDR is the range of IPv6 addresses in the CIDR format that the external workload can use to allocate IP addresses for the tunnel device and the health endpoint.",
                          "type": "string",
                          "pattern": "^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                        }
                      }
                    },
                    "status": {
                      "description": "Status is the most recent status of the external Cilium workload. It is a read-only field.",
                      "type": "object",
                      "properties": {
                        "id": {
                          "description": "ID is the numeric identity allocated for the external workload.",
                          "type": "integer",
                          "format": "int64"
                        },
                        "ip": {
                          "description": "IP is the IP address of the workload. Empty if the workload has not registered.",
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              },
              "subresources": {
                "status": {}
              },
              "additionalPrinterColumns": [
                {
                  "name": "Cilium ID",
                  "type": "integer",
                  "jsonPath": ".status.id"
                },
                {
                  "name": "IP",
                  "type": "string",
                  "jsonPath": ".status.ip"
                }
              ]
            }
          ],
          "conversion": {
            "strategy": "None"
          }
        },
        "status": {
          "conditions": [
            {
              "type": "NamesAccepted",
              "status": "True",
              "lastTransitionTime": "2023-11-21T10:47:02Z",
              "reason": "NoConflicts",
              "message": "no conflicts found"
            },
            {
              "type": "Established",
              "status": "True",
              "lastTransitionTime": "2023-11-21T10:47:02Z",
              "reason": "InitialNamesAccepted",
              "message": "the initial names have been accepted"
            }
          ],
          "acceptedNames": {
            "plural": "ciliumexternalworkloads",
            "singular": "ciliumexternalworkload",
            "shortNames": [
              "cew"
            ],
            "kind": "CiliumExternalWorkload",
            "listKind": "CiliumExternalWorkloadList"
          },
          "storedVersions": [
            "v2"
          ]
        }
      },
      "additionalColumns": [
        {
          "name": "Cilium ID",
          "type": "integer",
          "jsonPath": ".status.id"
        },
        {
          "name": "IP",
          "type": "string",
          "jsonPath": ".status.ip"
        }
      ],
      "short": "CiliumExternalWorkload",
      "apiGroup": "cilium.io",
      "apiKind": "CiliumExternalWorkload",
      "apiVersion": "v2",
      "readProperties": {
        "spec": "spec",
        "status": "status"
      },
      "writeProperties": {
        "spec": "spec"
      },
      "group": "cilium",
      "sub": "cilium",
      "listExcludes": [],
      "readExcludes": [],
      "simpleExcludes": [],
      "gqlDefs": {
        "metadata": "metadata!",
        "spec": "JSONObject",
        "status": "JSONObject"
      },
      "namespaced": false
    },
    {
      "alternatives": [],
      "name": "io.cilium.v2.CiliumIdentity",
      "definition": {
        "description": "CiliumIdentity is a CRD that represents an identity managed by Cilium. It is intended as a backing store for identity allocation, acting as the global coordination backend, and can be used in place of a KVStore (such as etcd). The name of the CRD is the numeric identity and the labels on the CRD object are the kubernetes sourced labels seen by cilium. This is currently the only label source possible when running under kubernetes. Non-kubernetes labels are filtered but all labels, from all sources, are places in the SecurityLabels field. These also include the source and are used to define the identity. The labels under metav1.ObjectMeta can be used when searching for CiliumIdentity instances that include particular labels. This can be done with invocations such as: \n \tkubectl get ciliumid -l 'foo=bar'",
        "type": "object",
        "required": [
          "metadata",
          "security-labels"
        ],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "security-labels": {
            "description": "SecurityLabels is the source-of-truth set of labels for this identity.",
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "cilium.io",
            "kind": "CiliumIdentity",
            "version": "v2"
          }
        ]
      },
      "crd": {
        "metadata": {
          "name": "ciliumidentities.cilium.io",
          "uid": "fd5d1b33-6735-452e-88c0-01c61a14935c",
          "resourceVersion": "25877237601",
          "generation": 1,
          "creationTimestamp": "2023-11-21T10:47:02Z",
          "labels": {
            "io.cilium.k8s.crd.schema.version": "1.26.11"
          },
          "managedFields": [
            {
              "manager": "cilium-operator-generic",
              "operation": "Update",
              "apiVersion": "apiextensions.k8s.io/v1",
              "time": "2023-11-21T10:47:02Z",
              "fieldsType": "FieldsV1",
              "fieldsV1": {
                "f:metadata": {
                  "f:labels": {
                    ".": {},
                    "f:io.cilium.k8s.crd.schema.version": {}
                  }
                },
                "f:spec": {
                  "f:conversion": {
                    ".": {},
                    "f:strategy": {}
                  },
                  "f:group": {},
                  "f:names": {
                    "f:kind": {},
                    "f:listKind": {},
                    "f:plural": {},
                    "f:shortNames": {},
                    "f:singular": {}
                  },
                  "f:scope": {},
                  "f:versions": {}
                }
              }
            },
            {
              "manager": "kube-apiserver",
              "operation": "Update",
              "apiVersion": "apiextensions.k8s.io/v1",
              "time": "2023-11-21T10:47:02Z",
              "fieldsType": "FieldsV1",
              "fieldsV1": {
                "f:status": {
                  "f:acceptedNames": {
                    "f:kind": {},
                    "f:listKind": {},
                    "f:plural": {},
                    "f:shortNames": {},
                    "f:singular": {}
                  },
                  "f:conditions": {
                    "k:{\"type\":\"Established\"}": {
                      ".": {},
                      "f:lastTransitionTime": {},
                      "f:message": {},
                      "f:reason": {},
                      "f:status": {},
                      "f:type": {}
                    },
                    "k:{\"type\":\"NamesAccepted\"}": {
                      ".": {},
                      "f:lastTransitionTime": {},
                      "f:message": {},
                      "f:reason": {},
                      "f:status": {},
                      "f:type": {}
                    }
                  }
                }
              },
              "subresource": "status"
            }
          ]
        },
        "spec": {
          "group": "cilium.io",
          "names": {
            "plural": "ciliumidentities",
            "singular": "ciliumidentity",
            "shortNames": [
              "ciliumid"
            ],
            "kind": "CiliumIdentity",
            "listKind": "CiliumIdentityList"
          },
          "scope": "Cluster",
          "versions": [
            {
              "name": "v2",
              "served": true,
              "storage": true,
              "schema": {
                "openAPIV3Schema": {
                  "description": "CiliumIdentity is a CRD that represents an identity managed by Cilium. It is intended as a backing store for identity allocation, acting as the global coordination backend, and can be used in place of a KVStore (such as etcd). The name of the CRD is the numeric identity and the labels on the CRD object are the kubernetes sourced labels seen by cilium. This is currently the only label source possible when running under kubernetes. Non-kubernetes labels are filtered but all labels, from all sources, are places in the SecurityLabels field. These also include the source and are used to define the identity. The labels under metav1.ObjectMeta can be used when searching for CiliumIdentity instances that include particular labels. This can be done with invocations such as: \n \tkubectl get ciliumid -l 'foo=bar'",
                  "type": "object",
                  "required": [
                    "metadata",
                    "security-labels"
                  ],
                  "properties": {
                    "apiVersion": {
                      "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                      "type": "string"
                    },
                    "kind": {
                      "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                      "type": "string"
                    },
                    "metadata": {
                      "type": "object"
                    },
                    "security-labels": {
                      "description": "SecurityLabels is the source-of-truth set of labels for this identity.",
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    }
                  }
                }
              },
              "subresources": {
                "status": {}
              },
              "additionalPrinterColumns": [
                {
                  "name": "Namespace",
                  "type": "string",
                  "description": "The namespace of the entity",
                  "jsonPath": ".metadata.labels.io\\.kubernetes\\.pod\\.namespace"
                },
                {
                  "name": "Age",
                  "type": "date",
                  "description": "The age of the identity",
                  "jsonPath": ".metadata.creationTimestamp"
                }
              ]
            }
          ],
          "conversion": {
            "strategy": "None"
          }
        },
        "status": {
          "conditions": [
            {
              "type": "NamesAccepted",
              "status": "True",
              "lastTransitionTime": "2023-11-21T10:47:02Z",
              "reason": "NoConflicts",
              "message": "no conflicts found"
            },
            {
              "type": "Established",
              "status": "True",
              "lastTransitionTime": "2023-11-21T10:47:02Z",
              "reason": "InitialNamesAccepted",
              "message": "the initial names have been accepted"
            }
          ],
          "acceptedNames": {
            "plural": "ciliumidentities",
            "singular": "ciliumidentity",
            "shortNames": [
              "ciliumid"
            ],
            "kind": "CiliumIdentity",
            "listKind": "CiliumIdentityList"
          },
          "storedVersions": [
            "v2"
          ]
        }
      },
      "additionalColumns": [
        {
          "name": "Namespace",
          "type": "string",
          "description": "The namespace of the entity",
          "jsonPath": ".metadata.labels.io\\.kubernetes\\.pod\\.namespace"
        },
        {
          "name": "Age",
          "type": "date",
          "description": "The age of the identity",
          "jsonPath": ".metadata.creationTimestamp"
        }
      ],
      "short": "CiliumIdentity",
      "apiGroup": "cilium.io",
      "apiKind": "CiliumIdentity",
      "apiVersion": "v2",
      "readProperties": {
        "security-labels": "security_labels"
      },
      "writeProperties": {
        "security-labels": "security_labels"
      },
      "group": "cilium",
      "sub": "cilium",
      "listExcludes": [],
      "readExcludes": [],
      "simpleExcludes": [],
      "gqlDefs": {
        "metadata": "metadata!",
        "security_labels": "JSONObject"
      },
      "namespaced": false
    },
    {
      "alternatives": [],
      "name": "io.cilium.v2.CiliumLocalRedirectPolicy",
      "definition": {
        "description": "CiliumLocalRedirectPolicy is a Kubernetes Custom Resource that contains a specification to redirect traffic locally within a node.",
        "type": "object",
        "required": [
          "metadata"
        ],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "spec": {
            "description": "Spec is the desired behavior of the local redirect policy.",
            "type": "object",
            "required": [
              "redirectBackend",
              "redirectFrontend"
            ],
            "properties": {
              "description": {
                "description": "Description can be used by the creator of the policy to describe the purpose of this policy.",
                "type": "string"
              },
              "redirectBackend": {
                "description": "RedirectBackend specifies backend configuration to redirect traffic to. It can not be empty.",
                "type": "object",
                "required": [
                  "localEndpointSelector",
                  "toPorts"
                ],
                "properties": {
                  "localEndpointSelector": {
                    "description": "LocalEndpointSelector selects node local pod(s) where traffic is redirected to.",
                    "type": "object",
                    "properties": {
                      "matchExpressions": {
                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                        "type": "array",
                        "items": {
                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                          "type": "object",
                          "required": [
                            "key",
                            "operator"
                          ],
                          "properties": {
                            "key": {
                              "description": "key is the label key that the selector applies to.",
                              "type": "string"
                            },
                            "operator": {
                              "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                              "type": "string",
                              "enum": [
                                "In",
                                "NotIn",
                                "Exists",
                                "DoesNotExist"
                              ]
                            },
                            "values": {
                              "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            }
                          }
                        }
                      },
                      "matchLabels": {
                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                        "type": "object",
                        "additionalProperties": {
                          "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                          "type": "string",
                          "maxLength": 63,
                          "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                        }
                      }
                    }
                  },
                  "toPorts": {
                    "description": "ToPorts is a list of L4 ports with protocol of node local pod(s) where traffic is redirected to. When multiple ports are specified, the ports must be named.",
                    "type": "array",
                    "items": {
                      "description": "PortInfo specifies L4 port number and name along with the transport protocol",
                      "type": "object",
                      "required": [
                        "port",
                        "protocol"
                      ],
                      "properties": {
                        "name": {
                          "description": "Name is a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                          "type": "string",
                          "pattern": "^([0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                        },
                        "port": {
                          "description": "Port is an L4 port number. The string will be strictly parsed as a single uint16.",
                          "type": "string",
                          "pattern": "^()([1-9]|[1-5]?[0-9]{2,4}|6[1-4][0-9]{3}|65[1-4][0-9]{2}|655[1-2][0-9]|6553[1-5])$"
                        },
                        "protocol": {
                          "description": "Protocol is the L4 protocol. Accepted values: \"TCP\", \"UDP\"",
                          "type": "string",
                          "enum": [
                            "TCP",
                            "UDP"
                          ]
                        }
                      }
                    }
                  }
                }
              },
              "redirectFrontend": {
                "description": "RedirectFrontend specifies frontend configuration to redirect traffic from. It can not be empty.",
                "type": "object",
                "properties": {
                  "addressMatcher": {
                    "description": "AddressMatcher is a tuple {IP, port, protocol} that matches traffic to be redirected.",
                    "type": "object",
                    "required": [
                      "ip",
                      "toPorts"
                    ],
                    "properties": {
                      "ip": {
                        "description": "IP is a destination ip address for traffic to be redirected. \n Example: When it is set to \"169.254.169.254\", traffic destined to \"169.254.169.254\" is redirected.",
                        "type": "string",
                        "pattern": "((^\\s*((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))\\s*$)|(^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$))"
                      },
                      "toPorts": {
                        "description": "ToPorts is a list of destination L4 ports with protocol for traffic to be redirected. When multiple ports are specified, the ports must be named. \n Example: When set to Port: \"53\" and Protocol: UDP, traffic destined to port '53' with UDP protocol is redirected.",
                        "type": "array",
                        "items": {
                          "description": "PortInfo specifies L4 port number and name along with the transport protocol",
                          "type": "object",
                          "required": [
                            "port",
                            "protocol"
                          ],
                          "properties": {
                            "name": {
                              "description": "Name is a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                              "type": "string",
                              "pattern": "^([0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                            },
                            "port": {
                              "description": "Port is an L4 port number. The string will be strictly parsed as a single uint16.",
                              "type": "string",
                              "pattern": "^()([1-9]|[1-5]?[0-9]{2,4}|6[1-4][0-9]{3}|65[1-4][0-9]{2}|655[1-2][0-9]|6553[1-5])$"
                            },
                            "protocol": {
                              "description": "Protocol is the L4 protocol. Accepted values: \"TCP\", \"UDP\"",
                              "type": "string",
                              "enum": [
                                "TCP",
                                "UDP"
                              ]
                            }
                          }
                        }
                      }
                    }
                  },
                  "serviceMatcher": {
                    "description": "ServiceMatcher specifies Kubernetes service and port that matches traffic to be redirected.",
                    "type": "object",
                    "required": [
                      "namespace",
                      "serviceName"
                    ],
                    "properties": {
                      "namespace": {
                        "description": "Namespace is the Kubernetes service namespace. The service namespace must match the namespace of the parent Local Redirect Policy.  For Cluster-wide Local Redirect Policy, this can be any namespace.",
                        "type": "string"
                      },
                      "serviceName": {
                        "description": "Name is the name of a destination Kubernetes service that identifies traffic to be redirected. The service type needs to be ClusterIP. \n Example: When this field is populated with 'serviceName:myService', all the traffic destined to the cluster IP of this service at the (specified) service port(s) will be redirected.",
                        "type": "string"
                      },
                      "toPorts": {
                        "description": "ToPorts is a list of destination service L4 ports with protocol for traffic to be redirected. If not specified, traffic for all the service ports will be redirected. When multiple ports are specified, the ports must be named.",
                        "type": "array",
                        "items": {
                          "description": "PortInfo specifies L4 port number and name along with the transport protocol",
                          "type": "object",
                          "required": [
                            "port",
                            "protocol"
                          ],
                          "properties": {
                            "name": {
                              "description": "Name is a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                              "type": "string",
                              "pattern": "^([0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                            },
                            "port": {
                              "description": "Port is an L4 port number. The string will be strictly parsed as a single uint16.",
                              "type": "string",
                              "pattern": "^()([1-9]|[1-5]?[0-9]{2,4}|6[1-4][0-9]{3}|65[1-4][0-9]{2}|655[1-2][0-9]|6553[1-5])$"
                            },
                            "protocol": {
                              "description": "Protocol is the L4 protocol. Accepted values: \"TCP\", \"UDP\"",
                              "type": "string",
                              "enum": [
                                "TCP",
                                "UDP"
                              ]
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "status": {
            "description": "Status is the most recent status of the local redirect policy. It is a read-only field.",
            "type": "object",
            "properties": {
              "ok": {
                "description": "TODO Define status(aditi)",
                "type": "object"
              }
            }
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "cilium.io",
            "kind": "CiliumLocalRedirectPolicy",
            "version": "v2"
          }
        ]
      },
      "crd": {
        "metadata": {
          "name": "ciliumlocalredirectpolicies.cilium.io",
          "uid": "d93c516d-3719-4157-a543-f9a82f015169",
          "resourceVersion": "25877238010",
          "generation": 1,
          "creationTimestamp": "2023-11-21T10:47:04Z",
          "labels": {
            "io.cilium.k8s.crd.schema.version": "1.26.11"
          },
          "managedFields": [
            {
              "manager": "cilium-operator-generic",
              "operation": "Update",
              "apiVersion": "apiextensions.k8s.io/v1",
              "time": "2023-11-21T10:47:04Z",
              "fieldsType": "FieldsV1",
              "fieldsV1": {
                "f:metadata": {
                  "f:labels": {
                    ".": {},
                    "f:io.cilium.k8s.crd.schema.version": {}
                  }
                },
                "f:spec": {
                  "f:conversion": {
                    ".": {},
                    "f:strategy": {}
                  },
                  "f:group": {},
                  "f:names": {
                    "f:kind": {},
                    "f:listKind": {},
                    "f:plural": {},
                    "f:shortNames": {},
                    "f:singular": {}
                  },
                  "f:scope": {},
                  "f:versions": {}
                }
              }
            },
            {
              "manager": "kube-apiserver",
              "operation": "Update",
              "apiVersion": "apiextensions.k8s.io/v1",
              "time": "2023-11-21T10:47:04Z",
              "fieldsType": "FieldsV1",
              "fieldsV1": {
                "f:status": {
                  "f:acceptedNames": {
                    "f:kind": {},
                    "f:listKind": {},
                    "f:plural": {},
                    "f:shortNames": {},
                    "f:singular": {}
                  },
                  "f:conditions": {
                    "k:{\"type\":\"Established\"}": {
                      ".": {},
                      "f:lastTransitionTime": {},
                      "f:message": {},
                      "f:reason": {},
                      "f:status": {},
                      "f:type": {}
                    },
                    "k:{\"type\":\"NamesAccepted\"}": {
                      ".": {},
                      "f:lastTransitionTime": {},
                      "f:message": {},
                      "f:reason": {},
                      "f:status": {},
                      "f:type": {}
                    }
                  }
                }
              },
              "subresource": "status"
            }
          ]
        },
        "spec": {
          "group": "cilium.io",
          "names": {
            "plural": "ciliumlocalredirectpolicies",
            "singular": "ciliumlocalredirectpolicy",
            "shortNames": [
              "clrp"
            ],
            "kind": "CiliumLocalRedirectPolicy",
            "listKind": "CiliumLocalRedirectPolicyList"
          },
          "scope": "Namespaced",
          "versions": [
            {
              "name": "v2",
              "served": true,
              "storage": true,
              "schema": {
                "openAPIV3Schema": {
                  "description": "CiliumLocalRedirectPolicy is a Kubernetes Custom Resource that contains a specification to redirect traffic locally within a node.",
                  "type": "object",
                  "required": [
                    "metadata"
                  ],
                  "properties": {
                    "apiVersion": {
                      "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                      "type": "string"
                    },
                    "kind": {
                      "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                      "type": "string"
                    },
                    "metadata": {
                      "type": "object"
                    },
                    "spec": {
                      "description": "Spec is the desired behavior of the local redirect policy.",
                      "type": "object",
                      "required": [
                        "redirectBackend",
                        "redirectFrontend"
                      ],
                      "properties": {
                        "description": {
                          "description": "Description can be used by the creator of the policy to describe the purpose of this policy.",
                          "type": "string"
                        },
                        "redirectBackend": {
                          "description": "RedirectBackend specifies backend configuration to redirect traffic to. It can not be empty.",
                          "type": "object",
                          "required": [
                            "localEndpointSelector",
                            "toPorts"
                          ],
                          "properties": {
                            "localEndpointSelector": {
                              "description": "LocalEndpointSelector selects node local pod(s) where traffic is redirected to.",
                              "type": "object",
                              "properties": {
                                "matchExpressions": {
                                  "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                  "type": "array",
                                  "items": {
                                    "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                    "type": "object",
                                    "required": [
                                      "key",
                                      "operator"
                                    ],
                                    "properties": {
                                      "key": {
                                        "description": "key is the label key that the selector applies to.",
                                        "type": "string"
                                      },
                                      "operator": {
                                        "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                        "type": "string",
                                        "enum": [
                                          "In",
                                          "NotIn",
                                          "Exists",
                                          "DoesNotExist"
                                        ]
                                      },
                                      "values": {
                                        "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        }
                                      }
                                    }
                                  }
                                },
                                "matchLabels": {
                                  "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                  "type": "object",
                                  "additionalProperties": {
                                    "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                    "type": "string",
                                    "maxLength": 63,
                                    "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                  }
                                }
                              }
                            },
                            "toPorts": {
                              "description": "ToPorts is a list of L4 ports with protocol of node local pod(s) where traffic is redirected to. When multiple ports are specified, the ports must be named.",
                              "type": "array",
                              "items": {
                                "description": "PortInfo specifies L4 port number and name along with the transport protocol",
                                "type": "object",
                                "required": [
                                  "port",
                                  "protocol"
                                ],
                                "properties": {
                                  "name": {
                                    "description": "Name is a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                    "type": "string",
                                    "pattern": "^([0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                  },
                                  "port": {
                                    "description": "Port is an L4 port number. The string will be strictly parsed as a single uint16.",
                                    "type": "string",
                                    "pattern": "^()([1-9]|[1-5]?[0-9]{2,4}|6[1-4][0-9]{3}|65[1-4][0-9]{2}|655[1-2][0-9]|6553[1-5])$"
                                  },
                                  "protocol": {
                                    "description": "Protocol is the L4 protocol. Accepted values: \"TCP\", \"UDP\"",
                                    "type": "string",
                                    "enum": [
                                      "TCP",
                                      "UDP"
                                    ]
                                  }
                                }
                              }
                            }
                          }
                        },
                        "redirectFrontend": {
                          "description": "RedirectFrontend specifies frontend configuration to redirect traffic from. It can not be empty.",
                          "type": "object",
                          "oneOf": [
                            {
                              "required": [
                                "addressMatcher"
                              ],
                              "properties": {
                                "addressMatcher": {}
                              }
                            },
                            {
                              "required": [
                                "serviceMatcher"
                              ],
                              "properties": {
                                "serviceMatcher": {}
                              }
                            }
                          ],
                          "properties": {
                            "addressMatcher": {
                              "description": "AddressMatcher is a tuple {IP, port, protocol} that matches traffic to be redirected.",
                              "type": "object",
                              "required": [
                                "ip",
                                "toPorts"
                              ],
                              "properties": {
                                "ip": {
                                  "description": "IP is a destination ip address for traffic to be redirected. \n Example: When it is set to \"169.254.169.254\", traffic destined to \"169.254.169.254\" is redirected.",
                                  "type": "string",
                                  "pattern": "((^\\s*((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))\\s*$)|(^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$))"
                                },
                                "toPorts": {
                                  "description": "ToPorts is a list of destination L4 ports with protocol for traffic to be redirected. When multiple ports are specified, the ports must be named. \n Example: When set to Port: \"53\" and Protocol: UDP, traffic destined to port '53' with UDP protocol is redirected.",
                                  "type": "array",
                                  "items": {
                                    "description": "PortInfo specifies L4 port number and name along with the transport protocol",
                                    "type": "object",
                                    "required": [
                                      "port",
                                      "protocol"
                                    ],
                                    "properties": {
                                      "name": {
                                        "description": "Name is a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                        "type": "string",
                                        "pattern": "^([0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                      },
                                      "port": {
                                        "description": "Port is an L4 port number. The string will be strictly parsed as a single uint16.",
                                        "type": "string",
                                        "pattern": "^()([1-9]|[1-5]?[0-9]{2,4}|6[1-4][0-9]{3}|65[1-4][0-9]{2}|655[1-2][0-9]|6553[1-5])$"
                                      },
                                      "protocol": {
                                        "description": "Protocol is the L4 protocol. Accepted values: \"TCP\", \"UDP\"",
                                        "type": "string",
                                        "enum": [
                                          "TCP",
                                          "UDP"
                                        ]
                                      }
                                    }
                                  }
                                }
                              }
                            },
                            "serviceMatcher": {
                              "description": "ServiceMatcher specifies Kubernetes service and port that matches traffic to be redirected.",
                              "type": "object",
                              "required": [
                                "namespace",
                                "serviceName"
                              ],
                              "properties": {
                                "namespace": {
                                  "description": "Namespace is the Kubernetes service namespace. The service namespace must match the namespace of the parent Local Redirect Policy.  For Cluster-wide Local Redirect Policy, this can be any namespace.",
                                  "type": "string"
                                },
                                "serviceName": {
                                  "description": "Name is the name of a destination Kubernetes service that identifies traffic to be redirected. The service type needs to be ClusterIP. \n Example: When this field is populated with 'serviceName:myService', all the traffic destined to the cluster IP of this service at the (specified) service port(s) will be redirected.",
                                  "type": "string"
                                },
                                "toPorts": {
                                  "description": "ToPorts is a list of destination service L4 ports with protocol for traffic to be redirected. If not specified, traffic for all the service ports will be redirected. When multiple ports are specified, the ports must be named.",
                                  "type": "array",
                                  "items": {
                                    "description": "PortInfo specifies L4 port number and name along with the transport protocol",
                                    "type": "object",
                                    "required": [
                                      "port",
                                      "protocol"
                                    ],
                                    "properties": {
                                      "name": {
                                        "description": "Name is a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                        "type": "string",
                                        "pattern": "^([0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                      },
                                      "port": {
                                        "description": "Port is an L4 port number. The string will be strictly parsed as a single uint16.",
                                        "type": "string",
                                        "pattern": "^()([1-9]|[1-5]?[0-9]{2,4}|6[1-4][0-9]{3}|65[1-4][0-9]{2}|655[1-2][0-9]|6553[1-5])$"
                                      },
                                      "protocol": {
                                        "description": "Protocol is the L4 protocol. Accepted values: \"TCP\", \"UDP\"",
                                        "type": "string",
                                        "enum": [
                                          "TCP",
                                          "UDP"
                                        ]
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "status": {
                      "description": "Status is the most recent status of the local redirect policy. It is a read-only field.",
                      "type": "object",
                      "properties": {
                        "ok": {
                          "description": "TODO Define status(aditi)",
                          "type": "object"
                        }
                      }
                    }
                  }
                }
              },
              "subresources": {},
              "additionalPrinterColumns": [
                {
                  "name": "Age",
                  "type": "date",
                  "jsonPath": ".metadata.creationTimestamp"
                }
              ]
            }
          ],
          "conversion": {
            "strategy": "None"
          }
        },
        "status": {
          "conditions": [
            {
              "type": "NamesAccepted",
              "status": "True",
              "lastTransitionTime": "2023-11-21T10:47:04Z",
              "reason": "NoConflicts",
              "message": "no conflicts found"
            },
            {
              "type": "Established",
              "status": "True",
              "lastTransitionTime": "2023-11-21T10:47:04Z",
              "reason": "InitialNamesAccepted",
              "message": "the initial names have been accepted"
            }
          ],
          "acceptedNames": {
            "plural": "ciliumlocalredirectpolicies",
            "singular": "ciliumlocalredirectpolicy",
            "shortNames": [
              "clrp"
            ],
            "kind": "CiliumLocalRedirectPolicy",
            "listKind": "CiliumLocalRedirectPolicyList"
          },
          "storedVersions": [
            "v2"
          ]
        }
      },
      "additionalColumns": [
        {
          "name": "Age",
          "type": "date",
          "jsonPath": ".metadata.creationTimestamp"
        }
      ],
      "short": "CiliumLocalRedirectPolicy",
      "apiGroup": "cilium.io",
      "apiKind": "CiliumLocalRedirectPolicy",
      "apiVersion": "v2",
      "readProperties": {
        "spec": "spec",
        "status": "status"
      },
      "writeProperties": {
        "spec": "spec"
      },
      "group": "cilium",
      "sub": "cilium",
      "listExcludes": [],
      "readExcludes": [],
      "simpleExcludes": [],
      "gqlDefs": {
        "metadata": "metadata!",
        "spec": "JSONObject",
        "status": "JSONObject"
      },
      "namespaced": true
    },
    {
      "alternatives": [],
      "name": "io.cilium.v2.CiliumNetworkPolicy",
      "definition": {
        "description": "CiliumNetworkPolicy is a Kubernetes third-party resource with an extended version of NetworkPolicy.",
        "type": "object",
        "required": [
          "metadata"
        ],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "spec": {
            "description": "Spec is the desired Cilium specific rule specification.",
            "type": "object",
            "properties": {
              "description": {
                "description": "Description is a free form string, it can be used by the creator of the rule to store human readable explanation of the purpose of this rule. Rules cannot be identified by comment.",
                "type": "string"
              },
              "egress": {
                "description": "Egress is a list of EgressRule which are enforced at egress. If omitted or empty, this rule does not apply at egress.",
                "type": "array",
                "items": {
                  "description": "EgressRule contains all rule types which can be applied at egress, i.e. network traffic that originates inside the endpoint and exits the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members of the structure are specified, then all members     must match in order for the rule to take effect. The exception to this     rule is the ToRequires member; the effects of any Requires field in any     rule will apply to all other rules as well. \n   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are     mutually exclusive. Only one of these members may be present within an     individual rule.",
                  "type": "object",
                  "properties": {
                    "authentication": {
                      "description": "Authentication is the required authentication type for the allowed traffic, if any.",
                      "type": "object",
                      "required": [
                        "mode"
                      ],
                      "properties": {
                        "mode": {
                          "description": "Mode is the required authentication mode for the allowed traffic, if any.",
                          "type": "string",
                          "enum": [
                            "disabled",
                            "required",
                            "test-always-fail"
                          ]
                        }
                      }
                    },
                    "icmps": {
                      "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is allowed to initiate type 8 ICMP connections.",
                      "type": "array",
                      "items": {
                        "description": "ICMPRule is a list of ICMP fields.",
                        "type": "object",
                        "properties": {
                          "fields": {
                            "description": "Fields is a list of ICMP fields.",
                            "type": "array",
                            "items": {
                              "description": "ICMPField is a ICMP field.",
                              "type": "object",
                              "required": [
                                "type"
                              ],
                              "properties": {
                                "family": {
                                  "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                  "type": "string",
                                  "enum": [
                                    "IPv4",
                                    "IPv6"
                                  ]
                                },
                                "type": {
                                  "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                  "type": "integer",
                                  "maximum": 255,
                                  "minimum": 0
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "toCIDR": {
                      "description": "ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules.  This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24",
                      "type": "array",
                      "items": {
                        "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                        "type": "string",
                        "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                      }
                    },
                    "toCIDRSet": {
                      "description": "ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.",
                      "type": "array",
                      "items": {
                        "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                        "type": "object",
                        "properties": {
                          "cidr": {
                            "description": "CIDR is a CIDR prefix / IP Block.",
                            "type": "string",
                            "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                          },
                          "cidrGroupRef": {
                            "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                            "type": "string",
                            "maxLength": 253,
                            "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                          },
                          "except": {
                            "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                            "type": "array",
                            "items": {
                              "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                              "type": "string",
                              "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                            }
                          }
                        }
                      }
                    },
                    "toEndpoints": {
                      "description": "ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\".",
                      "type": "array",
                      "items": {
                        "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                        "type": "object",
                        "properties": {
                          "matchExpressions": {
                            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                            "type": "array",
                            "items": {
                              "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                              "type": "object",
                              "required": [
                                "key",
                                "operator"
                              ],
                              "properties": {
                                "key": {
                                  "description": "key is the label key that the selector applies to.",
                                  "type": "string"
                                },
                                "operator": {
                                  "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                  "type": "string",
                                  "enum": [
                                    "In",
                                    "NotIn",
                                    "Exists",
                                    "DoesNotExist"
                                  ]
                                },
                                "values": {
                                  "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          },
                          "matchLabels": {
                            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                            "type": "object",
                            "additionalProperties": {
                              "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                              "type": "string",
                              "maxLength": 63,
                              "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                            }
                          }
                        }
                      }
                    },
                    "toEntities": {
                      "description": "ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`, `health`,`unmanaged` and `all`.",
                      "type": "array",
                      "items": {
                        "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                        "type": "string",
                        "enum": [
                          "all",
                          "world",
                          "cluster",
                          "host",
                          "init",
                          "ingress",
                          "unmanaged",
                          "remote-node",
                          "health",
                          "none",
                          "kube-apiserver"
                        ]
                      }
                    },
                    "toFQDNs": {
                      "description": "ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result from DNS resolution of `ToFQDN.MatchName`s are added to the same EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and L7 rules within this EgressRule will also apply to these IPs. The DNS -> IP mapping is re-resolved periodically from within the cilium-agent, and the IPs in the DNS response are effected in the policy for selected pods as-is (i.e. the list of IPs is not modified in any way). Note: An explicit rule to allow for DNS traffic is needed for the pods, as ToFQDN counts as an egress rule and will enforce egress policy when PolicyEnforcment=default. Note: If the resolved IPs are IPs within the kubernetes cluster, the ToFQDN rule will not apply to that IP. Note: ToFQDN cannot occur in the same policy as other To* rules.",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "matchName": {
                            "description": "MatchName matches literal DNS names. A trailing \".\" is automatically added when missing.",
                            "type": "string",
                            "pattern": "^([-a-zA-Z0-9_]+[.]?)+$"
                          },
                          "matchPattern": {
                            "description": "MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"*\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"*\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: `*.cilium.io` matches subomains of cilium at that level   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with \"cilium.io\"   except those containing \".\" separator, subcilium.io and sub-cilium.io match,   www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\"   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,   blog.cilium.io, cilium.io and google.com do not",
                            "type": "string",
                            "pattern": "^([-a-zA-Z0-9_*]+[.]?)+$"
                          }
                        }
                      }
                    },
                    "toGroups": {
                      "description": "ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws:     securityGroupsIds:     - 'sg-XXXXXXXXXXXXX'",
                      "type": "array",
                      "items": {
                        "description": "ToGroups structure to store all kinds of new integrations that needs a new derivative policy.",
                        "type": "object",
                        "properties": {
                          "aws": {
                            "description": "AWSGroup is an structure that can be used to whitelisting information from AWS integration",
                            "type": "object",
                            "properties": {
                              "labels": {
                                "type": "object",
                                "additionalProperties": {
                                  "type": "string"
                                }
                              },
                              "region": {
                                "type": "string"
                              },
                              "securityGroupsIds": {
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              },
                              "securityGroupsNames": {
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "toPorts": {
                      "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is allowed to initiate connections to destination port 8080/tcp",
                      "type": "array",
                      "items": {
                        "description": "PortRule is a list of ports/protocol combinations with optional Layer 7 rules which must be met.",
                        "type": "object",
                        "properties": {
                          "listener": {
                            "description": "listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.",
                            "type": "object",
                            "required": [
                              "envoyConfig",
                              "name"
                            ],
                            "properties": {
                              "envoyConfig": {
                                "description": "EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.",
                                "type": "object",
                                "required": [
                                  "name"
                                ],
                                "properties": {
                                  "kind": {
                                    "description": "Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.",
                                    "type": "string",
                                    "enum": [
                                      "CiliumEnvoyConfig",
                                      "CiliumClusterwideEnvoyConfig"
                                    ]
                                  },
                                  "name": {
                                    "description": "Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where the listener is defined in.",
                                    "type": "string",
                                    "minLength": 1
                                  }
                                }
                              },
                              "name": {
                                "description": "Name is the name of the listener.",
                                "type": "string",
                                "minLength": 1
                              }
                            }
                          },
                          "originatingTLS": {
                            "description": "OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.",
                            "type": "object",
                            "required": [
                              "secret"
                            ],
                            "properties": {
                              "certificate": {
                                "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                "type": "string"
                              },
                              "privateKey": {
                                "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                "type": "string"
                              },
                              "secret": {
                                "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                "type": "object",
                                "required": [
                                  "name"
                                ],
                                "properties": {
                                  "name": {
                                    "description": "Name is the name of the secret.",
                                    "type": "string"
                                  },
                                  "namespace": {
                                    "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                    "type": "string"
                                  }
                                }
                              },
                              "trustedCA": {
                                "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                "type": "string"
                              }
                            }
                          },
                          "ports": {
                            "description": "Ports is a list of L4 port/protocol",
                            "type": "array",
                            "items": {
                              "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                              "type": "object",
                              "required": [
                                "port"
                              ],
                              "properties": {
                                "port": {
                                  "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                  "type": "string",
                                  "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                },
                                "protocol": {
                                  "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                  "type": "string",
                                  "enum": [
                                    "TCP",
                                    "UDP",
                                    "SCTP",
                                    "ANY"
                                  ]
                                }
                              }
                            }
                          },
                          "rules": {
                            "description": "Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.",
                            "type": "object",
                            "properties": {
                              "dns": {
                                "description": "DNS-specific rules.",
                                "type": "array",
                                "items": {
                                  "description": "PortRuleDNS is a list of allowed DNS lookups.",
                                  "type": "object",
                                  "properties": {
                                    "matchName": {
                                      "description": "MatchName matches literal DNS names. A trailing \".\" is automatically added when missing.",
                                      "type": "string",
                                      "pattern": "^([-a-zA-Z0-9_]+[.]?)+$"
                                    },
                                    "matchPattern": {
                                      "description": "MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"*\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"*\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: `*.cilium.io` matches subomains of cilium at that level   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with \"cilium.io\"   except those containing \".\" separator, subcilium.io and sub-cilium.io match,   www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\"   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,   blog.cilium.io, cilium.io and google.com do not",
                                      "type": "string",
                                      "pattern": "^([-a-zA-Z0-9_*]+[.]?)+$"
                                    }
                                  }
                                }
                              },
                              "http": {
                                "description": "HTTP specific rules.",
                                "type": "array",
                                "items": {
                                  "description": "PortRuleHTTP is a list of HTTP protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect. \n All fields of this type are extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986.",
                                  "type": "object",
                                  "properties": {
                                    "headerMatches": {
                                      "description": "HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match.",
                                      "type": "array",
                                      "items": {
                                        "description": "HeaderMatch extends the HeaderValue for matching requirement of a named header field against an immediate string, a secret value, or a regex.  If none of the optional fields is present, then the header value is not matched, only presence of the header is enough.",
                                        "type": "object",
                                        "required": [
                                          "name"
                                        ],
                                        "properties": {
                                          "mismatch": {
                                            "description": "Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.",
                                            "type": "string",
                                            "enum": [
                                              "LOG",
                                              "ADD",
                                              "DELETE",
                                              "REPLACE"
                                            ]
                                          },
                                          "name": {
                                            "description": "Name identifies the header.",
                                            "type": "string"
                                          },
                                          "secret": {
                                            "description": "Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no \"Value\" specified, the match will fail.",
                                            "type": "object",
                                            "required": [
                                              "name"
                                            ],
                                            "properties": {
                                              "name": {
                                                "description": "Name is the name of the secret.",
                                                "type": "string"
                                              },
                                              "namespace": {
                                                "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                                "type": "string"
                                              }
                                            }
                                          },
                                          "value": {
                                            "description": "Value matches the exact value of the header. Can be specified either alone or together with \"Secret\"; will be used as the header value if the secret can not be found in the latter case.",
                                            "type": "string"
                                          }
                                        }
                                      }
                                    },
                                    "headers": {
                                      "description": "Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present.",
                                      "type": "array",
                                      "items": {
                                        "type": "string"
                                      }
                                    },
                                    "host": {
                                      "description": "Host is an extended POSIX regex matched against the host header of a request, e.g. \"foo.com\" \n If omitted or empty, the value of the host header is ignored.",
                                      "type": "string",
                                      "format": "idn-hostname"
                                    },
                                    "method": {
                                      "description": "Method is an extended POSIX regex matched against the method of a request, e.g. \"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\", ... \n If omitted or empty, all methods are allowed.",
                                      "type": "string"
                                    },
                                    "path": {
                                      "description": "Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986. \n If omitted or empty, all paths are all allowed.",
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "kafka": {
                                "description": "Kafka-specific rules.",
                                "type": "array",
                                "items": {
                                  "description": "PortRule is a list of Kafka protocol constraints. All fields are optional, if all fields are empty or missing, the rule will match all Kafka messages.",
                                  "type": "object",
                                  "properties": {
                                    "apiKey": {
                                      "description": "APIKey is a case-insensitive string matched against the key of a request, e.g. \"produce\", \"fetch\", \"createtopic\", \"deletetopic\", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys \n If omitted or empty, and if Role is not specified, then all keys are allowed.",
                                      "type": "string"
                                    },
                                    "apiVersion": {
                                      "description": "APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer. \n If omitted or empty, all versions are allowed.",
                                      "type": "string"
                                    },
                                    "clientID": {
                                      "description": "ClientID is the client identifier as provided in the request. \n From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client. \n If omitted or empty, all client identifiers are allowed.",
                                      "type": "string"
                                    },
                                    "role": {
                                      "description": "Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as \"produce\" or \"consume\". A Role automatically expands into all APIKeys required to perform the specified higher-level operation. \n The following values are supported:  - \"produce\": Allow producing to the topics specified in the rule  - \"consume\": Allow consuming from the topics specified in the rule \n This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule. \n If omitted or empty, and if APIKey is not specified, then all keys are allowed.",
                                      "type": "string",
                                      "enum": [
                                        "produce",
                                        "consume"
                                      ]
                                    },
                                    "topic": {
                                      "description": "Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected. \n This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _. \n Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255. \n If omitted or empty, all topics are allowed.",
                                      "type": "string",
                                      "maxLength": 255
                                    }
                                  }
                                }
                              },
                              "l7": {
                                "description": "Key-value pair rules.",
                                "type": "array",
                                "items": {
                                  "description": "PortRuleL7 is a list of key-value pairs interpreted by a L7 protocol as protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect.",
                                  "type": "object",
                                  "additionalProperties": {
                                    "type": "string"
                                  }
                                }
                              },
                              "l7proto": {
                                "description": "Name of the L7 protocol for which the Key-value pair rules apply.",
                                "type": "string"
                              }
                            }
                          },
                          "serverNames": {
                            "description": "ServerNames is a list of allowed TLS SNI values. If not empty, then TLS must be present and one of the provided SNIs must be indicated in the TLS handshake.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "terminatingTLS": {
                            "description": "TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.",
                            "type": "object",
                            "required": [
                              "secret"
                            ],
                            "properties": {
                              "certificate": {
                                "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                "type": "string"
                              },
                              "privateKey": {
                                "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                "type": "string"
                              },
                              "secret": {
                                "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                "type": "object",
                                "required": [
                                  "name"
                                ],
                                "properties": {
                                  "name": {
                                    "description": "Name is the name of the secret.",
                                    "type": "string"
                                  },
                                  "namespace": {
                                    "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                    "type": "string"
                                  }
                                }
                              },
                              "trustedCA": {
                                "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    },
                    "toRequires": {
                      "description": "ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\".",
                      "type": "array",
                      "items": {
                        "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                        "type": "object",
                        "properties": {
                          "matchExpressions": {
                            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                            "type": "array",
                            "items": {
                              "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                              "type": "object",
                              "required": [
                                "key",
                                "operator"
                              ],
                              "properties": {
                                "key": {
                                  "description": "key is the label key that the selector applies to.",
                                  "type": "string"
                                },
                                "operator": {
                                  "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                  "type": "string",
                                  "enum": [
                                    "In",
                                    "NotIn",
                                    "Exists",
                                    "DoesNotExist"
                                  ]
                                },
                                "values": {
                                  "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          },
                          "matchLabels": {
                            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                            "type": "object",
                            "additionalProperties": {
                              "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                              "type": "string",
                              "maxLength": 63,
                              "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                            }
                          }
                        }
                      }
                    },
                    "toServices": {
                      "description": "ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service",
                      "type": "array",
                      "items": {
                        "description": "Service wraps around selectors for services",
                        "type": "object",
                        "properties": {
                          "k8sService": {
                            "description": "K8sService selects service by name and namespace pair",
                            "type": "object",
                            "properties": {
                              "namespace": {
                                "type": "string"
                              },
                              "serviceName": {
                                "type": "string"
                              }
                            }
                          },
                          "k8sServiceSelector": {
                            "description": "K8sServiceSelector selects services by k8s labels and namespace",
                            "type": "object",
                            "required": [
                              "selector"
                            ],
                            "properties": {
                              "namespace": {
                                "type": "string"
                              },
                              "selector": {
                                "description": "ServiceSelector is a label selector for k8s services",
                                "type": "object",
                                "properties": {
                                  "matchExpressions": {
                                    "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                    "type": "array",
                                    "items": {
                                      "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                      "type": "object",
                                      "required": [
                                        "key",
                                        "operator"
                                      ],
                                      "properties": {
                                        "key": {
                                          "description": "key is the label key that the selector applies to.",
                                          "type": "string"
                                        },
                                        "operator": {
                                          "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                          "type": "string",
                                          "enum": [
                                            "In",
                                            "NotIn",
                                            "Exists",
                                            "DoesNotExist"
                                          ]
                                        },
                                        "values": {
                                          "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                          "type": "array",
                                          "items": {
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  },
                                  "matchLabels": {
                                    "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                    "type": "object",
                                    "additionalProperties": {
                                      "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                      "type": "string",
                                      "maxLength": 63,
                                      "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              },
              "egressDeny": {
                "description": "EgressDeny is a list of EgressDenyRule which are enforced at egress. Any rule inserted here will be denied regardless of the allowed egress rules in the 'egress' field. If omitted or empty, this rule does not apply at egress.",
                "type": "array",
                "items": {
                  "description": "EgressDenyRule contains all rule types which can be applied at egress, i.e. network traffic that originates inside the endpoint and exits the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members of the structure are specified, then all members     must match in order for the rule to take effect. The exception to this     rule is the ToRequires member; the effects of any Requires field in any     rule will apply to all other rules as well. \n   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are     mutually exclusive. Only one of these members may be present within an     individual rule.",
                  "type": "object",
                  "properties": {
                    "icmps": {
                      "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is not allowed to initiate type 8 ICMP connections.",
                      "type": "array",
                      "items": {
                        "description": "ICMPRule is a list of ICMP fields.",
                        "type": "object",
                        "properties": {
                          "fields": {
                            "description": "Fields is a list of ICMP fields.",
                            "type": "array",
                            "items": {
                              "description": "ICMPField is a ICMP field.",
                              "type": "object",
                              "required": [
                                "type"
                              ],
                              "properties": {
                                "family": {
                                  "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                  "type": "string",
                                  "enum": [
                                    "IPv4",
                                    "IPv6"
                                  ]
                                },
                                "type": {
                                  "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                  "type": "integer",
                                  "maximum": 255,
                                  "minimum": 0
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "toCIDR": {
                      "description": "ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules.  This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24",
                      "type": "array",
                      "items": {
                        "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                        "type": "string",
                        "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                      }
                    },
                    "toCIDRSet": {
                      "description": "ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.",
                      "type": "array",
                      "items": {
                        "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                        "type": "object",
                        "properties": {
                          "cidr": {
                            "description": "CIDR is a CIDR prefix / IP Block.",
                            "type": "string",
                            "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                          },
                          "cidrGroupRef": {
                            "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                            "type": "string",
                            "maxLength": 253,
                            "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                          },
                          "except": {
                            "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                            "type": "array",
                            "items": {
                              "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                              "type": "string",
                              "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                            }
                          }
                        }
                      }
                    },
                    "toEndpoints": {
                      "description": "ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\".",
                      "type": "array",
                      "items": {
                        "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                        "type": "object",
                        "properties": {
                          "matchExpressions": {
                            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                            "type": "array",
                            "items": {
                              "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                              "type": "object",
                              "required": [
                                "key",
                                "operator"
                              ],
                              "properties": {
                                "key": {
                                  "description": "key is the label key that the selector applies to.",
                                  "type": "string"
                                },
                                "operator": {
                                  "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                  "type": "string",
                                  "enum": [
                                    "In",
                                    "NotIn",
                                    "Exists",
                                    "DoesNotExist"
                                  ]
                                },
                                "values": {
                                  "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          },
                          "matchLabels": {
                            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                            "type": "object",
                            "additionalProperties": {
                              "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                              "type": "string",
                              "maxLength": 63,
                              "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                            }
                          }
                        }
                      }
                    },
                    "toEntities": {
                      "description": "ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`, `health`,`unmanaged` and `all`.",
                      "type": "array",
                      "items": {
                        "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                        "type": "string",
                        "enum": [
                          "all",
                          "world",
                          "cluster",
                          "host",
                          "init",
                          "ingress",
                          "unmanaged",
                          "remote-node",
                          "health",
                          "none",
                          "kube-apiserver"
                        ]
                      }
                    },
                    "toGroups": {
                      "description": "ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws:     securityGroupsIds:     - 'sg-XXXXXXXXXXXXX'",
                      "type": "array",
                      "items": {
                        "description": "ToGroups structure to store all kinds of new integrations that needs a new derivative policy.",
                        "type": "object",
                        "properties": {
                          "aws": {
                            "description": "AWSGroup is an structure that can be used to whitelisting information from AWS integration",
                            "type": "object",
                            "properties": {
                              "labels": {
                                "type": "object",
                                "additionalProperties": {
                                  "type": "string"
                                }
                              },
                              "region": {
                                "type": "string"
                              },
                              "securityGroupsIds": {
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              },
                              "securityGroupsNames": {
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "toPorts": {
                      "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is not allowed to initiate connections to destination port 8080/tcp",
                      "type": "array",
                      "items": {
                        "description": "PortDenyRule is a list of ports/protocol that should be used for deny policies. This structure lacks the L7Rules since it's not supported in deny policies.",
                        "type": "object",
                        "properties": {
                          "ports": {
                            "description": "Ports is a list of L4 port/protocol",
                            "type": "array",
                            "items": {
                              "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                              "type": "object",
                              "required": [
                                "port"
                              ],
                              "properties": {
                                "port": {
                                  "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                  "type": "string",
                                  "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                },
                                "protocol": {
                                  "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                  "type": "string",
                                  "enum": [
                                    "TCP",
                                    "UDP",
                                    "SCTP",
                                    "ANY"
                                  ]
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "toRequires": {
                      "description": "ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\".",
                      "type": "array",
                      "items": {
                        "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                        "type": "object",
                        "properties": {
                          "matchExpressions": {
                            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                            "type": "array",
                            "items": {
                              "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                              "type": "object",
                              "required": [
                                "key",
                                "operator"
                              ],
                              "properties": {
                                "key": {
                                  "description": "key is the label key that the selector applies to.",
                                  "type": "string"
                                },
                                "operator": {
                                  "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                  "type": "string",
                                  "enum": [
                                    "In",
                                    "NotIn",
                                    "Exists",
                                    "DoesNotExist"
                                  ]
                                },
                                "values": {
                                  "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          },
                          "matchLabels": {
                            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                            "type": "object",
                            "additionalProperties": {
                              "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                              "type": "string",
                              "maxLength": 63,
                              "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                            }
                          }
                        }
                      }
                    },
                    "toServices": {
                      "description": "ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service",
                      "type": "array",
                      "items": {
                        "description": "Service wraps around selectors for services",
                        "type": "object",
                        "properties": {
                          "k8sService": {
                            "description": "K8sService selects service by name and namespace pair",
                            "type": "object",
                            "properties": {
                              "namespace": {
                                "type": "string"
                              },
                              "serviceName": {
                                "type": "string"
                              }
                            }
                          },
                          "k8sServiceSelector": {
                            "description": "K8sServiceSelector selects services by k8s labels and namespace",
                            "type": "object",
                            "required": [
                              "selector"
                            ],
                            "properties": {
                              "namespace": {
                                "type": "string"
                              },
                              "selector": {
                                "description": "ServiceSelector is a label selector for k8s services",
                                "type": "object",
                                "properties": {
                                  "matchExpressions": {
                                    "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                    "type": "array",
                                    "items": {
                                      "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                      "type": "object",
                                      "required": [
                                        "key",
                                        "operator"
                                      ],
                                      "properties": {
                                        "key": {
                                          "description": "key is the label key that the selector applies to.",
                                          "type": "string"
                                        },
                                        "operator": {
                                          "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                          "type": "string",
                                          "enum": [
                                            "In",
                                            "NotIn",
                                            "Exists",
                                            "DoesNotExist"
                                          ]
                                        },
                                        "values": {
                                          "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                          "type": "array",
                                          "items": {
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  },
                                  "matchLabels": {
                                    "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                    "type": "object",
                                    "additionalProperties": {
                                      "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                      "type": "string",
                                      "maxLength": 63,
                                      "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              },
              "endpointSelector": {
                "description": "EndpointSelector selects all endpoints which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive.",
                "type": "object",
                "properties": {
                  "matchExpressions": {
                    "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                    "type": "array",
                    "items": {
                      "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                      "type": "object",
                      "required": [
                        "key",
                        "operator"
                      ],
                      "properties": {
                        "key": {
                          "description": "key is the label key that the selector applies to.",
                          "type": "string"
                        },
                        "operator": {
                          "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                          "type": "string",
                          "enum": [
                            "In",
                            "NotIn",
                            "Exists",
                            "DoesNotExist"
                          ]
                        },
                        "values": {
                          "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        }
                      }
                    }
                  },
                  "matchLabels": {
                    "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                    "type": "object",
                    "additionalProperties": {
                      "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                      "type": "string",
                      "maxLength": 63,
                      "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                    }
                  }
                }
              },
              "ingress": {
                "description": "Ingress is a list of IngressRule which are enforced at ingress. If omitted or empty, this rule does not apply at ingress.",
                "type": "array",
                "items": {
                  "description": "IngressRule contains all rule types which can be applied at ingress, i.e. network traffic that originates outside of the endpoint and is entering the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members are set, all of them need to match in order for     the rule to take effect. The exception to this rule is FromRequires field;     the effects of any Requires field in any rule will apply to all other     rules as well. \n   - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually     exclusive. Only one of these members may be present within an individual     rule.",
                  "type": "object",
                  "properties": {
                    "authentication": {
                      "description": "Authentication is the required authentication type for the allowed traffic, if any.",
                      "type": "object",
                      "required": [
                        "mode"
                      ],
                      "properties": {
                        "mode": {
                          "description": "Mode is the required authentication mode for the allowed traffic, if any.",
                          "type": "string",
                          "enum": [
                            "disabled",
                            "required",
                            "test-always-fail"
                          ]
                        }
                      }
                    },
                    "fromCIDR": {
                      "description": "FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do *not* originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field.  This will match on the source IP address of incoming connections. Adding  a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.3.9.1",
                      "type": "array",
                      "items": {
                        "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                        "type": "string",
                        "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                      }
                    },
                    "fromCIDRSet": {
                      "description": "FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.",
                      "type": "array",
                      "items": {
                        "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                        "type": "object",
                        "properties": {
                          "cidr": {
                            "description": "CIDR is a CIDR prefix / IP Block.",
                            "type": "string",
                            "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                          },
                          "cidrGroupRef": {
                            "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                            "type": "string",
                            "maxLength": 253,
                            "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                          },
                          "except": {
                            "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                            "type": "array",
                            "items": {
                              "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                              "type": "string",
                              "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                            }
                          }
                        }
                      }
                    },
                    "fromEndpoints": {
                      "description": "FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\".",
                      "type": "array",
                      "items": {
                        "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                        "type": "object",
                        "properties": {
                          "matchExpressions": {
                            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                            "type": "array",
                            "items": {
                              "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                              "type": "object",
                              "required": [
                                "key",
                                "operator"
                              ],
                              "properties": {
                                "key": {
                                  "description": "key is the label key that the selector applies to.",
                                  "type": "string"
                                },
                                "operator": {
                                  "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                  "type": "string",
                                  "enum": [
                                    "In",
                                    "NotIn",
                                    "Exists",
                                    "DoesNotExist"
                                  ]
                                },
                                "values": {
                                  "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          },
                          "matchLabels": {
                            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                            "type": "object",
                            "additionalProperties": {
                              "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                              "type": "string",
                              "maxLength": 63,
                              "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                            }
                          }
                        }
                      }
                    },
                    "fromEntities": {
                      "description": "FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are `world`, `cluster` and `host`",
                      "type": "array",
                      "items": {
                        "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                        "type": "string",
                        "enum": [
                          "all",
                          "world",
                          "cluster",
                          "host",
                          "init",
                          "ingress",
                          "unmanaged",
                          "remote-node",
                          "health",
                          "none",
                          "kube-apiserver"
                        ]
                      }
                    },
                    "fromRequires": {
                      "description": "FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\".",
                      "type": "array",
                      "items": {
                        "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                        "type": "object",
                        "properties": {
                          "matchExpressions": {
                            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                            "type": "array",
                            "items": {
                              "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                              "type": "object",
                              "required": [
                                "key",
                                "operator"
                              ],
                              "properties": {
                                "key": {
                                  "description": "key is the label key that the selector applies to.",
                                  "type": "string"
                                },
                                "operator": {
                                  "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                  "type": "string",
                                  "enum": [
                                    "In",
                                    "NotIn",
                                    "Exists",
                                    "DoesNotExist"
                                  ]
                                },
                                "values": {
                                  "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          },
                          "matchLabels": {
                            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                            "type": "object",
                            "additionalProperties": {
                              "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                              "type": "string",
                              "maxLength": 63,
                              "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                            }
                          }
                        }
                      }
                    },
                    "icmps": {
                      "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming type 8 ICMP connections.",
                      "type": "array",
                      "items": {
                        "description": "ICMPRule is a list of ICMP fields.",
                        "type": "object",
                        "properties": {
                          "fields": {
                            "description": "Fields is a list of ICMP fields.",
                            "type": "array",
                            "items": {
                              "description": "ICMPField is a ICMP field.",
                              "type": "object",
                              "required": [
                                "type"
                              ],
                              "properties": {
                                "family": {
                                  "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                  "type": "string",
                                  "enum": [
                                    "IPv4",
                                    "IPv6"
                                  ]
                                },
                                "type": {
                                  "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                  "type": "integer",
                                  "maximum": 255,
                                  "minimum": 0
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "toPorts": {
                      "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming connections on port 80/tcp.",
                      "type": "array",
                      "items": {
                        "description": "PortRule is a list of ports/protocol combinations with optional Layer 7 rules which must be met.",
                        "type": "object",
                        "properties": {
                          "listener": {
                            "description": "listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.",
                            "type": "object",
                            "required": [
                              "envoyConfig",
                              "name"
                            ],
                            "properties": {
                              "envoyConfig": {
                                "description": "EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.",
                                "type": "object",
                                "required": [
                                  "name"
                                ],
                                "properties": {
                                  "kind": {
                                    "description": "Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.",
                                    "type": "string",
                                    "enum": [
                                      "CiliumEnvoyConfig",
                                      "CiliumClusterwideEnvoyConfig"
                                    ]
                                  },
                                  "name": {
                                    "description": "Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where the listener is defined in.",
                                    "type": "string",
                                    "minLength": 1
                                  }
                                }
                              },
                              "name": {
                                "description": "Name is the name of the listener.",
                                "type": "string",
                                "minLength": 1
                              }
                            }
                          },
                          "originatingTLS": {
                            "description": "OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.",
                            "type": "object",
                            "required": [
                              "secret"
                            ],
                            "properties": {
                              "certificate": {
                                "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                "type": "string"
                              },
                              "privateKey": {
                                "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                "type": "string"
                              },
                              "secret": {
                                "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                "type": "object",
                                "required": [
                                  "name"
                                ],
                                "properties": {
                                  "name": {
                                    "description": "Name is the name of the secret.",
                                    "type": "string"
                                  },
                                  "namespace": {
                                    "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                    "type": "string"
                                  }
                                }
                              },
                              "trustedCA": {
                                "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                "type": "string"
                              }
                            }
                          },
                          "ports": {
                            "description": "Ports is a list of L4 port/protocol",
                            "type": "array",
                            "items": {
                              "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                              "type": "object",
                              "required": [
                                "port"
                              ],
                              "properties": {
                                "port": {
                                  "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                  "type": "string",
                                  "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                },
                                "protocol": {
                                  "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                  "type": "string",
                                  "enum": [
                                    "TCP",
                                    "UDP",
                                    "SCTP",
                                    "ANY"
                                  ]
                                }
                              }
                            }
                          },
                          "rules": {
                            "description": "Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.",
                            "type": "object",
                            "properties": {
                              "dns": {
                                "description": "DNS-specific rules.",
                                "type": "array",
                                "items": {
                                  "description": "PortRuleDNS is a list of allowed DNS lookups.",
                                  "type": "object",
                                  "properties": {
                                    "matchName": {
                                      "description": "MatchName matches literal DNS names. A trailing \".\" is automatically added when missing.",
                                      "type": "string",
                                      "pattern": "^([-a-zA-Z0-9_]+[.]?)+$"
                                    },
                                    "matchPattern": {
                                      "description": "MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"*\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"*\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: `*.cilium.io` matches subomains of cilium at that level   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with \"cilium.io\"   except those containing \".\" separator, subcilium.io and sub-cilium.io match,   www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\"   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,   blog.cilium.io, cilium.io and google.com do not",
                                      "type": "string",
                                      "pattern": "^([-a-zA-Z0-9_*]+[.]?)+$"
                                    }
                                  }
                                }
                              },
                              "http": {
                                "description": "HTTP specific rules.",
                                "type": "array",
                                "items": {
                                  "description": "PortRuleHTTP is a list of HTTP protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect. \n All fields of this type are extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986.",
                                  "type": "object",
                                  "properties": {
                                    "headerMatches": {
                                      "description": "HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match.",
                                      "type": "array",
                                      "items": {
                                        "description": "HeaderMatch extends the HeaderValue for matching requirement of a named header field against an immediate string, a secret value, or a regex.  If none of the optional fields is present, then the header value is not matched, only presence of the header is enough.",
                                        "type": "object",
                                        "required": [
                                          "name"
                                        ],
                                        "properties": {
                                          "mismatch": {
                                            "description": "Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.",
                                            "type": "string",
                                            "enum": [
                                              "LOG",
                                              "ADD",
                                              "DELETE",
                                              "REPLACE"
                                            ]
                                          },
                                          "name": {
                                            "description": "Name identifies the header.",
                                            "type": "string"
                                          },
                                          "secret": {
                                            "description": "Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no \"Value\" specified, the match will fail.",
                                            "type": "object",
                                            "required": [
                                              "name"
                                            ],
                                            "properties": {
                                              "name": {
                                                "description": "Name is the name of the secret.",
                                                "type": "string"
                                              },
                                              "namespace": {
                                                "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                                "type": "string"
                                              }
                                            }
                                          },
                                          "value": {
                                            "description": "Value matches the exact value of the header. Can be specified either alone or together with \"Secret\"; will be used as the header value if the secret can not be found in the latter case.",
                                            "type": "string"
                                          }
                                        }
                                      }
                                    },
                                    "headers": {
                                      "description": "Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present.",
                                      "type": "array",
                                      "items": {
                                        "type": "string"
                                      }
                                    },
                                    "host": {
                                      "description": "Host is an extended POSIX regex matched against the host header of a request, e.g. \"foo.com\" \n If omitted or empty, the value of the host header is ignored.",
                                      "type": "string",
                                      "format": "idn-hostname"
                                    },
                                    "method": {
                                      "description": "Method is an extended POSIX regex matched against the method of a request, e.g. \"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\", ... \n If omitted or empty, all methods are allowed.",
                                      "type": "string"
                                    },
                                    "path": {
                                      "description": "Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986. \n If omitted or empty, all paths are all allowed.",
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "kafka": {
                                "description": "Kafka-specific rules.",
                                "type": "array",
                                "items": {
                                  "description": "PortRule is a list of Kafka protocol constraints. All fields are optional, if all fields are empty or missing, the rule will match all Kafka messages.",
                                  "type": "object",
                                  "properties": {
                                    "apiKey": {
                                      "description": "APIKey is a case-insensitive string matched against the key of a request, e.g. \"produce\", \"fetch\", \"createtopic\", \"deletetopic\", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys \n If omitted or empty, and if Role is not specified, then all keys are allowed.",
                                      "type": "string"
                                    },
                                    "apiVersion": {
                                      "description": "APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer. \n If omitted or empty, all versions are allowed.",
                                      "type": "string"
                                    },
                                    "clientID": {
                                      "description": "ClientID is the client identifier as provided in the request. \n From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client. \n If omitted or empty, all client identifiers are allowed.",
                                      "type": "string"
                                    },
                                    "role": {
                                      "description": "Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as \"produce\" or \"consume\". A Role automatically expands into all APIKeys required to perform the specified higher-level operation. \n The following values are supported:  - \"produce\": Allow producing to the topics specified in the rule  - \"consume\": Allow consuming from the topics specified in the rule \n This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule. \n If omitted or empty, and if APIKey is not specified, then all keys are allowed.",
                                      "type": "string",
                                      "enum": [
                                        "produce",
                                        "consume"
                                      ]
                                    },
                                    "topic": {
                                      "description": "Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected. \n This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _. \n Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255. \n If omitted or empty, all topics are allowed.",
                                      "type": "string",
                                      "maxLength": 255
                                    }
                                  }
                                }
                              },
                              "l7": {
                                "description": "Key-value pair rules.",
                                "type": "array",
                                "items": {
                                  "description": "PortRuleL7 is a list of key-value pairs interpreted by a L7 protocol as protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect.",
                                  "type": "object",
                                  "additionalProperties": {
                                    "type": "string"
                                  }
                                }
                              },
                              "l7proto": {
                                "description": "Name of the L7 protocol for which the Key-value pair rules apply.",
                                "type": "string"
                              }
                            }
                          },
                          "serverNames": {
                            "description": "ServerNames is a list of allowed TLS SNI values. If not empty, then TLS must be present and one of the provided SNIs must be indicated in the TLS handshake.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "terminatingTLS": {
                            "description": "TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.",
                            "type": "object",
                            "required": [
                              "secret"
                            ],
                            "properties": {
                              "certificate": {
                                "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                "type": "string"
                              },
                              "privateKey": {
                                "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                "type": "string"
                              },
                              "secret": {
                                "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                "type": "object",
                                "required": [
                                  "name"
                                ],
                                "properties": {
                                  "name": {
                                    "description": "Name is the name of the secret.",
                                    "type": "string"
                                  },
                                  "namespace": {
                                    "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                    "type": "string"
                                  }
                                }
                              },
                              "trustedCA": {
                                "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              },
              "ingressDeny": {
                "description": "IngressDeny is a list of IngressDenyRule which are enforced at ingress. Any rule inserted here will be denied regardless of the allowed ingress rules in the 'ingress' field. If omitted or empty, this rule does not apply at ingress.",
                "type": "array",
                "items": {
                  "description": "IngressDenyRule contains all rule types which can be applied at ingress, i.e. network traffic that originates outside of the endpoint and is entering the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members are set, all of them need to match in order for     the rule to take effect. The exception to this rule is FromRequires field;     the effects of any Requires field in any rule will apply to all other     rules as well. \n   - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually     exclusive. Only one of these members may be present within an individual     rule.",
                  "type": "object",
                  "properties": {
                    "fromCIDR": {
                      "description": "FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do *not* originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field.  This will match on the source IP address of incoming connections. Adding  a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.3.9.1",
                      "type": "array",
                      "items": {
                        "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                        "type": "string",
                        "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                      }
                    },
                    "fromCIDRSet": {
                      "description": "FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.",
                      "type": "array",
                      "items": {
                        "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                        "type": "object",
                        "properties": {
                          "cidr": {
                            "description": "CIDR is a CIDR prefix / IP Block.",
                            "type": "string",
                            "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                          },
                          "cidrGroupRef": {
                            "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                            "type": "string",
                            "maxLength": 253,
                            "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                          },
                          "except": {
                            "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                            "type": "array",
                            "items": {
                              "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                              "type": "string",
                              "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                            }
                          }
                        }
                      }
                    },
                    "fromEndpoints": {
                      "description": "FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\".",
                      "type": "array",
                      "items": {
                        "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                        "type": "object",
                        "properties": {
                          "matchExpressions": {
                            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                            "type": "array",
                            "items": {
                              "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                              "type": "object",
                              "required": [
                                "key",
                                "operator"
                              ],
                              "properties": {
                                "key": {
                                  "description": "key is the label key that the selector applies to.",
                                  "type": "string"
                                },
                                "operator": {
                                  "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                  "type": "string",
                                  "enum": [
                                    "In",
                                    "NotIn",
                                    "Exists",
                                    "DoesNotExist"
                                  ]
                                },
                                "values": {
                                  "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          },
                          "matchLabels": {
                            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                            "type": "object",
                            "additionalProperties": {
                              "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                              "type": "string",
                              "maxLength": 63,
                              "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                            }
                          }
                        }
                      }
                    },
                    "fromEntities": {
                      "description": "FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are `world`, `cluster` and `host`",
                      "type": "array",
                      "items": {
                        "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                        "type": "string",
                        "enum": [
                          "all",
                          "world",
                          "cluster",
                          "host",
                          "init",
                          "ingress",
                          "unmanaged",
                          "remote-node",
                          "health",
                          "none",
                          "kube-apiserver"
                        ]
                      }
                    },
                    "fromRequires": {
                      "description": "FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\".",
                      "type": "array",
                      "items": {
                        "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                        "type": "object",
                        "properties": {
                          "matchExpressions": {
                            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                            "type": "array",
                            "items": {
                              "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                              "type": "object",
                              "required": [
                                "key",
                                "operator"
                              ],
                              "properties": {
                                "key": {
                                  "description": "key is the label key that the selector applies to.",
                                  "type": "string"
                                },
                                "operator": {
                                  "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                  "type": "string",
                                  "enum": [
                                    "In",
                                    "NotIn",
                                    "Exists",
                                    "DoesNotExist"
                                  ]
                                },
                                "values": {
                                  "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          },
                          "matchLabels": {
                            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                            "type": "object",
                            "additionalProperties": {
                              "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                              "type": "string",
                              "maxLength": 63,
                              "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                            }
                          }
                        }
                      }
                    },
                    "icmps": {
                      "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming type 8 ICMP connections.",
                      "type": "array",
                      "items": {
                        "description": "ICMPRule is a list of ICMP fields.",
                        "type": "object",
                        "properties": {
                          "fields": {
                            "description": "Fields is a list of ICMP fields.",
                            "type": "array",
                            "items": {
                              "description": "ICMPField is a ICMP field.",
                              "type": "object",
                              "required": [
                                "type"
                              ],
                              "properties": {
                                "family": {
                                  "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                  "type": "string",
                                  "enum": [
                                    "IPv4",
                                    "IPv6"
                                  ]
                                },
                                "type": {
                                  "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                  "type": "integer",
                                  "maximum": 255,
                                  "minimum": 0
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "toPorts": {
                      "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming connections on port 80/tcp.",
                      "type": "array",
                      "items": {
                        "description": "PortDenyRule is a list of ports/protocol that should be used for deny policies. This structure lacks the L7Rules since it's not supported in deny policies.",
                        "type": "object",
                        "properties": {
                          "ports": {
                            "description": "Ports is a list of L4 port/protocol",
                            "type": "array",
                            "items": {
                              "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                              "type": "object",
                              "required": [
                                "port"
                              ],
                              "properties": {
                                "port": {
                                  "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                  "type": "string",
                                  "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                },
                                "protocol": {
                                  "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                  "type": "string",
                                  "enum": [
                                    "TCP",
                                    "UDP",
                                    "SCTP",
                                    "ANY"
                                  ]
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              },
              "labels": {
                "description": "Labels is a list of optional strings which can be used to re-identify the rule or to store metadata. It is possible to lookup or delete strings based on labels. Labels are not required to be unique, multiple rules can have overlapping or identical labels.",
                "type": "array",
                "items": {
                  "description": "Label is the Cilium's representation of a container label.",
                  "type": "object",
                  "required": [
                    "key"
                  ],
                  "properties": {
                    "key": {
                      "type": "string"
                    },
                    "source": {
                      "description": "Source can be one of the above values (e.g.: LabelSourceContainer).",
                      "type": "string"
                    },
                    "value": {
                      "type": "string"
                    }
                  }
                }
              },
              "nodeSelector": {
                "description": "NodeSelector selects all nodes which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive. Can only be used in CiliumClusterwideNetworkPolicies.",
                "type": "object",
                "properties": {
                  "matchExpressions": {
                    "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                    "type": "array",
                    "items": {
                      "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                      "type": "object",
                      "required": [
                        "key",
                        "operator"
                      ],
                      "properties": {
                        "key": {
                          "description": "key is the label key that the selector applies to.",
                          "type": "string"
                        },
                        "operator": {
                          "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                          "type": "string",
                          "enum": [
                            "In",
                            "NotIn",
                            "Exists",
                            "DoesNotExist"
                          ]
                        },
                        "values": {
                          "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        }
                      }
                    }
                  },
                  "matchLabels": {
                    "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                    "type": "object",
                    "additionalProperties": {
                      "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                      "type": "string",
                      "maxLength": 63,
                      "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                    }
                  }
                }
              }
            }
          },
          "specs": {
            "description": "Specs is a list of desired Cilium specific rule specification.",
            "type": "array",
            "items": {
              "description": "Rule is a policy rule which must be applied to all endpoints which match the labels contained in the endpointSelector \n Each rule is split into an ingress section which contains all rules applicable at ingress, and an egress section applicable at egress. For rule types such as `L4Rule` and `CIDR` which can be applied at both ingress and egress, both ingress and egress side have to either specifically allow the connection or one side has to be omitted. \n Either ingress, egress, or both can be provided. If both ingress and egress are omitted, the rule has no effect.",
              "type": "object",
              "properties": {
                "description": {
                  "description": "Description is a free form string, it can be used by the creator of the rule to store human readable explanation of the purpose of this rule. Rules cannot be identified by comment.",
                  "type": "string"
                },
                "egress": {
                  "description": "Egress is a list of EgressRule which are enforced at egress. If omitted or empty, this rule does not apply at egress.",
                  "type": "array",
                  "items": {
                    "description": "EgressRule contains all rule types which can be applied at egress, i.e. network traffic that originates inside the endpoint and exits the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members of the structure are specified, then all members     must match in order for the rule to take effect. The exception to this     rule is the ToRequires member; the effects of any Requires field in any     rule will apply to all other rules as well. \n   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are     mutually exclusive. Only one of these members may be present within an     individual rule.",
                    "type": "object",
                    "properties": {
                      "authentication": {
                        "description": "Authentication is the required authentication type for the allowed traffic, if any.",
                        "type": "object",
                        "required": [
                          "mode"
                        ],
                        "properties": {
                          "mode": {
                            "description": "Mode is the required authentication mode for the allowed traffic, if any.",
                            "type": "string",
                            "enum": [
                              "disabled",
                              "required",
                              "test-always-fail"
                            ]
                          }
                        }
                      },
                      "icmps": {
                        "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is allowed to initiate type 8 ICMP connections.",
                        "type": "array",
                        "items": {
                          "description": "ICMPRule is a list of ICMP fields.",
                          "type": "object",
                          "properties": {
                            "fields": {
                              "description": "Fields is a list of ICMP fields.",
                              "type": "array",
                              "items": {
                                "description": "ICMPField is a ICMP field.",
                                "type": "object",
                                "required": [
                                  "type"
                                ],
                                "properties": {
                                  "family": {
                                    "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                    "type": "string",
                                    "enum": [
                                      "IPv4",
                                      "IPv6"
                                    ]
                                  },
                                  "type": {
                                    "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                    "type": "integer",
                                    "maximum": 255,
                                    "minimum": 0
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      "toCIDR": {
                        "description": "ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules.  This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24",
                        "type": "array",
                        "items": {
                          "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                          "type": "string",
                          "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                        }
                      },
                      "toCIDRSet": {
                        "description": "ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.",
                        "type": "array",
                        "items": {
                          "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                          "type": "object",
                          "properties": {
                            "cidr": {
                              "description": "CIDR is a CIDR prefix / IP Block.",
                              "type": "string",
                              "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                            },
                            "cidrGroupRef": {
                              "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                              "type": "string",
                              "maxLength": 253,
                              "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                            },
                            "except": {
                              "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                              "type": "array",
                              "items": {
                                "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                "type": "string",
                                "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                              }
                            }
                          }
                        }
                      },
                      "toEndpoints": {
                        "description": "ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\".",
                        "type": "array",
                        "items": {
                          "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                          "type": "object",
                          "properties": {
                            "matchExpressions": {
                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                              "type": "array",
                              "items": {
                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "key is the label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                    "type": "string",
                                    "enum": [
                                      "In",
                                      "NotIn",
                                      "Exists",
                                      "DoesNotExist"
                                    ]
                                  },
                                  "values": {
                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "matchLabels": {
                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                              "type": "object",
                              "additionalProperties": {
                                "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                "type": "string",
                                "maxLength": 63,
                                "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                              }
                            }
                          }
                        }
                      },
                      "toEntities": {
                        "description": "ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`, `health`,`unmanaged` and `all`.",
                        "type": "array",
                        "items": {
                          "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                          "type": "string",
                          "enum": [
                            "all",
                            "world",
                            "cluster",
                            "host",
                            "init",
                            "ingress",
                            "unmanaged",
                            "remote-node",
                            "health",
                            "none",
                            "kube-apiserver"
                          ]
                        }
                      },
                      "toFQDNs": {
                        "description": "ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result from DNS resolution of `ToFQDN.MatchName`s are added to the same EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and L7 rules within this EgressRule will also apply to these IPs. The DNS -> IP mapping is re-resolved periodically from within the cilium-agent, and the IPs in the DNS response are effected in the policy for selected pods as-is (i.e. the list of IPs is not modified in any way). Note: An explicit rule to allow for DNS traffic is needed for the pods, as ToFQDN counts as an egress rule and will enforce egress policy when PolicyEnforcment=default. Note: If the resolved IPs are IPs within the kubernetes cluster, the ToFQDN rule will not apply to that IP. Note: ToFQDN cannot occur in the same policy as other To* rules.",
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "matchName": {
                              "description": "MatchName matches literal DNS names. A trailing \".\" is automatically added when missing.",
                              "type": "string",
                              "pattern": "^([-a-zA-Z0-9_]+[.]?)+$"
                            },
                            "matchPattern": {
                              "description": "MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"*\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"*\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: `*.cilium.io` matches subomains of cilium at that level   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with \"cilium.io\"   except those containing \".\" separator, subcilium.io and sub-cilium.io match,   www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\"   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,   blog.cilium.io, cilium.io and google.com do not",
                              "type": "string",
                              "pattern": "^([-a-zA-Z0-9_*]+[.]?)+$"
                            }
                          }
                        }
                      },
                      "toGroups": {
                        "description": "ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws:     securityGroupsIds:     - 'sg-XXXXXXXXXXXXX'",
                        "type": "array",
                        "items": {
                          "description": "ToGroups structure to store all kinds of new integrations that needs a new derivative policy.",
                          "type": "object",
                          "properties": {
                            "aws": {
                              "description": "AWSGroup is an structure that can be used to whitelisting information from AWS integration",
                              "type": "object",
                              "properties": {
                                "labels": {
                                  "type": "object",
                                  "additionalProperties": {
                                    "type": "string"
                                  }
                                },
                                "region": {
                                  "type": "string"
                                },
                                "securityGroupsIds": {
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                },
                                "securityGroupsNames": {
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      "toPorts": {
                        "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is allowed to initiate connections to destination port 8080/tcp",
                        "type": "array",
                        "items": {
                          "description": "PortRule is a list of ports/protocol combinations with optional Layer 7 rules which must be met.",
                          "type": "object",
                          "properties": {
                            "listener": {
                              "description": "listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.",
                              "type": "object",
                              "required": [
                                "envoyConfig",
                                "name"
                              ],
                              "properties": {
                                "envoyConfig": {
                                  "description": "EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.",
                                  "type": "object",
                                  "required": [
                                    "name"
                                  ],
                                  "properties": {
                                    "kind": {
                                      "description": "Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.",
                                      "type": "string",
                                      "enum": [
                                        "CiliumEnvoyConfig",
                                        "CiliumClusterwideEnvoyConfig"
                                      ]
                                    },
                                    "name": {
                                      "description": "Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where the listener is defined in.",
                                      "type": "string",
                                      "minLength": 1
                                    }
                                  }
                                },
                                "name": {
                                  "description": "Name is the name of the listener.",
                                  "type": "string",
                                  "minLength": 1
                                }
                              }
                            },
                            "originatingTLS": {
                              "description": "OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.",
                              "type": "object",
                              "required": [
                                "secret"
                              ],
                              "properties": {
                                "certificate": {
                                  "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                  "type": "string"
                                },
                                "privateKey": {
                                  "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                  "type": "string"
                                },
                                "secret": {
                                  "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                  "type": "object",
                                  "required": [
                                    "name"
                                  ],
                                  "properties": {
                                    "name": {
                                      "description": "Name is the name of the secret.",
                                      "type": "string"
                                    },
                                    "namespace": {
                                      "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                      "type": "string"
                                    }
                                  }
                                },
                                "trustedCA": {
                                  "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                  "type": "string"
                                }
                              }
                            },
                            "ports": {
                              "description": "Ports is a list of L4 port/protocol",
                              "type": "array",
                              "items": {
                                "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                                "type": "object",
                                "required": [
                                  "port"
                                ],
                                "properties": {
                                  "port": {
                                    "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                    "type": "string",
                                    "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                  },
                                  "protocol": {
                                    "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                    "type": "string",
                                    "enum": [
                                      "TCP",
                                      "UDP",
                                      "SCTP",
                                      "ANY"
                                    ]
                                  }
                                }
                              }
                            },
                            "rules": {
                              "description": "Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.",
                              "type": "object",
                              "properties": {
                                "dns": {
                                  "description": "DNS-specific rules.",
                                  "type": "array",
                                  "items": {
                                    "description": "PortRuleDNS is a list of allowed DNS lookups.",
                                    "type": "object",
                                    "properties": {
                                      "matchName": {
                                        "description": "MatchName matches literal DNS names. A trailing \".\" is automatically added when missing.",
                                        "type": "string",
                                        "pattern": "^([-a-zA-Z0-9_]+[.]?)+$"
                                      },
                                      "matchPattern": {
                                        "description": "MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"*\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"*\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: `*.cilium.io` matches subomains of cilium at that level   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with \"cilium.io\"   except those containing \".\" separator, subcilium.io and sub-cilium.io match,   www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\"   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,   blog.cilium.io, cilium.io and google.com do not",
                                        "type": "string",
                                        "pattern": "^([-a-zA-Z0-9_*]+[.]?)+$"
                                      }
                                    }
                                  }
                                },
                                "http": {
                                  "description": "HTTP specific rules.",
                                  "type": "array",
                                  "items": {
                                    "description": "PortRuleHTTP is a list of HTTP protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect. \n All fields of this type are extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986.",
                                    "type": "object",
                                    "properties": {
                                      "headerMatches": {
                                        "description": "HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match.",
                                        "type": "array",
                                        "items": {
                                          "description": "HeaderMatch extends the HeaderValue for matching requirement of a named header field against an immediate string, a secret value, or a regex.  If none of the optional fields is present, then the header value is not matched, only presence of the header is enough.",
                                          "type": "object",
                                          "required": [
                                            "name"
                                          ],
                                          "properties": {
                                            "mismatch": {
                                              "description": "Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.",
                                              "type": "string",
                                              "enum": [
                                                "LOG",
                                                "ADD",
                                                "DELETE",
                                                "REPLACE"
                                              ]
                                            },
                                            "name": {
                                              "description": "Name identifies the header.",
                                              "type": "string"
                                            },
                                            "secret": {
                                              "description": "Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no \"Value\" specified, the match will fail.",
                                              "type": "object",
                                              "required": [
                                                "name"
                                              ],
                                              "properties": {
                                                "name": {
                                                  "description": "Name is the name of the secret.",
                                                  "type": "string"
                                                },
                                                "namespace": {
                                                  "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                                  "type": "string"
                                                }
                                              }
                                            },
                                            "value": {
                                              "description": "Value matches the exact value of the header. Can be specified either alone or together with \"Secret\"; will be used as the header value if the secret can not be found in the latter case.",
                                              "type": "string"
                                            }
                                          }
                                        }
                                      },
                                      "headers": {
                                        "description": "Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present.",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        }
                                      },
                                      "host": {
                                        "description": "Host is an extended POSIX regex matched against the host header of a request, e.g. \"foo.com\" \n If omitted or empty, the value of the host header is ignored.",
                                        "type": "string",
                                        "format": "idn-hostname"
                                      },
                                      "method": {
                                        "description": "Method is an extended POSIX regex matched against the method of a request, e.g. \"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\", ... \n If omitted or empty, all methods are allowed.",
                                        "type": "string"
                                      },
                                      "path": {
                                        "description": "Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986. \n If omitted or empty, all paths are all allowed.",
                                        "type": "string"
                                      }
                                    }
                                  }
                                },
                                "kafka": {
                                  "description": "Kafka-specific rules.",
                                  "type": "array",
                                  "items": {
                                    "description": "PortRule is a list of Kafka protocol constraints. All fields are optional, if all fields are empty or missing, the rule will match all Kafka messages.",
                                    "type": "object",
                                    "properties": {
                                      "apiKey": {
                                        "description": "APIKey is a case-insensitive string matched against the key of a request, e.g. \"produce\", \"fetch\", \"createtopic\", \"deletetopic\", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys \n If omitted or empty, and if Role is not specified, then all keys are allowed.",
                                        "type": "string"
                                      },
                                      "apiVersion": {
                                        "description": "APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer. \n If omitted or empty, all versions are allowed.",
                                        "type": "string"
                                      },
                                      "clientID": {
                                        "description": "ClientID is the client identifier as provided in the request. \n From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client. \n If omitted or empty, all client identifiers are allowed.",
                                        "type": "string"
                                      },
                                      "role": {
                                        "description": "Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as \"produce\" or \"consume\". A Role automatically expands into all APIKeys required to perform the specified higher-level operation. \n The following values are supported:  - \"produce\": Allow producing to the topics specified in the rule  - \"consume\": Allow consuming from the topics specified in the rule \n This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule. \n If omitted or empty, and if APIKey is not specified, then all keys are allowed.",
                                        "type": "string",
                                        "enum": [
                                          "produce",
                                          "consume"
                                        ]
                                      },
                                      "topic": {
                                        "description": "Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected. \n This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _. \n Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255. \n If omitted or empty, all topics are allowed.",
                                        "type": "string",
                                        "maxLength": 255
                                      }
                                    }
                                  }
                                },
                                "l7": {
                                  "description": "Key-value pair rules.",
                                  "type": "array",
                                  "items": {
                                    "description": "PortRuleL7 is a list of key-value pairs interpreted by a L7 protocol as protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect.",
                                    "type": "object",
                                    "additionalProperties": {
                                      "type": "string"
                                    }
                                  }
                                },
                                "l7proto": {
                                  "description": "Name of the L7 protocol for which the Key-value pair rules apply.",
                                  "type": "string"
                                }
                              }
                            },
                            "serverNames": {
                              "description": "ServerNames is a list of allowed TLS SNI values. If not empty, then TLS must be present and one of the provided SNIs must be indicated in the TLS handshake.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            },
                            "terminatingTLS": {
                              "description": "TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.",
                              "type": "object",
                              "required": [
                                "secret"
                              ],
                              "properties": {
                                "certificate": {
                                  "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                  "type": "string"
                                },
                                "privateKey": {
                                  "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                  "type": "string"
                                },
                                "secret": {
                                  "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                  "type": "object",
                                  "required": [
                                    "name"
                                  ],
                                  "properties": {
                                    "name": {
                                      "description": "Name is the name of the secret.",
                                      "type": "string"
                                    },
                                    "namespace": {
                                      "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                      "type": "string"
                                    }
                                  }
                                },
                                "trustedCA": {
                                  "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                  "type": "string"
                                }
                              }
                            }
                          }
                        }
                      },
                      "toRequires": {
                        "description": "ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\".",
                        "type": "array",
                        "items": {
                          "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                          "type": "object",
                          "properties": {
                            "matchExpressions": {
                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                              "type": "array",
                              "items": {
                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "key is the label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                    "type": "string",
                                    "enum": [
                                      "In",
                                      "NotIn",
                                      "Exists",
                                      "DoesNotExist"
                                    ]
                                  },
                                  "values": {
                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "matchLabels": {
                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                              "type": "object",
                              "additionalProperties": {
                                "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                "type": "string",
                                "maxLength": 63,
                                "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                              }
                            }
                          }
                        }
                      },
                      "toServices": {
                        "description": "ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service",
                        "type": "array",
                        "items": {
                          "description": "Service wraps around selectors for services",
                          "type": "object",
                          "properties": {
                            "k8sService": {
                              "description": "K8sService selects service by name and namespace pair",
                              "type": "object",
                              "properties": {
                                "namespace": {
                                  "type": "string"
                                },
                                "serviceName": {
                                  "type": "string"
                                }
                              }
                            },
                            "k8sServiceSelector": {
                              "description": "K8sServiceSelector selects services by k8s labels and namespace",
                              "type": "object",
                              "required": [
                                "selector"
                              ],
                              "properties": {
                                "namespace": {
                                  "type": "string"
                                },
                                "selector": {
                                  "description": "ServiceSelector is a label selector for k8s services",
                                  "type": "object",
                                  "properties": {
                                    "matchExpressions": {
                                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                      "type": "array",
                                      "items": {
                                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                        "type": "object",
                                        "required": [
                                          "key",
                                          "operator"
                                        ],
                                        "properties": {
                                          "key": {
                                            "description": "key is the label key that the selector applies to.",
                                            "type": "string"
                                          },
                                          "operator": {
                                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                            "type": "string",
                                            "enum": [
                                              "In",
                                              "NotIn",
                                              "Exists",
                                              "DoesNotExist"
                                            ]
                                          },
                                          "values": {
                                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "matchLabels": {
                                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                      "type": "object",
                                      "additionalProperties": {
                                        "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                        "type": "string",
                                        "maxLength": 63,
                                        "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "egressDeny": {
                  "description": "EgressDeny is a list of EgressDenyRule which are enforced at egress. Any rule inserted here will be denied regardless of the allowed egress rules in the 'egress' field. If omitted or empty, this rule does not apply at egress.",
                  "type": "array",
                  "items": {
                    "description": "EgressDenyRule contains all rule types which can be applied at egress, i.e. network traffic that originates inside the endpoint and exits the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members of the structure are specified, then all members     must match in order for the rule to take effect. The exception to this     rule is the ToRequires member; the effects of any Requires field in any     rule will apply to all other rules as well. \n   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are     mutually exclusive. Only one of these members may be present within an     individual rule.",
                    "type": "object",
                    "properties": {
                      "icmps": {
                        "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is not allowed to initiate type 8 ICMP connections.",
                        "type": "array",
                        "items": {
                          "description": "ICMPRule is a list of ICMP fields.",
                          "type": "object",
                          "properties": {
                            "fields": {
                              "description": "Fields is a list of ICMP fields.",
                              "type": "array",
                              "items": {
                                "description": "ICMPField is a ICMP field.",
                                "type": "object",
                                "required": [
                                  "type"
                                ],
                                "properties": {
                                  "family": {
                                    "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                    "type": "string",
                                    "enum": [
                                      "IPv4",
                                      "IPv6"
                                    ]
                                  },
                                  "type": {
                                    "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                    "type": "integer",
                                    "maximum": 255,
                                    "minimum": 0
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      "toCIDR": {
                        "description": "ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules.  This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24",
                        "type": "array",
                        "items": {
                          "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                          "type": "string",
                          "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                        }
                      },
                      "toCIDRSet": {
                        "description": "ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.",
                        "type": "array",
                        "items": {
                          "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                          "type": "object",
                          "properties": {
                            "cidr": {
                              "description": "CIDR is a CIDR prefix / IP Block.",
                              "type": "string",
                              "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                            },
                            "cidrGroupRef": {
                              "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                              "type": "string",
                              "maxLength": 253,
                              "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                            },
                            "except": {
                              "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                              "type": "array",
                              "items": {
                                "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                "type": "string",
                                "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                              }
                            }
                          }
                        }
                      },
                      "toEndpoints": {
                        "description": "ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\".",
                        "type": "array",
                        "items": {
                          "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                          "type": "object",
                          "properties": {
                            "matchExpressions": {
                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                              "type": "array",
                              "items": {
                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "key is the label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                    "type": "string",
                                    "enum": [
                                      "In",
                                      "NotIn",
                                      "Exists",
                                      "DoesNotExist"
                                    ]
                                  },
                                  "values": {
                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "matchLabels": {
                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                              "type": "object",
                              "additionalProperties": {
                                "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                "type": "string",
                                "maxLength": 63,
                                "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                              }
                            }
                          }
                        }
                      },
                      "toEntities": {
                        "description": "ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`, `health`,`unmanaged` and `all`.",
                        "type": "array",
                        "items": {
                          "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                          "type": "string",
                          "enum": [
                            "all",
                            "world",
                            "cluster",
                            "host",
                            "init",
                            "ingress",
                            "unmanaged",
                            "remote-node",
                            "health",
                            "none",
                            "kube-apiserver"
                          ]
                        }
                      },
                      "toGroups": {
                        "description": "ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws:     securityGroupsIds:     - 'sg-XXXXXXXXXXXXX'",
                        "type": "array",
                        "items": {
                          "description": "ToGroups structure to store all kinds of new integrations that needs a new derivative policy.",
                          "type": "object",
                          "properties": {
                            "aws": {
                              "description": "AWSGroup is an structure that can be used to whitelisting information from AWS integration",
                              "type": "object",
                              "properties": {
                                "labels": {
                                  "type": "object",
                                  "additionalProperties": {
                                    "type": "string"
                                  }
                                },
                                "region": {
                                  "type": "string"
                                },
                                "securityGroupsIds": {
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                },
                                "securityGroupsNames": {
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      "toPorts": {
                        "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is not allowed to initiate connections to destination port 8080/tcp",
                        "type": "array",
                        "items": {
                          "description": "PortDenyRule is a list of ports/protocol that should be used for deny policies. This structure lacks the L7Rules since it's not supported in deny policies.",
                          "type": "object",
                          "properties": {
                            "ports": {
                              "description": "Ports is a list of L4 port/protocol",
                              "type": "array",
                              "items": {
                                "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                                "type": "object",
                                "required": [
                                  "port"
                                ],
                                "properties": {
                                  "port": {
                                    "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                    "type": "string",
                                    "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                  },
                                  "protocol": {
                                    "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                    "type": "string",
                                    "enum": [
                                      "TCP",
                                      "UDP",
                                      "SCTP",
                                      "ANY"
                                    ]
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      "toRequires": {
                        "description": "ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\".",
                        "type": "array",
                        "items": {
                          "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                          "type": "object",
                          "properties": {
                            "matchExpressions": {
                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                              "type": "array",
                              "items": {
                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "key is the label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                    "type": "string",
                                    "enum": [
                                      "In",
                                      "NotIn",
                                      "Exists",
                                      "DoesNotExist"
                                    ]
                                  },
                                  "values": {
                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "matchLabels": {
                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                              "type": "object",
                              "additionalProperties": {
                                "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                "type": "string",
                                "maxLength": 63,
                                "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                              }
                            }
                          }
                        }
                      },
                      "toServices": {
                        "description": "ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service",
                        "type": "array",
                        "items": {
                          "description": "Service wraps around selectors for services",
                          "type": "object",
                          "properties": {
                            "k8sService": {
                              "description": "K8sService selects service by name and namespace pair",
                              "type": "object",
                              "properties": {
                                "namespace": {
                                  "type": "string"
                                },
                                "serviceName": {
                                  "type": "string"
                                }
                              }
                            },
                            "k8sServiceSelector": {
                              "description": "K8sServiceSelector selects services by k8s labels and namespace",
                              "type": "object",
                              "required": [
                                "selector"
                              ],
                              "properties": {
                                "namespace": {
                                  "type": "string"
                                },
                                "selector": {
                                  "description": "ServiceSelector is a label selector for k8s services",
                                  "type": "object",
                                  "properties": {
                                    "matchExpressions": {
                                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                      "type": "array",
                                      "items": {
                                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                        "type": "object",
                                        "required": [
                                          "key",
                                          "operator"
                                        ],
                                        "properties": {
                                          "key": {
                                            "description": "key is the label key that the selector applies to.",
                                            "type": "string"
                                          },
                                          "operator": {
                                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                            "type": "string",
                                            "enum": [
                                              "In",
                                              "NotIn",
                                              "Exists",
                                              "DoesNotExist"
                                            ]
                                          },
                                          "values": {
                                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "matchLabels": {
                                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                      "type": "object",
                                      "additionalProperties": {
                                        "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                        "type": "string",
                                        "maxLength": 63,
                                        "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "endpointSelector": {
                  "description": "EndpointSelector selects all endpoints which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive.",
                  "type": "object",
                  "properties": {
                    "matchExpressions": {
                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                      "type": "array",
                      "items": {
                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                        "type": "object",
                        "required": [
                          "key",
                          "operator"
                        ],
                        "properties": {
                          "key": {
                            "description": "key is the label key that the selector applies to.",
                            "type": "string"
                          },
                          "operator": {
                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                            "type": "string",
                            "enum": [
                              "In",
                              "NotIn",
                              "Exists",
                              "DoesNotExist"
                            ]
                          },
                          "values": {
                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      }
                    },
                    "matchLabels": {
                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                      "type": "object",
                      "additionalProperties": {
                        "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                        "type": "string",
                        "maxLength": 63,
                        "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                      }
                    }
                  }
                },
                "ingress": {
                  "description": "Ingress is a list of IngressRule which are enforced at ingress. If omitted or empty, this rule does not apply at ingress.",
                  "type": "array",
                  "items": {
                    "description": "IngressRule contains all rule types which can be applied at ingress, i.e. network traffic that originates outside of the endpoint and is entering the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members are set, all of them need to match in order for     the rule to take effect. The exception to this rule is FromRequires field;     the effects of any Requires field in any rule will apply to all other     rules as well. \n   - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually     exclusive. Only one of these members may be present within an individual     rule.",
                    "type": "object",
                    "properties": {
                      "authentication": {
                        "description": "Authentication is the required authentication type for the allowed traffic, if any.",
                        "type": "object",
                        "required": [
                          "mode"
                        ],
                        "properties": {
                          "mode": {
                            "description": "Mode is the required authentication mode for the allowed traffic, if any.",
                            "type": "string",
                            "enum": [
                              "disabled",
                              "required",
                              "test-always-fail"
                            ]
                          }
                        }
                      },
                      "fromCIDR": {
                        "description": "FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do *not* originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field.  This will match on the source IP address of incoming connections. Adding  a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.3.9.1",
                        "type": "array",
                        "items": {
                          "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                          "type": "string",
                          "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                        }
                      },
                      "fromCIDRSet": {
                        "description": "FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.",
                        "type": "array",
                        "items": {
                          "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                          "type": "object",
                          "properties": {
                            "cidr": {
                              "description": "CIDR is a CIDR prefix / IP Block.",
                              "type": "string",
                              "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                            },
                            "cidrGroupRef": {
                              "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                              "type": "string",
                              "maxLength": 253,
                              "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                            },
                            "except": {
                              "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                              "type": "array",
                              "items": {
                                "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                "type": "string",
                                "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                              }
                            }
                          }
                        }
                      },
                      "fromEndpoints": {
                        "description": "FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\".",
                        "type": "array",
                        "items": {
                          "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                          "type": "object",
                          "properties": {
                            "matchExpressions": {
                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                              "type": "array",
                              "items": {
                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "key is the label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                    "type": "string",
                                    "enum": [
                                      "In",
                                      "NotIn",
                                      "Exists",
                                      "DoesNotExist"
                                    ]
                                  },
                                  "values": {
                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "matchLabels": {
                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                              "type": "object",
                              "additionalProperties": {
                                "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                "type": "string",
                                "maxLength": 63,
                                "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                              }
                            }
                          }
                        }
                      },
                      "fromEntities": {
                        "description": "FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are `world`, `cluster` and `host`",
                        "type": "array",
                        "items": {
                          "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                          "type": "string",
                          "enum": [
                            "all",
                            "world",
                            "cluster",
                            "host",
                            "init",
                            "ingress",
                            "unmanaged",
                            "remote-node",
                            "health",
                            "none",
                            "kube-apiserver"
                          ]
                        }
                      },
                      "fromRequires": {
                        "description": "FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\".",
                        "type": "array",
                        "items": {
                          "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                          "type": "object",
                          "properties": {
                            "matchExpressions": {
                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                              "type": "array",
                              "items": {
                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "key is the label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                    "type": "string",
                                    "enum": [
                                      "In",
                                      "NotIn",
                                      "Exists",
                                      "DoesNotExist"
                                    ]
                                  },
                                  "values": {
                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "matchLabels": {
                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                              "type": "object",
                              "additionalProperties": {
                                "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                "type": "string",
                                "maxLength": 63,
                                "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                              }
                            }
                          }
                        }
                      },
                      "icmps": {
                        "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming type 8 ICMP connections.",
                        "type": "array",
                        "items": {
                          "description": "ICMPRule is a list of ICMP fields.",
                          "type": "object",
                          "properties": {
                            "fields": {
                              "description": "Fields is a list of ICMP fields.",
                              "type": "array",
                              "items": {
                                "description": "ICMPField is a ICMP field.",
                                "type": "object",
                                "required": [
                                  "type"
                                ],
                                "properties": {
                                  "family": {
                                    "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                    "type": "string",
                                    "enum": [
                                      "IPv4",
                                      "IPv6"
                                    ]
                                  },
                                  "type": {
                                    "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                    "type": "integer",
                                    "maximum": 255,
                                    "minimum": 0
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      "toPorts": {
                        "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming connections on port 80/tcp.",
                        "type": "array",
                        "items": {
                          "description": "PortRule is a list of ports/protocol combinations with optional Layer 7 rules which must be met.",
                          "type": "object",
                          "properties": {
                            "listener": {
                              "description": "listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.",
                              "type": "object",
                              "required": [
                                "envoyConfig",
                                "name"
                              ],
                              "properties": {
                                "envoyConfig": {
                                  "description": "EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.",
                                  "type": "object",
                                  "required": [
                                    "name"
                                  ],
                                  "properties": {
                                    "kind": {
                                      "description": "Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.",
                                      "type": "string",
                                      "enum": [
                                        "CiliumEnvoyConfig",
                                        "CiliumClusterwideEnvoyConfig"
                                      ]
                                    },
                                    "name": {
                                      "description": "Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where the listener is defined in.",
                                      "type": "string",
                                      "minLength": 1
                                    }
                                  }
                                },
                                "name": {
                                  "description": "Name is the name of the listener.",
                                  "type": "string",
                                  "minLength": 1
                                }
                              }
                            },
                            "originatingTLS": {
                              "description": "OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.",
                              "type": "object",
                              "required": [
                                "secret"
                              ],
                              "properties": {
                                "certificate": {
                                  "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                  "type": "string"
                                },
                                "privateKey": {
                                  "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                  "type": "string"
                                },
                                "secret": {
                                  "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                  "type": "object",
                                  "required": [
                                    "name"
                                  ],
                                  "properties": {
                                    "name": {
                                      "description": "Name is the name of the secret.",
                                      "type": "string"
                                    },
                                    "namespace": {
                                      "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                      "type": "string"
                                    }
                                  }
                                },
                                "trustedCA": {
                                  "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                  "type": "string"
                                }
                              }
                            },
                            "ports": {
                              "description": "Ports is a list of L4 port/protocol",
                              "type": "array",
                              "items": {
                                "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                                "type": "object",
                                "required": [
                                  "port"
                                ],
                                "properties": {
                                  "port": {
                                    "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                    "type": "string",
                                    "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                  },
                                  "protocol": {
                                    "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                    "type": "string",
                                    "enum": [
                                      "TCP",
                                      "UDP",
                                      "SCTP",
                                      "ANY"
                                    ]
                                  }
                                }
                              }
                            },
                            "rules": {
                              "description": "Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.",
                              "type": "object",
                              "properties": {
                                "dns": {
                                  "description": "DNS-specific rules.",
                                  "type": "array",
                                  "items": {
                                    "description": "PortRuleDNS is a list of allowed DNS lookups.",
                                    "type": "object",
                                    "properties": {
                                      "matchName": {
                                        "description": "MatchName matches literal DNS names. A trailing \".\" is automatically added when missing.",
                                        "type": "string",
                                        "pattern": "^([-a-zA-Z0-9_]+[.]?)+$"
                                      },
                                      "matchPattern": {
                                        "description": "MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"*\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"*\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: `*.cilium.io` matches subomains of cilium at that level   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with \"cilium.io\"   except those containing \".\" separator, subcilium.io and sub-cilium.io match,   www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\"   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,   blog.cilium.io, cilium.io and google.com do not",
                                        "type": "string",
                                        "pattern": "^([-a-zA-Z0-9_*]+[.]?)+$"
                                      }
                                    }
                                  }
                                },
                                "http": {
                                  "description": "HTTP specific rules.",
                                  "type": "array",
                                  "items": {
                                    "description": "PortRuleHTTP is a list of HTTP protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect. \n All fields of this type are extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986.",
                                    "type": "object",
                                    "properties": {
                                      "headerMatches": {
                                        "description": "HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match.",
                                        "type": "array",
                                        "items": {
                                          "description": "HeaderMatch extends the HeaderValue for matching requirement of a named header field against an immediate string, a secret value, or a regex.  If none of the optional fields is present, then the header value is not matched, only presence of the header is enough.",
                                          "type": "object",
                                          "required": [
                                            "name"
                                          ],
                                          "properties": {
                                            "mismatch": {
                                              "description": "Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.",
                                              "type": "string",
                                              "enum": [
                                                "LOG",
                                                "ADD",
                                                "DELETE",
                                                "REPLACE"
                                              ]
                                            },
                                            "name": {
                                              "description": "Name identifies the header.",
                                              "type": "string"
                                            },
                                            "secret": {
                                              "description": "Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no \"Value\" specified, the match will fail.",
                                              "type": "object",
                                              "required": [
                                                "name"
                                              ],
                                              "properties": {
                                                "name": {
                                                  "description": "Name is the name of the secret.",
                                                  "type": "string"
                                                },
                                                "namespace": {
                                                  "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                                  "type": "string"
                                                }
                                              }
                                            },
                                            "value": {
                                              "description": "Value matches the exact value of the header. Can be specified either alone or together with \"Secret\"; will be used as the header value if the secret can not be found in the latter case.",
                                              "type": "string"
                                            }
                                          }
                                        }
                                      },
                                      "headers": {
                                        "description": "Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present.",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        }
                                      },
                                      "host": {
                                        "description": "Host is an extended POSIX regex matched against the host header of a request, e.g. \"foo.com\" \n If omitted or empty, the value of the host header is ignored.",
                                        "type": "string",
                                        "format": "idn-hostname"
                                      },
                                      "method": {
                                        "description": "Method is an extended POSIX regex matched against the method of a request, e.g. \"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\", ... \n If omitted or empty, all methods are allowed.",
                                        "type": "string"
                                      },
                                      "path": {
                                        "description": "Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986. \n If omitted or empty, all paths are all allowed.",
                                        "type": "string"
                                      }
                                    }
                                  }
                                },
                                "kafka": {
                                  "description": "Kafka-specific rules.",
                                  "type": "array",
                                  "items": {
                                    "description": "PortRule is a list of Kafka protocol constraints. All fields are optional, if all fields are empty or missing, the rule will match all Kafka messages.",
                                    "type": "object",
                                    "properties": {
                                      "apiKey": {
                                        "description": "APIKey is a case-insensitive string matched against the key of a request, e.g. \"produce\", \"fetch\", \"createtopic\", \"deletetopic\", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys \n If omitted or empty, and if Role is not specified, then all keys are allowed.",
                                        "type": "string"
                                      },
                                      "apiVersion": {
                                        "description": "APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer. \n If omitted or empty, all versions are allowed.",
                                        "type": "string"
                                      },
                                      "clientID": {
                                        "description": "ClientID is the client identifier as provided in the request. \n From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client. \n If omitted or empty, all client identifiers are allowed.",
                                        "type": "string"
                                      },
                                      "role": {
                                        "description": "Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as \"produce\" or \"consume\". A Role automatically expands into all APIKeys required to perform the specified higher-level operation. \n The following values are supported:  - \"produce\": Allow producing to the topics specified in the rule  - \"consume\": Allow consuming from the topics specified in the rule \n This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule. \n If omitted or empty, and if APIKey is not specified, then all keys are allowed.",
                                        "type": "string",
                                        "enum": [
                                          "produce",
                                          "consume"
                                        ]
                                      },
                                      "topic": {
                                        "description": "Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected. \n This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _. \n Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255. \n If omitted or empty, all topics are allowed.",
                                        "type": "string",
                                        "maxLength": 255
                                      }
                                    }
                                  }
                                },
                                "l7": {
                                  "description": "Key-value pair rules.",
                                  "type": "array",
                                  "items": {
                                    "description": "PortRuleL7 is a list of key-value pairs interpreted by a L7 protocol as protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect.",
                                    "type": "object",
                                    "additionalProperties": {
                                      "type": "string"
                                    }
                                  }
                                },
                                "l7proto": {
                                  "description": "Name of the L7 protocol for which the Key-value pair rules apply.",
                                  "type": "string"
                                }
                              }
                            },
                            "serverNames": {
                              "description": "ServerNames is a list of allowed TLS SNI values. If not empty, then TLS must be present and one of the provided SNIs must be indicated in the TLS handshake.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            },
                            "terminatingTLS": {
                              "description": "TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.",
                              "type": "object",
                              "required": [
                                "secret"
                              ],
                              "properties": {
                                "certificate": {
                                  "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                  "type": "string"
                                },
                                "privateKey": {
                                  "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                  "type": "string"
                                },
                                "secret": {
                                  "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                  "type": "object",
                                  "required": [
                                    "name"
                                  ],
                                  "properties": {
                                    "name": {
                                      "description": "Name is the name of the secret.",
                                      "type": "string"
                                    },
                                    "namespace": {
                                      "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                      "type": "string"
                                    }
                                  }
                                },
                                "trustedCA": {
                                  "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                  "type": "string"
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "ingressDeny": {
                  "description": "IngressDeny is a list of IngressDenyRule which are enforced at ingress. Any rule inserted here will be denied regardless of the allowed ingress rules in the 'ingress' field. If omitted or empty, this rule does not apply at ingress.",
                  "type": "array",
                  "items": {
                    "description": "IngressDenyRule contains all rule types which can be applied at ingress, i.e. network traffic that originates outside of the endpoint and is entering the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members are set, all of them need to match in order for     the rule to take effect. The exception to this rule is FromRequires field;     the effects of any Requires field in any rule will apply to all other     rules as well. \n   - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually     exclusive. Only one of these members may be present within an individual     rule.",
                    "type": "object",
                    "properties": {
                      "fromCIDR": {
                        "description": "FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do *not* originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field.  This will match on the source IP address of incoming connections. Adding  a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.3.9.1",
                        "type": "array",
                        "items": {
                          "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                          "type": "string",
                          "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                        }
                      },
                      "fromCIDRSet": {
                        "description": "FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.",
                        "type": "array",
                        "items": {
                          "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                          "type": "object",
                          "properties": {
                            "cidr": {
                              "description": "CIDR is a CIDR prefix / IP Block.",
                              "type": "string",
                              "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                            },
                            "cidrGroupRef": {
                              "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                              "type": "string",
                              "maxLength": 253,
                              "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                            },
                            "except": {
                              "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                              "type": "array",
                              "items": {
                                "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                "type": "string",
                                "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                              }
                            }
                          }
                        }
                      },
                      "fromEndpoints": {
                        "description": "FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\".",
                        "type": "array",
                        "items": {
                          "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                          "type": "object",
                          "properties": {
                            "matchExpressions": {
                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                              "type": "array",
                              "items": {
                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "key is the label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                    "type": "string",
                                    "enum": [
                                      "In",
                                      "NotIn",
                                      "Exists",
                                      "DoesNotExist"
                                    ]
                                  },
                                  "values": {
                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "matchLabels": {
                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                              "type": "object",
                              "additionalProperties": {
                                "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                "type": "string",
                                "maxLength": 63,
                                "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                              }
                            }
                          }
                        }
                      },
                      "fromEntities": {
                        "description": "FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are `world`, `cluster` and `host`",
                        "type": "array",
                        "items": {
                          "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                          "type": "string",
                          "enum": [
                            "all",
                            "world",
                            "cluster",
                            "host",
                            "init",
                            "ingress",
                            "unmanaged",
                            "remote-node",
                            "health",
                            "none",
                            "kube-apiserver"
                          ]
                        }
                      },
                      "fromRequires": {
                        "description": "FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\".",
                        "type": "array",
                        "items": {
                          "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                          "type": "object",
                          "properties": {
                            "matchExpressions": {
                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                              "type": "array",
                              "items": {
                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "key is the label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                    "type": "string",
                                    "enum": [
                                      "In",
                                      "NotIn",
                                      "Exists",
                                      "DoesNotExist"
                                    ]
                                  },
                                  "values": {
                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "matchLabels": {
                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                              "type": "object",
                              "additionalProperties": {
                                "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                "type": "string",
                                "maxLength": 63,
                                "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                              }
                            }
                          }
                        }
                      },
                      "icmps": {
                        "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming type 8 ICMP connections.",
                        "type": "array",
                        "items": {
                          "description": "ICMPRule is a list of ICMP fields.",
                          "type": "object",
                          "properties": {
                            "fields": {
                              "description": "Fields is a list of ICMP fields.",
                              "type": "array",
                              "items": {
                                "description": "ICMPField is a ICMP field.",
                                "type": "object",
                                "required": [
                                  "type"
                                ],
                                "properties": {
                                  "family": {
                                    "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                    "type": "string",
                                    "enum": [
                                      "IPv4",
                                      "IPv6"
                                    ]
                                  },
                                  "type": {
                                    "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                    "type": "integer",
                                    "maximum": 255,
                                    "minimum": 0
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      "toPorts": {
                        "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming connections on port 80/tcp.",
                        "type": "array",
                        "items": {
                          "description": "PortDenyRule is a list of ports/protocol that should be used for deny policies. This structure lacks the L7Rules since it's not supported in deny policies.",
                          "type": "object",
                          "properties": {
                            "ports": {
                              "description": "Ports is a list of L4 port/protocol",
                              "type": "array",
                              "items": {
                                "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                                "type": "object",
                                "required": [
                                  "port"
                                ],
                                "properties": {
                                  "port": {
                                    "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                    "type": "string",
                                    "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                  },
                                  "protocol": {
                                    "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                    "type": "string",
                                    "enum": [
                                      "TCP",
                                      "UDP",
                                      "SCTP",
                                      "ANY"
                                    ]
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "labels": {
                  "description": "Labels is a list of optional strings which can be used to re-identify the rule or to store metadata. It is possible to lookup or delete strings based on labels. Labels are not required to be unique, multiple rules can have overlapping or identical labels.",
                  "type": "array",
                  "items": {
                    "description": "Label is the Cilium's representation of a container label.",
                    "type": "object",
                    "required": [
                      "key"
                    ],
                    "properties": {
                      "key": {
                        "type": "string"
                      },
                      "source": {
                        "description": "Source can be one of the above values (e.g.: LabelSourceContainer).",
                        "type": "string"
                      },
                      "value": {
                        "type": "string"
                      }
                    }
                  }
                },
                "nodeSelector": {
                  "description": "NodeSelector selects all nodes which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive. Can only be used in CiliumClusterwideNetworkPolicies.",
                  "type": "object",
                  "properties": {
                    "matchExpressions": {
                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                      "type": "array",
                      "items": {
                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                        "type": "object",
                        "required": [
                          "key",
                          "operator"
                        ],
                        "properties": {
                          "key": {
                            "description": "key is the label key that the selector applies to.",
                            "type": "string"
                          },
                          "operator": {
                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                            "type": "string",
                            "enum": [
                              "In",
                              "NotIn",
                              "Exists",
                              "DoesNotExist"
                            ]
                          },
                          "values": {
                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      }
                    },
                    "matchLabels": {
                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                      "type": "object",
                      "additionalProperties": {
                        "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                        "type": "string",
                        "maxLength": 63,
                        "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                      }
                    }
                  }
                }
              }
            }
          },
          "status": {
            "description": "Status is the status of the Cilium policy rule",
            "type": "object",
            "properties": {
              "derivativePolicies": {
                "description": "DerivativePolicies is the status of all policies derived from the Cilium policy",
                "type": "object",
                "additionalProperties": {
                  "description": "CiliumNetworkPolicyNodeStatus is the status of a Cilium policy rule for a specific node.",
                  "type": "object",
                  "properties": {
                    "annotations": {
                      "description": "Annotations corresponds to the Annotations in the ObjectMeta of the CNP that have been realized on the node for CNP. That is, if a CNP has been imported and has been assigned annotation X=Y by the user, Annotations in CiliumNetworkPolicyNodeStatus will be X=Y once the CNP that was imported corresponding to Annotation X=Y has been realized on the node.",
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "enforcing": {
                      "description": "Enforcing is set to true once all endpoints present at the time the policy has been imported are enforcing this policy.",
                      "type": "boolean"
                    },
                    "error": {
                      "description": "Error describes any error that occurred when parsing or importing the policy, or realizing the policy for the endpoints to which it applies on the node.",
                      "type": "string"
                    },
                    "lastUpdated": {
                      "description": "LastUpdated contains the last time this status was updated",
                      "type": "string",
                      "format": "date-time"
                    },
                    "localPolicyRevision": {
                      "description": "Revision is the policy revision of the repository which first implemented this policy.",
                      "type": "integer",
                      "format": "int64"
                    },
                    "ok": {
                      "description": "OK is true when the policy has been parsed and imported successfully into the in-memory policy repository on the node.",
                      "type": "boolean"
                    }
                  }
                }
              },
              "nodes": {
                "description": "Nodes is the Cilium policy status for each node",
                "type": "object",
                "additionalProperties": {
                  "description": "CiliumNetworkPolicyNodeStatus is the status of a Cilium policy rule for a specific node.",
                  "type": "object",
                  "properties": {
                    "annotations": {
                      "description": "Annotations corresponds to the Annotations in the ObjectMeta of the CNP that have been realized on the node for CNP. That is, if a CNP has been imported and has been assigned annotation X=Y by the user, Annotations in CiliumNetworkPolicyNodeStatus will be X=Y once the CNP that was imported corresponding to Annotation X=Y has been realized on the node.",
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "enforcing": {
                      "description": "Enforcing is set to true once all endpoints present at the time the policy has been imported are enforcing this policy.",
                      "type": "boolean"
                    },
                    "error": {
                      "description": "Error describes any error that occurred when parsing or importing the policy, or realizing the policy for the endpoints to which it applies on the node.",
                      "type": "string"
                    },
                    "lastUpdated": {
                      "description": "LastUpdated contains the last time this status was updated",
                      "type": "string",
                      "format": "date-time"
                    },
                    "localPolicyRevision": {
                      "description": "Revision is the policy revision of the repository which first implemented this policy.",
                      "type": "integer",
                      "format": "int64"
                    },
                    "ok": {
                      "description": "OK is true when the policy has been parsed and imported successfully into the in-memory policy repository on the node.",
                      "type": "boolean"
                    }
                  }
                }
              }
            }
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "cilium.io",
            "kind": "CiliumNetworkPolicy",
            "version": "v2"
          }
        ]
      },
      "crd": {
        "metadata": {
          "name": "ciliumnetworkpolicies.cilium.io",
          "uid": "dd9a3306-cf2e-4ee0-9bc0-e38569bda3cf",
          "resourceVersion": "25877238829",
          "generation": 1,
          "creationTimestamp": "2023-11-21T10:47:05Z",
          "labels": {
            "io.cilium.k8s.crd.schema.version": "1.26.11"
          },
          "managedFields": [
            {
              "manager": "cilium-operator-generic",
              "operation": "Update",
              "apiVersion": "apiextensions.k8s.io/v1",
              "time": "2023-11-21T10:47:05Z",
              "fieldsType": "FieldsV1",
              "fieldsV1": {
                "f:metadata": {
                  "f:labels": {
                    ".": {},
                    "f:io.cilium.k8s.crd.schema.version": {}
                  }
                },
                "f:spec": {
                  "f:conversion": {
                    ".": {},
                    "f:strategy": {}
                  },
                  "f:group": {},
                  "f:names": {
                    "f:kind": {},
                    "f:listKind": {},
                    "f:plural": {},
                    "f:shortNames": {},
                    "f:singular": {}
                  },
                  "f:scope": {},
                  "f:versions": {}
                }
              }
            },
            {
              "manager": "kube-apiserver",
              "operation": "Update",
              "apiVersion": "apiextensions.k8s.io/v1",
              "time": "2023-11-21T10:47:07Z",
              "fieldsType": "FieldsV1",
              "fieldsV1": {
                "f:status": {
                  "f:acceptedNames": {
                    "f:kind": {},
                    "f:listKind": {},
                    "f:plural": {},
                    "f:shortNames": {},
                    "f:singular": {}
                  },
                  "f:conditions": {
                    "k:{\"type\":\"Established\"}": {
                      ".": {},
                      "f:lastTransitionTime": {},
                      "f:message": {},
                      "f:reason": {},
                      "f:status": {},
                      "f:type": {}
                    },
                    "k:{\"type\":\"NamesAccepted\"}": {
                      ".": {},
                      "f:lastTransitionTime": {},
                      "f:message": {},
                      "f:reason": {},
                      "f:status": {},
                      "f:type": {}
                    }
                  }
                }
              },
              "subresource": "status"
            }
          ]
        },
        "spec": {
          "group": "cilium.io",
          "names": {
            "plural": "ciliumnetworkpolicies",
            "singular": "ciliumnetworkpolicy",
            "shortNames": [
              "cnp",
              "ciliumnp"
            ],
            "kind": "CiliumNetworkPolicy",
            "listKind": "CiliumNetworkPolicyList"
          },
          "scope": "Namespaced",
          "versions": [
            {
              "name": "v2",
              "served": true,
              "storage": true,
              "schema": {
                "openAPIV3Schema": {
                  "description": "CiliumNetworkPolicy is a Kubernetes third-party resource with an extended version of NetworkPolicy.",
                  "type": "object",
                  "required": [
                    "metadata"
                  ],
                  "properties": {
                    "apiVersion": {
                      "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                      "type": "string"
                    },
                    "kind": {
                      "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                      "type": "string"
                    },
                    "metadata": {
                      "type": "object"
                    },
                    "spec": {
                      "description": "Spec is the desired Cilium specific rule specification.",
                      "type": "object",
                      "oneOf": [
                        {
                          "required": [
                            "endpointSelector"
                          ],
                          "properties": {
                            "endpointSelector": {}
                          }
                        },
                        {
                          "required": [
                            "nodeSelector"
                          ],
                          "properties": {
                            "nodeSelector": {}
                          }
                        }
                      ],
                      "properties": {
                        "description": {
                          "description": "Description is a free form string, it can be used by the creator of the rule to store human readable explanation of the purpose of this rule. Rules cannot be identified by comment.",
                          "type": "string"
                        },
                        "egress": {
                          "description": "Egress is a list of EgressRule which are enforced at egress. If omitted or empty, this rule does not apply at egress.",
                          "type": "array",
                          "items": {
                            "description": "EgressRule contains all rule types which can be applied at egress, i.e. network traffic that originates inside the endpoint and exits the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members of the structure are specified, then all members     must match in order for the rule to take effect. The exception to this     rule is the ToRequires member; the effects of any Requires field in any     rule will apply to all other rules as well. \n   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are     mutually exclusive. Only one of these members may be present within an     individual rule.",
                            "type": "object",
                            "properties": {
                              "authentication": {
                                "description": "Authentication is the required authentication type for the allowed traffic, if any.",
                                "type": "object",
                                "required": [
                                  "mode"
                                ],
                                "properties": {
                                  "mode": {
                                    "description": "Mode is the required authentication mode for the allowed traffic, if any.",
                                    "type": "string",
                                    "enum": [
                                      "disabled",
                                      "required",
                                      "test-always-fail"
                                    ]
                                  }
                                }
                              },
                              "icmps": {
                                "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is allowed to initiate type 8 ICMP connections.",
                                "type": "array",
                                "items": {
                                  "description": "ICMPRule is a list of ICMP fields.",
                                  "type": "object",
                                  "properties": {
                                    "fields": {
                                      "description": "Fields is a list of ICMP fields.",
                                      "type": "array",
                                      "items": {
                                        "description": "ICMPField is a ICMP field.",
                                        "type": "object",
                                        "required": [
                                          "type"
                                        ],
                                        "properties": {
                                          "family": {
                                            "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                            "type": "string",
                                            "default": "IPv4",
                                            "enum": [
                                              "IPv4",
                                              "IPv6"
                                            ]
                                          },
                                          "type": {
                                            "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                            "type": "integer",
                                            "maximum": 255,
                                            "minimum": 0
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              },
                              "toCIDR": {
                                "description": "ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules.  This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24",
                                "type": "array",
                                "items": {
                                  "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                  "type": "string",
                                  "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                }
                              },
                              "toCIDRSet": {
                                "description": "ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.",
                                "type": "array",
                                "items": {
                                  "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                                  "type": "object",
                                  "oneOf": [
                                    {
                                      "required": [
                                        "cidr"
                                      ],
                                      "properties": {
                                        "cidr": {}
                                      }
                                    },
                                    {
                                      "required": [
                                        "cidrGroupRef"
                                      ],
                                      "properties": {
                                        "cidrGroupRef": {}
                                      }
                                    }
                                  ],
                                  "properties": {
                                    "cidr": {
                                      "description": "CIDR is a CIDR prefix / IP Block.",
                                      "type": "string",
                                      "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                    },
                                    "cidrGroupRef": {
                                      "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                                      "type": "string",
                                      "maxLength": 253,
                                      "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                                    },
                                    "except": {
                                      "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                                      "type": "array",
                                      "items": {
                                        "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                        "type": "string",
                                        "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                      }
                                    }
                                  }
                                }
                              },
                              "toEndpoints": {
                                "description": "ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\".",
                                "type": "array",
                                "items": {
                                  "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                  "type": "object",
                                  "properties": {
                                    "matchExpressions": {
                                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                      "type": "array",
                                      "items": {
                                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                        "type": "object",
                                        "required": [
                                          "key",
                                          "operator"
                                        ],
                                        "properties": {
                                          "key": {
                                            "description": "key is the label key that the selector applies to.",
                                            "type": "string"
                                          },
                                          "operator": {
                                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                            "type": "string",
                                            "enum": [
                                              "In",
                                              "NotIn",
                                              "Exists",
                                              "DoesNotExist"
                                            ]
                                          },
                                          "values": {
                                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "matchLabels": {
                                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                      "type": "object",
                                      "additionalProperties": {
                                        "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                        "type": "string",
                                        "maxLength": 63,
                                        "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                      }
                                    }
                                  }
                                }
                              },
                              "toEntities": {
                                "description": "ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`, `health`,`unmanaged` and `all`.",
                                "type": "array",
                                "items": {
                                  "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                                  "type": "string",
                                  "enum": [
                                    "all",
                                    "world",
                                    "cluster",
                                    "host",
                                    "init",
                                    "ingress",
                                    "unmanaged",
                                    "remote-node",
                                    "health",
                                    "none",
                                    "kube-apiserver"
                                  ]
                                }
                              },
                              "toFQDNs": {
                                "description": "ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result from DNS resolution of `ToFQDN.MatchName`s are added to the same EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and L7 rules within this EgressRule will also apply to these IPs. The DNS -> IP mapping is re-resolved periodically from within the cilium-agent, and the IPs in the DNS response are effected in the policy for selected pods as-is (i.e. the list of IPs is not modified in any way). Note: An explicit rule to allow for DNS traffic is needed for the pods, as ToFQDN counts as an egress rule and will enforce egress policy when PolicyEnforcment=default. Note: If the resolved IPs are IPs within the kubernetes cluster, the ToFQDN rule will not apply to that IP. Note: ToFQDN cannot occur in the same policy as other To* rules.",
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "matchName": {
                                      "description": "MatchName matches literal DNS names. A trailing \".\" is automatically added when missing.",
                                      "type": "string",
                                      "pattern": "^([-a-zA-Z0-9_]+[.]?)+$"
                                    },
                                    "matchPattern": {
                                      "description": "MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"*\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"*\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: `*.cilium.io` matches subomains of cilium at that level   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with \"cilium.io\"   except those containing \".\" separator, subcilium.io and sub-cilium.io match,   www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\"   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,   blog.cilium.io, cilium.io and google.com do not",
                                      "type": "string",
                                      "pattern": "^([-a-zA-Z0-9_*]+[.]?)+$"
                                    }
                                  }
                                }
                              },
                              "toGroups": {
                                "description": "ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws:     securityGroupsIds:     - 'sg-XXXXXXXXXXXXX'",
                                "type": "array",
                                "items": {
                                  "description": "ToGroups structure to store all kinds of new integrations that needs a new derivative policy.",
                                  "type": "object",
                                  "properties": {
                                    "aws": {
                                      "description": "AWSGroup is an structure that can be used to whitelisting information from AWS integration",
                                      "type": "object",
                                      "properties": {
                                        "labels": {
                                          "type": "object",
                                          "additionalProperties": {
                                            "type": "string"
                                          }
                                        },
                                        "region": {
                                          "type": "string"
                                        },
                                        "securityGroupsIds": {
                                          "type": "array",
                                          "items": {
                                            "type": "string"
                                          }
                                        },
                                        "securityGroupsNames": {
                                          "type": "array",
                                          "items": {
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              },
                              "toPorts": {
                                "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is allowed to initiate connections to destination port 8080/tcp",
                                "type": "array",
                                "items": {
                                  "description": "PortRule is a list of ports/protocol combinations with optional Layer 7 rules which must be met.",
                                  "type": "object",
                                  "properties": {
                                    "listener": {
                                      "description": "listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.",
                                      "type": "object",
                                      "required": [
                                        "envoyConfig",
                                        "name"
                                      ],
                                      "properties": {
                                        "envoyConfig": {
                                          "description": "EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.",
                                          "type": "object",
                                          "required": [
                                            "name"
                                          ],
                                          "properties": {
                                            "kind": {
                                              "description": "Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.",
                                              "type": "string",
                                              "enum": [
                                                "CiliumEnvoyConfig",
                                                "CiliumClusterwideEnvoyConfig"
                                              ]
                                            },
                                            "name": {
                                              "description": "Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where the listener is defined in.",
                                              "type": "string",
                                              "minLength": 1
                                            }
                                          }
                                        },
                                        "name": {
                                          "description": "Name is the name of the listener.",
                                          "type": "string",
                                          "minLength": 1
                                        }
                                      }
                                    },
                                    "originatingTLS": {
                                      "description": "OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.",
                                      "type": "object",
                                      "required": [
                                        "secret"
                                      ],
                                      "properties": {
                                        "certificate": {
                                          "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                          "type": "string"
                                        },
                                        "privateKey": {
                                          "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                          "type": "string"
                                        },
                                        "secret": {
                                          "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                          "type": "object",
                                          "required": [
                                            "name"
                                          ],
                                          "properties": {
                                            "name": {
                                              "description": "Name is the name of the secret.",
                                              "type": "string"
                                            },
                                            "namespace": {
                                              "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "trustedCA": {
                                          "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                          "type": "string"
                                        }
                                      }
                                    },
                                    "ports": {
                                      "description": "Ports is a list of L4 port/protocol",
                                      "type": "array",
                                      "items": {
                                        "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                                        "type": "object",
                                        "required": [
                                          "port"
                                        ],
                                        "properties": {
                                          "port": {
                                            "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                            "type": "string",
                                            "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                          },
                                          "protocol": {
                                            "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                            "type": "string",
                                            "enum": [
                                              "TCP",
                                              "UDP",
                                              "SCTP",
                                              "ANY"
                                            ]
                                          }
                                        }
                                      }
                                    },
                                    "rules": {
                                      "description": "Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.",
                                      "type": "object",
                                      "properties": {
                                        "dns": {
                                          "description": "DNS-specific rules.",
                                          "type": "array",
                                          "items": {
                                            "description": "PortRuleDNS is a list of allowed DNS lookups.",
                                            "type": "object",
                                            "properties": {
                                              "matchName": {
                                                "description": "MatchName matches literal DNS names. A trailing \".\" is automatically added when missing.",
                                                "type": "string",
                                                "pattern": "^([-a-zA-Z0-9_]+[.]?)+$"
                                              },
                                              "matchPattern": {
                                                "description": "MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"*\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"*\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: `*.cilium.io` matches subomains of cilium at that level   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with \"cilium.io\"   except those containing \".\" separator, subcilium.io and sub-cilium.io match,   www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\"   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,   blog.cilium.io, cilium.io and google.com do not",
                                                "type": "string",
                                                "pattern": "^([-a-zA-Z0-9_*]+[.]?)+$"
                                              }
                                            }
                                          }
                                        },
                                        "http": {
                                          "description": "HTTP specific rules.",
                                          "type": "array",
                                          "items": {
                                            "description": "PortRuleHTTP is a list of HTTP protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect. \n All fields of this type are extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986.",
                                            "type": "object",
                                            "properties": {
                                              "headerMatches": {
                                                "description": "HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match.",
                                                "type": "array",
                                                "items": {
                                                  "description": "HeaderMatch extends the HeaderValue for matching requirement of a named header field against an immediate string, a secret value, or a regex.  If none of the optional fields is present, then the header value is not matched, only presence of the header is enough.",
                                                  "type": "object",
                                                  "required": [
                                                    "name"
                                                  ],
                                                  "properties": {
                                                    "mismatch": {
                                                      "description": "Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.",
                                                      "type": "string",
                                                      "enum": [
                                                        "LOG",
                                                        "ADD",
                                                        "DELETE",
                                                        "REPLACE"
                                                      ]
                                                    },
                                                    "name": {
                                                      "description": "Name identifies the header.",
                                                      "type": "string"
                                                    },
                                                    "secret": {
                                                      "description": "Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no \"Value\" specified, the match will fail.",
                                                      "type": "object",
                                                      "required": [
                                                        "name"
                                                      ],
                                                      "properties": {
                                                        "name": {
                                                          "description": "Name is the name of the secret.",
                                                          "type": "string"
                                                        },
                                                        "namespace": {
                                                          "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                                          "type": "string"
                                                        }
                                                      }
                                                    },
                                                    "value": {
                                                      "description": "Value matches the exact value of the header. Can be specified either alone or together with \"Secret\"; will be used as the header value if the secret can not be found in the latter case.",
                                                      "type": "string"
                                                    }
                                                  }
                                                }
                                              },
                                              "headers": {
                                                "description": "Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present.",
                                                "type": "array",
                                                "items": {
                                                  "type": "string"
                                                }
                                              },
                                              "host": {
                                                "description": "Host is an extended POSIX regex matched against the host header of a request, e.g. \"foo.com\" \n If omitted or empty, the value of the host header is ignored.",
                                                "type": "string",
                                                "format": "idn-hostname"
                                              },
                                              "method": {
                                                "description": "Method is an extended POSIX regex matched against the method of a request, e.g. \"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\", ... \n If omitted or empty, all methods are allowed.",
                                                "type": "string"
                                              },
                                              "path": {
                                                "description": "Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986. \n If omitted or empty, all paths are all allowed.",
                                                "type": "string"
                                              }
                                            }
                                          }
                                        },
                                        "kafka": {
                                          "description": "Kafka-specific rules.",
                                          "type": "array",
                                          "items": {
                                            "description": "PortRule is a list of Kafka protocol constraints. All fields are optional, if all fields are empty or missing, the rule will match all Kafka messages.",
                                            "type": "object",
                                            "properties": {
                                              "apiKey": {
                                                "description": "APIKey is a case-insensitive string matched against the key of a request, e.g. \"produce\", \"fetch\", \"createtopic\", \"deletetopic\", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys \n If omitted or empty, and if Role is not specified, then all keys are allowed.",
                                                "type": "string"
                                              },
                                              "apiVersion": {
                                                "description": "APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer. \n If omitted or empty, all versions are allowed.",
                                                "type": "string"
                                              },
                                              "clientID": {
                                                "description": "ClientID is the client identifier as provided in the request. \n From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client. \n If omitted or empty, all client identifiers are allowed.",
                                                "type": "string"
                                              },
                                              "role": {
                                                "description": "Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as \"produce\" or \"consume\". A Role automatically expands into all APIKeys required to perform the specified higher-level operation. \n The following values are supported:  - \"produce\": Allow producing to the topics specified in the rule  - \"consume\": Allow consuming from the topics specified in the rule \n This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule. \n If omitted or empty, and if APIKey is not specified, then all keys are allowed.",
                                                "type": "string",
                                                "enum": [
                                                  "produce",
                                                  "consume"
                                                ]
                                              },
                                              "topic": {
                                                "description": "Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected. \n This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _. \n Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255. \n If omitted or empty, all topics are allowed.",
                                                "type": "string",
                                                "maxLength": 255
                                              }
                                            }
                                          }
                                        },
                                        "l7": {
                                          "description": "Key-value pair rules.",
                                          "type": "array",
                                          "items": {
                                            "description": "PortRuleL7 is a list of key-value pairs interpreted by a L7 protocol as protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect.",
                                            "type": "object",
                                            "additionalProperties": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "l7proto": {
                                          "description": "Name of the L7 protocol for which the Key-value pair rules apply.",
                                          "type": "string"
                                        }
                                      }
                                    },
                                    "serverNames": {
                                      "description": "ServerNames is a list of allowed TLS SNI values. If not empty, then TLS must be present and one of the provided SNIs must be indicated in the TLS handshake.",
                                      "type": "array",
                                      "items": {
                                        "type": "string"
                                      }
                                    },
                                    "terminatingTLS": {
                                      "description": "TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.",
                                      "type": "object",
                                      "required": [
                                        "secret"
                                      ],
                                      "properties": {
                                        "certificate": {
                                          "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                          "type": "string"
                                        },
                                        "privateKey": {
                                          "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                          "type": "string"
                                        },
                                        "secret": {
                                          "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                          "type": "object",
                                          "required": [
                                            "name"
                                          ],
                                          "properties": {
                                            "name": {
                                              "description": "Name is the name of the secret.",
                                              "type": "string"
                                            },
                                            "namespace": {
                                              "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "trustedCA": {
                                          "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                          "type": "string"
                                        }
                                      }
                                    }
                                  }
                                }
                              },
                              "toRequires": {
                                "description": "ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\".",
                                "type": "array",
                                "items": {
                                  "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                  "type": "object",
                                  "properties": {
                                    "matchExpressions": {
                                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                      "type": "array",
                                      "items": {
                                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                        "type": "object",
                                        "required": [
                                          "key",
                                          "operator"
                                        ],
                                        "properties": {
                                          "key": {
                                            "description": "key is the label key that the selector applies to.",
                                            "type": "string"
                                          },
                                          "operator": {
                                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                            "type": "string",
                                            "enum": [
                                              "In",
                                              "NotIn",
                                              "Exists",
                                              "DoesNotExist"
                                            ]
                                          },
                                          "values": {
                                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "matchLabels": {
                                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                      "type": "object",
                                      "additionalProperties": {
                                        "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                        "type": "string",
                                        "maxLength": 63,
                                        "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                      }
                                    }
                                  }
                                }
                              },
                              "toServices": {
                                "description": "ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service",
                                "type": "array",
                                "items": {
                                  "description": "Service wraps around selectors for services",
                                  "type": "object",
                                  "properties": {
                                    "k8sService": {
                                      "description": "K8sService selects service by name and namespace pair",
                                      "type": "object",
                                      "properties": {
                                        "namespace": {
                                          "type": "string"
                                        },
                                        "serviceName": {
                                          "type": "string"
                                        }
                                      }
                                    },
                                    "k8sServiceSelector": {
                                      "description": "K8sServiceSelector selects services by k8s labels and namespace",
                                      "type": "object",
                                      "required": [
                                        "selector"
                                      ],
                                      "properties": {
                                        "namespace": {
                                          "type": "string"
                                        },
                                        "selector": {
                                          "description": "ServiceSelector is a label selector for k8s services",
                                          "type": "object",
                                          "properties": {
                                            "matchExpressions": {
                                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                              "type": "array",
                                              "items": {
                                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                                "type": "object",
                                                "required": [
                                                  "key",
                                                  "operator"
                                                ],
                                                "properties": {
                                                  "key": {
                                                    "description": "key is the label key that the selector applies to.",
                                                    "type": "string"
                                                  },
                                                  "operator": {
                                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                                    "type": "string",
                                                    "enum": [
                                                      "In",
                                                      "NotIn",
                                                      "Exists",
                                                      "DoesNotExist"
                                                    ]
                                                  },
                                                  "values": {
                                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                                    "type": "array",
                                                    "items": {
                                                      "type": "string"
                                                    }
                                                  }
                                                }
                                              }
                                            },
                                            "matchLabels": {
                                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                              "type": "object",
                                              "additionalProperties": {
                                                "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                                "type": "string",
                                                "maxLength": 63,
                                                "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        "egressDeny": {
                          "description": "EgressDeny is a list of EgressDenyRule which are enforced at egress. Any rule inserted here will be denied regardless of the allowed egress rules in the 'egress' field. If omitted or empty, this rule does not apply at egress.",
                          "type": "array",
                          "items": {
                            "description": "EgressDenyRule contains all rule types which can be applied at egress, i.e. network traffic that originates inside the endpoint and exits the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members of the structure are specified, then all members     must match in order for the rule to take effect. The exception to this     rule is the ToRequires member; the effects of any Requires field in any     rule will apply to all other rules as well. \n   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are     mutually exclusive. Only one of these members may be present within an     individual rule.",
                            "type": "object",
                            "properties": {
                              "icmps": {
                                "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is not allowed to initiate type 8 ICMP connections.",
                                "type": "array",
                                "items": {
                                  "description": "ICMPRule is a list of ICMP fields.",
                                  "type": "object",
                                  "properties": {
                                    "fields": {
                                      "description": "Fields is a list of ICMP fields.",
                                      "type": "array",
                                      "items": {
                                        "description": "ICMPField is a ICMP field.",
                                        "type": "object",
                                        "required": [
                                          "type"
                                        ],
                                        "properties": {
                                          "family": {
                                            "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                            "type": "string",
                                            "default": "IPv4",
                                            "enum": [
                                              "IPv4",
                                              "IPv6"
                                            ]
                                          },
                                          "type": {
                                            "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                            "type": "integer",
                                            "maximum": 255,
                                            "minimum": 0
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              },
                              "toCIDR": {
                                "description": "ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules.  This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24",
                                "type": "array",
                                "items": {
                                  "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                  "type": "string",
                                  "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                }
                              },
                              "toCIDRSet": {
                                "description": "ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.",
                                "type": "array",
                                "items": {
                                  "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                                  "type": "object",
                                  "oneOf": [
                                    {
                                      "required": [
                                        "cidr"
                                      ],
                                      "properties": {
                                        "cidr": {}
                                      }
                                    },
                                    {
                                      "required": [
                                        "cidrGroupRef"
                                      ],
                                      "properties": {
                                        "cidrGroupRef": {}
                                      }
                                    }
                                  ],
                                  "properties": {
                                    "cidr": {
                                      "description": "CIDR is a CIDR prefix / IP Block.",
                                      "type": "string",
                                      "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                    },
                                    "cidrGroupRef": {
                                      "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                                      "type": "string",
                                      "maxLength": 253,
                                      "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                                    },
                                    "except": {
                                      "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                                      "type": "array",
                                      "items": {
                                        "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                        "type": "string",
                                        "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                      }
                                    }
                                  }
                                }
                              },
                              "toEndpoints": {
                                "description": "ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\".",
                                "type": "array",
                                "items": {
                                  "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                  "type": "object",
                                  "properties": {
                                    "matchExpressions": {
                                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                      "type": "array",
                                      "items": {
                                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                        "type": "object",
                                        "required": [
                                          "key",
                                          "operator"
                                        ],
                                        "properties": {
                                          "key": {
                                            "description": "key is the label key that the selector applies to.",
                                            "type": "string"
                                          },
                                          "operator": {
                                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                            "type": "string",
                                            "enum": [
                                              "In",
                                              "NotIn",
                                              "Exists",
                                              "DoesNotExist"
                                            ]
                                          },
                                          "values": {
                                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "matchLabels": {
                                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                      "type": "object",
                                      "additionalProperties": {
                                        "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                        "type": "string",
                                        "maxLength": 63,
                                        "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                      }
                                    }
                                  }
                                }
                              },
                              "toEntities": {
                                "description": "ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`, `health`,`unmanaged` and `all`.",
                                "type": "array",
                                "items": {
                                  "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                                  "type": "string",
                                  "enum": [
                                    "all",
                                    "world",
                                    "cluster",
                                    "host",
                                    "init",
                                    "ingress",
                                    "unmanaged",
                                    "remote-node",
                                    "health",
                                    "none",
                                    "kube-apiserver"
                                  ]
                                }
                              },
                              "toGroups": {
                                "description": "ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws:     securityGroupsIds:     - 'sg-XXXXXXXXXXXXX'",
                                "type": "array",
                                "items": {
                                  "description": "ToGroups structure to store all kinds of new integrations that needs a new derivative policy.",
                                  "type": "object",
                                  "properties": {
                                    "aws": {
                                      "description": "AWSGroup is an structure that can be used to whitelisting information from AWS integration",
                                      "type": "object",
                                      "properties": {
                                        "labels": {
                                          "type": "object",
                                          "additionalProperties": {
                                            "type": "string"
                                          }
                                        },
                                        "region": {
                                          "type": "string"
                                        },
                                        "securityGroupsIds": {
                                          "type": "array",
                                          "items": {
                                            "type": "string"
                                          }
                                        },
                                        "securityGroupsNames": {
                                          "type": "array",
                                          "items": {
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              },
                              "toPorts": {
                                "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is not allowed to initiate connections to destination port 8080/tcp",
                                "type": "array",
                                "items": {
                                  "description": "PortDenyRule is a list of ports/protocol that should be used for deny policies. This structure lacks the L7Rules since it's not supported in deny policies.",
                                  "type": "object",
                                  "properties": {
                                    "ports": {
                                      "description": "Ports is a list of L4 port/protocol",
                                      "type": "array",
                                      "items": {
                                        "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                                        "type": "object",
                                        "required": [
                                          "port"
                                        ],
                                        "properties": {
                                          "port": {
                                            "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                            "type": "string",
                                            "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                          },
                                          "protocol": {
                                            "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                            "type": "string",
                                            "enum": [
                                              "TCP",
                                              "UDP",
                                              "SCTP",
                                              "ANY"
                                            ]
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              },
                              "toRequires": {
                                "description": "ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\".",
                                "type": "array",
                                "items": {
                                  "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                  "type": "object",
                                  "properties": {
                                    "matchExpressions": {
                                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                      "type": "array",
                                      "items": {
                                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                        "type": "object",
                                        "required": [
                                          "key",
                                          "operator"
                                        ],
                                        "properties": {
                                          "key": {
                                            "description": "key is the label key that the selector applies to.",
                                            "type": "string"
                                          },
                                          "operator": {
                                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                            "type": "string",
                                            "enum": [
                                              "In",
                                              "NotIn",
                                              "Exists",
                                              "DoesNotExist"
                                            ]
                                          },
                                          "values": {
                                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "matchLabels": {
                                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                      "type": "object",
                                      "additionalProperties": {
                                        "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                        "type": "string",
                                        "maxLength": 63,
                                        "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                      }
                                    }
                                  }
                                }
                              },
                              "toServices": {
                                "description": "ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service",
                                "type": "array",
                                "items": {
                                  "description": "Service wraps around selectors for services",
                                  "type": "object",
                                  "properties": {
                                    "k8sService": {
                                      "description": "K8sService selects service by name and namespace pair",
                                      "type": "object",
                                      "properties": {
                                        "namespace": {
                                          "type": "string"
                                        },
                                        "serviceName": {
                                          "type": "string"
                                        }
                                      }
                                    },
                                    "k8sServiceSelector": {
                                      "description": "K8sServiceSelector selects services by k8s labels and namespace",
                                      "type": "object",
                                      "required": [
                                        "selector"
                                      ],
                                      "properties": {
                                        "namespace": {
                                          "type": "string"
                                        },
                                        "selector": {
                                          "description": "ServiceSelector is a label selector for k8s services",
                                          "type": "object",
                                          "properties": {
                                            "matchExpressions": {
                                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                              "type": "array",
                                              "items": {
                                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                                "type": "object",
                                                "required": [
                                                  "key",
                                                  "operator"
                                                ],
                                                "properties": {
                                                  "key": {
                                                    "description": "key is the label key that the selector applies to.",
                                                    "type": "string"
                                                  },
                                                  "operator": {
                                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                                    "type": "string",
                                                    "enum": [
                                                      "In",
                                                      "NotIn",
                                                      "Exists",
                                                      "DoesNotExist"
                                                    ]
                                                  },
                                                  "values": {
                                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                                    "type": "array",
                                                    "items": {
                                                      "type": "string"
                                                    }
                                                  }
                                                }
                                              }
                                            },
                                            "matchLabels": {
                                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                              "type": "object",
                                              "additionalProperties": {
                                                "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                                "type": "string",
                                                "maxLength": 63,
                                                "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        "endpointSelector": {
                          "description": "EndpointSelector selects all endpoints which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive.",
                          "type": "object",
                          "properties": {
                            "matchExpressions": {
                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                              "type": "array",
                              "items": {
                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "key is the label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                    "type": "string",
                                    "enum": [
                                      "In",
                                      "NotIn",
                                      "Exists",
                                      "DoesNotExist"
                                    ]
                                  },
                                  "values": {
                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "matchLabels": {
                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                              "type": "object",
                              "additionalProperties": {
                                "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                "type": "string",
                                "maxLength": 63,
                                "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                              }
                            }
                          }
                        },
                        "ingress": {
                          "description": "Ingress is a list of IngressRule which are enforced at ingress. If omitted or empty, this rule does not apply at ingress.",
                          "type": "array",
                          "items": {
                            "description": "IngressRule contains all rule types which can be applied at ingress, i.e. network traffic that originates outside of the endpoint and is entering the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members are set, all of them need to match in order for     the rule to take effect. The exception to this rule is FromRequires field;     the effects of any Requires field in any rule will apply to all other     rules as well. \n   - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually     exclusive. Only one of these members may be present within an individual     rule.",
                            "type": "object",
                            "properties": {
                              "authentication": {
                                "description": "Authentication is the required authentication type for the allowed traffic, if any.",
                                "type": "object",
                                "required": [
                                  "mode"
                                ],
                                "properties": {
                                  "mode": {
                                    "description": "Mode is the required authentication mode for the allowed traffic, if any.",
                                    "type": "string",
                                    "enum": [
                                      "disabled",
                                      "required",
                                      "test-always-fail"
                                    ]
                                  }
                                }
                              },
                              "fromCIDR": {
                                "description": "FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do *not* originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field.  This will match on the source IP address of incoming connections. Adding  a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.3.9.1",
                                "type": "array",
                                "items": {
                                  "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                  "type": "string",
                                  "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                }
                              },
                              "fromCIDRSet": {
                                "description": "FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.",
                                "type": "array",
                                "items": {
                                  "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                                  "type": "object",
                                  "oneOf": [
                                    {
                                      "required": [
                                        "cidr"
                                      ],
                                      "properties": {
                                        "cidr": {}
                                      }
                                    },
                                    {
                                      "required": [
                                        "cidrGroupRef"
                                      ],
                                      "properties": {
                                        "cidrGroupRef": {}
                                      }
                                    }
                                  ],
                                  "properties": {
                                    "cidr": {
                                      "description": "CIDR is a CIDR prefix / IP Block.",
                                      "type": "string",
                                      "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                    },
                                    "cidrGroupRef": {
                                      "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                                      "type": "string",
                                      "maxLength": 253,
                                      "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                                    },
                                    "except": {
                                      "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                                      "type": "array",
                                      "items": {
                                        "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                        "type": "string",
                                        "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                      }
                                    }
                                  }
                                }
                              },
                              "fromEndpoints": {
                                "description": "FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\".",
                                "type": "array",
                                "items": {
                                  "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                  "type": "object",
                                  "properties": {
                                    "matchExpressions": {
                                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                      "type": "array",
                                      "items": {
                                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                        "type": "object",
                                        "required": [
                                          "key",
                                          "operator"
                                        ],
                                        "properties": {
                                          "key": {
                                            "description": "key is the label key that the selector applies to.",
                                            "type": "string"
                                          },
                                          "operator": {
                                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                            "type": "string",
                                            "enum": [
                                              "In",
                                              "NotIn",
                                              "Exists",
                                              "DoesNotExist"
                                            ]
                                          },
                                          "values": {
                                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "matchLabels": {
                                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                      "type": "object",
                                      "additionalProperties": {
                                        "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                        "type": "string",
                                        "maxLength": 63,
                                        "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                      }
                                    }
                                  }
                                }
                              },
                              "fromEntities": {
                                "description": "FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are `world`, `cluster` and `host`",
                                "type": "array",
                                "items": {
                                  "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                                  "type": "string",
                                  "enum": [
                                    "all",
                                    "world",
                                    "cluster",
                                    "host",
                                    "init",
                                    "ingress",
                                    "unmanaged",
                                    "remote-node",
                                    "health",
                                    "none",
                                    "kube-apiserver"
                                  ]
                                }
                              },
                              "fromRequires": {
                                "description": "FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\".",
                                "type": "array",
                                "items": {
                                  "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                  "type": "object",
                                  "properties": {
                                    "matchExpressions": {
                                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                      "type": "array",
                                      "items": {
                                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                        "type": "object",
                                        "required": [
                                          "key",
                                          "operator"
                                        ],
                                        "properties": {
                                          "key": {
                                            "description": "key is the label key that the selector applies to.",
                                            "type": "string"
                                          },
                                          "operator": {
                                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                            "type": "string",
                                            "enum": [
                                              "In",
                                              "NotIn",
                                              "Exists",
                                              "DoesNotExist"
                                            ]
                                          },
                                          "values": {
                                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "matchLabels": {
                                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                      "type": "object",
                                      "additionalProperties": {
                                        "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                        "type": "string",
                                        "maxLength": 63,
                                        "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                      }
                                    }
                                  }
                                }
                              },
                              "icmps": {
                                "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming type 8 ICMP connections.",
                                "type": "array",
                                "items": {
                                  "description": "ICMPRule is a list of ICMP fields.",
                                  "type": "object",
                                  "properties": {
                                    "fields": {
                                      "description": "Fields is a list of ICMP fields.",
                                      "type": "array",
                                      "items": {
                                        "description": "ICMPField is a ICMP field.",
                                        "type": "object",
                                        "required": [
                                          "type"
                                        ],
                                        "properties": {
                                          "family": {
                                            "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                            "type": "string",
                                            "default": "IPv4",
                                            "enum": [
                                              "IPv4",
                                              "IPv6"
                                            ]
                                          },
                                          "type": {
                                            "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                            "type": "integer",
                                            "maximum": 255,
                                            "minimum": 0
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              },
                              "toPorts": {
                                "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming connections on port 80/tcp.",
                                "type": "array",
                                "items": {
                                  "description": "PortRule is a list of ports/protocol combinations with optional Layer 7 rules which must be met.",
                                  "type": "object",
                                  "properties": {
                                    "listener": {
                                      "description": "listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.",
                                      "type": "object",
                                      "required": [
                                        "envoyConfig",
                                        "name"
                                      ],
                                      "properties": {
                                        "envoyConfig": {
                                          "description": "EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.",
                                          "type": "object",
                                          "required": [
                                            "name"
                                          ],
                                          "properties": {
                                            "kind": {
                                              "description": "Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.",
                                              "type": "string",
                                              "enum": [
                                                "CiliumEnvoyConfig",
                                                "CiliumClusterwideEnvoyConfig"
                                              ]
                                            },
                                            "name": {
                                              "description": "Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where the listener is defined in.",
                                              "type": "string",
                                              "minLength": 1
                                            }
                                          }
                                        },
                                        "name": {
                                          "description": "Name is the name of the listener.",
                                          "type": "string",
                                          "minLength": 1
                                        }
                                      }
                                    },
                                    "originatingTLS": {
                                      "description": "OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.",
                                      "type": "object",
                                      "required": [
                                        "secret"
                                      ],
                                      "properties": {
                                        "certificate": {
                                          "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                          "type": "string"
                                        },
                                        "privateKey": {
                                          "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                          "type": "string"
                                        },
                                        "secret": {
                                          "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                          "type": "object",
                                          "required": [
                                            "name"
                                          ],
                                          "properties": {
                                            "name": {
                                              "description": "Name is the name of the secret.",
                                              "type": "string"
                                            },
                                            "namespace": {
                                              "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "trustedCA": {
                                          "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                          "type": "string"
                                        }
                                      }
                                    },
                                    "ports": {
                                      "description": "Ports is a list of L4 port/protocol",
                                      "type": "array",
                                      "items": {
                                        "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                                        "type": "object",
                                        "required": [
                                          "port"
                                        ],
                                        "properties": {
                                          "port": {
                                            "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                            "type": "string",
                                            "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                          },
                                          "protocol": {
                                            "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                            "type": "string",
                                            "enum": [
                                              "TCP",
                                              "UDP",
                                              "SCTP",
                                              "ANY"
                                            ]
                                          }
                                        }
                                      }
                                    },
                                    "rules": {
                                      "description": "Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.",
                                      "type": "object",
                                      "properties": {
                                        "dns": {
                                          "description": "DNS-specific rules.",
                                          "type": "array",
                                          "items": {
                                            "description": "PortRuleDNS is a list of allowed DNS lookups.",
                                            "type": "object",
                                            "properties": {
                                              "matchName": {
                                                "description": "MatchName matches literal DNS names. A trailing \".\" is automatically added when missing.",
                                                "type": "string",
                                                "pattern": "^([-a-zA-Z0-9_]+[.]?)+$"
                                              },
                                              "matchPattern": {
                                                "description": "MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"*\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"*\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: `*.cilium.io` matches subomains of cilium at that level   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with \"cilium.io\"   except those containing \".\" separator, subcilium.io and sub-cilium.io match,   www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\"   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,   blog.cilium.io, cilium.io and google.com do not",
                                                "type": "string",
                                                "pattern": "^([-a-zA-Z0-9_*]+[.]?)+$"
                                              }
                                            }
                                          }
                                        },
                                        "http": {
                                          "description": "HTTP specific rules.",
                                          "type": "array",
                                          "items": {
                                            "description": "PortRuleHTTP is a list of HTTP protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect. \n All fields of this type are extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986.",
                                            "type": "object",
                                            "properties": {
                                              "headerMatches": {
                                                "description": "HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match.",
                                                "type": "array",
                                                "items": {
                                                  "description": "HeaderMatch extends the HeaderValue for matching requirement of a named header field against an immediate string, a secret value, or a regex.  If none of the optional fields is present, then the header value is not matched, only presence of the header is enough.",
                                                  "type": "object",
                                                  "required": [
                                                    "name"
                                                  ],
                                                  "properties": {
                                                    "mismatch": {
                                                      "description": "Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.",
                                                      "type": "string",
                                                      "enum": [
                                                        "LOG",
                                                        "ADD",
                                                        "DELETE",
                                                        "REPLACE"
                                                      ]
                                                    },
                                                    "name": {
                                                      "description": "Name identifies the header.",
                                                      "type": "string"
                                                    },
                                                    "secret": {
                                                      "description": "Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no \"Value\" specified, the match will fail.",
                                                      "type": "object",
                                                      "required": [
                                                        "name"
                                                      ],
                                                      "properties": {
                                                        "name": {
                                                          "description": "Name is the name of the secret.",
                                                          "type": "string"
                                                        },
                                                        "namespace": {
                                                          "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                                          "type": "string"
                                                        }
                                                      }
                                                    },
                                                    "value": {
                                                      "description": "Value matches the exact value of the header. Can be specified either alone or together with \"Secret\"; will be used as the header value if the secret can not be found in the latter case.",
                                                      "type": "string"
                                                    }
                                                  }
                                                }
                                              },
                                              "headers": {
                                                "description": "Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present.",
                                                "type": "array",
                                                "items": {
                                                  "type": "string"
                                                }
                                              },
                                              "host": {
                                                "description": "Host is an extended POSIX regex matched against the host header of a request, e.g. \"foo.com\" \n If omitted or empty, the value of the host header is ignored.",
                                                "type": "string",
                                                "format": "idn-hostname"
                                              },
                                              "method": {
                                                "description": "Method is an extended POSIX regex matched against the method of a request, e.g. \"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\", ... \n If omitted or empty, all methods are allowed.",
                                                "type": "string"
                                              },
                                              "path": {
                                                "description": "Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986. \n If omitted or empty, all paths are all allowed.",
                                                "type": "string"
                                              }
                                            }
                                          }
                                        },
                                        "kafka": {
                                          "description": "Kafka-specific rules.",
                                          "type": "array",
                                          "items": {
                                            "description": "PortRule is a list of Kafka protocol constraints. All fields are optional, if all fields are empty or missing, the rule will match all Kafka messages.",
                                            "type": "object",
                                            "properties": {
                                              "apiKey": {
                                                "description": "APIKey is a case-insensitive string matched against the key of a request, e.g. \"produce\", \"fetch\", \"createtopic\", \"deletetopic\", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys \n If omitted or empty, and if Role is not specified, then all keys are allowed.",
                                                "type": "string"
                                              },
                                              "apiVersion": {
                                                "description": "APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer. \n If omitted or empty, all versions are allowed.",
                                                "type": "string"
                                              },
                                              "clientID": {
                                                "description": "ClientID is the client identifier as provided in the request. \n From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client. \n If omitted or empty, all client identifiers are allowed.",
                                                "type": "string"
                                              },
                                              "role": {
                                                "description": "Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as \"produce\" or \"consume\". A Role automatically expands into all APIKeys required to perform the specified higher-level operation. \n The following values are supported:  - \"produce\": Allow producing to the topics specified in the rule  - \"consume\": Allow consuming from the topics specified in the rule \n This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule. \n If omitted or empty, and if APIKey is not specified, then all keys are allowed.",
                                                "type": "string",
                                                "enum": [
                                                  "produce",
                                                  "consume"
                                                ]
                                              },
                                              "topic": {
                                                "description": "Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected. \n This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _. \n Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255. \n If omitted or empty, all topics are allowed.",
                                                "type": "string",
                                                "maxLength": 255
                                              }
                                            }
                                          }
                                        },
                                        "l7": {
                                          "description": "Key-value pair rules.",
                                          "type": "array",
                                          "items": {
                                            "description": "PortRuleL7 is a list of key-value pairs interpreted by a L7 protocol as protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect.",
                                            "type": "object",
                                            "additionalProperties": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "l7proto": {
                                          "description": "Name of the L7 protocol for which the Key-value pair rules apply.",
                                          "type": "string"
                                        }
                                      }
                                    },
                                    "serverNames": {
                                      "description": "ServerNames is a list of allowed TLS SNI values. If not empty, then TLS must be present and one of the provided SNIs must be indicated in the TLS handshake.",
                                      "type": "array",
                                      "items": {
                                        "type": "string"
                                      }
                                    },
                                    "terminatingTLS": {
                                      "description": "TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.",
                                      "type": "object",
                                      "required": [
                                        "secret"
                                      ],
                                      "properties": {
                                        "certificate": {
                                          "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                          "type": "string"
                                        },
                                        "privateKey": {
                                          "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                          "type": "string"
                                        },
                                        "secret": {
                                          "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                          "type": "object",
                                          "required": [
                                            "name"
                                          ],
                                          "properties": {
                                            "name": {
                                              "description": "Name is the name of the secret.",
                                              "type": "string"
                                            },
                                            "namespace": {
                                              "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "trustedCA": {
                                          "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                          "type": "string"
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        "ingressDeny": {
                          "description": "IngressDeny is a list of IngressDenyRule which are enforced at ingress. Any rule inserted here will be denied regardless of the allowed ingress rules in the 'ingress' field. If omitted or empty, this rule does not apply at ingress.",
                          "type": "array",
                          "items": {
                            "description": "IngressDenyRule contains all rule types which can be applied at ingress, i.e. network traffic that originates outside of the endpoint and is entering the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members are set, all of them need to match in order for     the rule to take effect. The exception to this rule is FromRequires field;     the effects of any Requires field in any rule will apply to all other     rules as well. \n   - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually     exclusive. Only one of these members may be present within an individual     rule.",
                            "type": "object",
                            "properties": {
                              "fromCIDR": {
                                "description": "FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do *not* originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field.  This will match on the source IP address of incoming connections. Adding  a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.3.9.1",
                                "type": "array",
                                "items": {
                                  "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                  "type": "string",
                                  "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                }
                              },
                              "fromCIDRSet": {
                                "description": "FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.",
                                "type": "array",
                                "items": {
                                  "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                                  "type": "object",
                                  "oneOf": [
                                    {
                                      "required": [
                                        "cidr"
                                      ],
                                      "properties": {
                                        "cidr": {}
                                      }
                                    },
                                    {
                                      "required": [
                                        "cidrGroupRef"
                                      ],
                                      "properties": {
                                        "cidrGroupRef": {}
                                      }
                                    }
                                  ],
                                  "properties": {
                                    "cidr": {
                                      "description": "CIDR is a CIDR prefix / IP Block.",
                                      "type": "string",
                                      "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                    },
                                    "cidrGroupRef": {
                                      "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                                      "type": "string",
                                      "maxLength": 253,
                                      "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                                    },
                                    "except": {
                                      "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                                      "type": "array",
                                      "items": {
                                        "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                        "type": "string",
                                        "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                      }
                                    }
                                  }
                                }
                              },
                              "fromEndpoints": {
                                "description": "FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\".",
                                "type": "array",
                                "items": {
                                  "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                  "type": "object",
                                  "properties": {
                                    "matchExpressions": {
                                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                      "type": "array",
                                      "items": {
                                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                        "type": "object",
                                        "required": [
                                          "key",
                                          "operator"
                                        ],
                                        "properties": {
                                          "key": {
                                            "description": "key is the label key that the selector applies to.",
                                            "type": "string"
                                          },
                                          "operator": {
                                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                            "type": "string",
                                            "enum": [
                                              "In",
                                              "NotIn",
                                              "Exists",
                                              "DoesNotExist"
                                            ]
                                          },
                                          "values": {
                                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "matchLabels": {
                                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                      "type": "object",
                                      "additionalProperties": {
                                        "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                        "type": "string",
                                        "maxLength": 63,
                                        "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                      }
                                    }
                                  }
                                }
                              },
                              "fromEntities": {
                                "description": "FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are `world`, `cluster` and `host`",
                                "type": "array",
                                "items": {
                                  "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                                  "type": "string",
                                  "enum": [
                                    "all",
                                    "world",
                                    "cluster",
                                    "host",
                                    "init",
                                    "ingress",
                                    "unmanaged",
                                    "remote-node",
                                    "health",
                                    "none",
                                    "kube-apiserver"
                                  ]
                                }
                              },
                              "fromRequires": {
                                "description": "FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\".",
                                "type": "array",
                                "items": {
                                  "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                  "type": "object",
                                  "properties": {
                                    "matchExpressions": {
                                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                      "type": "array",
                                      "items": {
                                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                        "type": "object",
                                        "required": [
                                          "key",
                                          "operator"
                                        ],
                                        "properties": {
                                          "key": {
                                            "description": "key is the label key that the selector applies to.",
                                            "type": "string"
                                          },
                                          "operator": {
                                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                            "type": "string",
                                            "enum": [
                                              "In",
                                              "NotIn",
                                              "Exists",
                                              "DoesNotExist"
                                            ]
                                          },
                                          "values": {
                                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "matchLabels": {
                                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                      "type": "object",
                                      "additionalProperties": {
                                        "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                        "type": "string",
                                        "maxLength": 63,
                                        "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                      }
                                    }
                                  }
                                }
                              },
                              "icmps": {
                                "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming type 8 ICMP connections.",
                                "type": "array",
                                "items": {
                                  "description": "ICMPRule is a list of ICMP fields.",
                                  "type": "object",
                                  "properties": {
                                    "fields": {
                                      "description": "Fields is a list of ICMP fields.",
                                      "type": "array",
                                      "items": {
                                        "description": "ICMPField is a ICMP field.",
                                        "type": "object",
                                        "required": [
                                          "type"
                                        ],
                                        "properties": {
                                          "family": {
                                            "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                            "type": "string",
                                            "default": "IPv4",
                                            "enum": [
                                              "IPv4",
                                              "IPv6"
                                            ]
                                          },
                                          "type": {
                                            "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                            "type": "integer",
                                            "maximum": 255,
                                            "minimum": 0
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              },
                              "toPorts": {
                                "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming connections on port 80/tcp.",
                                "type": "array",
                                "items": {
                                  "description": "PortDenyRule is a list of ports/protocol that should be used for deny policies. This structure lacks the L7Rules since it's not supported in deny policies.",
                                  "type": "object",
                                  "properties": {
                                    "ports": {
                                      "description": "Ports is a list of L4 port/protocol",
                                      "type": "array",
                                      "items": {
                                        "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                                        "type": "object",
                                        "required": [
                                          "port"
                                        ],
                                        "properties": {
                                          "port": {
                                            "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                            "type": "string",
                                            "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                          },
                                          "protocol": {
                                            "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                            "type": "string",
                                            "enum": [
                                              "TCP",
                                              "UDP",
                                              "SCTP",
                                              "ANY"
                                            ]
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        "labels": {
                          "description": "Labels is a list of optional strings which can be used to re-identify the rule or to store metadata. It is possible to lookup or delete strings based on labels. Labels are not required to be unique, multiple rules can have overlapping or identical labels.",
                          "type": "array",
                          "items": {
                            "description": "Label is the Cilium's representation of a container label.",
                            "type": "object",
                            "required": [
                              "key"
                            ],
                            "properties": {
                              "key": {
                                "type": "string"
                              },
                              "source": {
                                "description": "Source can be one of the above values (e.g.: LabelSourceContainer).",
                                "type": "string"
                              },
                              "value": {
                                "type": "string"
                              }
                            }
                          }
                        },
                        "nodeSelector": {
                          "description": "NodeSelector selects all nodes which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive. Can only be used in CiliumClusterwideNetworkPolicies.",
                          "type": "object",
                          "properties": {
                            "matchExpressions": {
                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                              "type": "array",
                              "items": {
                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "key is the label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                    "type": "string",
                                    "enum": [
                                      "In",
                                      "NotIn",
                                      "Exists",
                                      "DoesNotExist"
                                    ]
                                  },
                                  "values": {
                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "matchLabels": {
                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                              "type": "object",
                              "additionalProperties": {
                                "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                "type": "string",
                                "maxLength": 63,
                                "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                              }
                            }
                          }
                        }
                      }
                    },
                    "specs": {
                      "description": "Specs is a list of desired Cilium specific rule specification.",
                      "type": "array",
                      "items": {
                        "description": "Rule is a policy rule which must be applied to all endpoints which match the labels contained in the endpointSelector \n Each rule is split into an ingress section which contains all rules applicable at ingress, and an egress section applicable at egress. For rule types such as `L4Rule` and `CIDR` which can be applied at both ingress and egress, both ingress and egress side have to either specifically allow the connection or one side has to be omitted. \n Either ingress, egress, or both can be provided. If both ingress and egress are omitted, the rule has no effect.",
                        "type": "object",
                        "oneOf": [
                          {
                            "required": [
                              "endpointSelector"
                            ],
                            "properties": {
                              "endpointSelector": {}
                            }
                          },
                          {
                            "required": [
                              "nodeSelector"
                            ],
                            "properties": {
                              "nodeSelector": {}
                            }
                          }
                        ],
                        "properties": {
                          "description": {
                            "description": "Description is a free form string, it can be used by the creator of the rule to store human readable explanation of the purpose of this rule. Rules cannot be identified by comment.",
                            "type": "string"
                          },
                          "egress": {
                            "description": "Egress is a list of EgressRule which are enforced at egress. If omitted or empty, this rule does not apply at egress.",
                            "type": "array",
                            "items": {
                              "description": "EgressRule contains all rule types which can be applied at egress, i.e. network traffic that originates inside the endpoint and exits the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members of the structure are specified, then all members     must match in order for the rule to take effect. The exception to this     rule is the ToRequires member; the effects of any Requires field in any     rule will apply to all other rules as well. \n   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are     mutually exclusive. Only one of these members may be present within an     individual rule.",
                              "type": "object",
                              "properties": {
                                "authentication": {
                                  "description": "Authentication is the required authentication type for the allowed traffic, if any.",
                                  "type": "object",
                                  "required": [
                                    "mode"
                                  ],
                                  "properties": {
                                    "mode": {
                                      "description": "Mode is the required authentication mode for the allowed traffic, if any.",
                                      "type": "string",
                                      "enum": [
                                        "disabled",
                                        "required",
                                        "test-always-fail"
                                      ]
                                    }
                                  }
                                },
                                "icmps": {
                                  "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is allowed to initiate type 8 ICMP connections.",
                                  "type": "array",
                                  "items": {
                                    "description": "ICMPRule is a list of ICMP fields.",
                                    "type": "object",
                                    "properties": {
                                      "fields": {
                                        "description": "Fields is a list of ICMP fields.",
                                        "type": "array",
                                        "items": {
                                          "description": "ICMPField is a ICMP field.",
                                          "type": "object",
                                          "required": [
                                            "type"
                                          ],
                                          "properties": {
                                            "family": {
                                              "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                              "type": "string",
                                              "default": "IPv4",
                                              "enum": [
                                                "IPv4",
                                                "IPv6"
                                              ]
                                            },
                                            "type": {
                                              "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                              "type": "integer",
                                              "maximum": 255,
                                              "minimum": 0
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                "toCIDR": {
                                  "description": "ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules.  This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24",
                                  "type": "array",
                                  "items": {
                                    "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                    "type": "string",
                                    "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                  }
                                },
                                "toCIDRSet": {
                                  "description": "ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.",
                                  "type": "array",
                                  "items": {
                                    "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                                    "type": "object",
                                    "oneOf": [
                                      {
                                        "required": [
                                          "cidr"
                                        ],
                                        "properties": {
                                          "cidr": {}
                                        }
                                      },
                                      {
                                        "required": [
                                          "cidrGroupRef"
                                        ],
                                        "properties": {
                                          "cidrGroupRef": {}
                                        }
                                      }
                                    ],
                                    "properties": {
                                      "cidr": {
                                        "description": "CIDR is a CIDR prefix / IP Block.",
                                        "type": "string",
                                        "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                      },
                                      "cidrGroupRef": {
                                        "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                                        "type": "string",
                                        "maxLength": 253,
                                        "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                                      },
                                      "except": {
                                        "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                                        "type": "array",
                                        "items": {
                                          "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                          "type": "string",
                                          "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                        }
                                      }
                                    }
                                  }
                                },
                                "toEndpoints": {
                                  "description": "ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\".",
                                  "type": "array",
                                  "items": {
                                    "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string",
                                              "enum": [
                                                "In",
                                                "NotIn",
                                                "Exists",
                                                "DoesNotExist"
                                              ]
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                          "type": "string",
                                          "maxLength": 63,
                                          "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                        }
                                      }
                                    }
                                  }
                                },
                                "toEntities": {
                                  "description": "ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`, `health`,`unmanaged` and `all`.",
                                  "type": "array",
                                  "items": {
                                    "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                                    "type": "string",
                                    "enum": [
                                      "all",
                                      "world",
                                      "cluster",
                                      "host",
                                      "init",
                                      "ingress",
                                      "unmanaged",
                                      "remote-node",
                                      "health",
                                      "none",
                                      "kube-apiserver"
                                    ]
                                  }
                                },
                                "toFQDNs": {
                                  "description": "ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result from DNS resolution of `ToFQDN.MatchName`s are added to the same EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and L7 rules within this EgressRule will also apply to these IPs. The DNS -> IP mapping is re-resolved periodically from within the cilium-agent, and the IPs in the DNS response are effected in the policy for selected pods as-is (i.e. the list of IPs is not modified in any way). Note: An explicit rule to allow for DNS traffic is needed for the pods, as ToFQDN counts as an egress rule and will enforce egress policy when PolicyEnforcment=default. Note: If the resolved IPs are IPs within the kubernetes cluster, the ToFQDN rule will not apply to that IP. Note: ToFQDN cannot occur in the same policy as other To* rules.",
                                  "type": "array",
                                  "items": {
                                    "type": "object",
                                    "properties": {
                                      "matchName": {
                                        "description": "MatchName matches literal DNS names. A trailing \".\" is automatically added when missing.",
                                        "type": "string",
                                        "pattern": "^([-a-zA-Z0-9_]+[.]?)+$"
                                      },
                                      "matchPattern": {
                                        "description": "MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"*\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"*\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: `*.cilium.io` matches subomains of cilium at that level   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with \"cilium.io\"   except those containing \".\" separator, subcilium.io and sub-cilium.io match,   www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\"   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,   blog.cilium.io, cilium.io and google.com do not",
                                        "type": "string",
                                        "pattern": "^([-a-zA-Z0-9_*]+[.]?)+$"
                                      }
                                    }
                                  }
                                },
                                "toGroups": {
                                  "description": "ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws:     securityGroupsIds:     - 'sg-XXXXXXXXXXXXX'",
                                  "type": "array",
                                  "items": {
                                    "description": "ToGroups structure to store all kinds of new integrations that needs a new derivative policy.",
                                    "type": "object",
                                    "properties": {
                                      "aws": {
                                        "description": "AWSGroup is an structure that can be used to whitelisting information from AWS integration",
                                        "type": "object",
                                        "properties": {
                                          "labels": {
                                            "type": "object",
                                            "additionalProperties": {
                                              "type": "string"
                                            }
                                          },
                                          "region": {
                                            "type": "string"
                                          },
                                          "securityGroupsIds": {
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          },
                                          "securityGroupsNames": {
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                "toPorts": {
                                  "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is allowed to initiate connections to destination port 8080/tcp",
                                  "type": "array",
                                  "items": {
                                    "description": "PortRule is a list of ports/protocol combinations with optional Layer 7 rules which must be met.",
                                    "type": "object",
                                    "properties": {
                                      "listener": {
                                        "description": "listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.",
                                        "type": "object",
                                        "required": [
                                          "envoyConfig",
                                          "name"
                                        ],
                                        "properties": {
                                          "envoyConfig": {
                                            "description": "EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.",
                                            "type": "object",
                                            "required": [
                                              "name"
                                            ],
                                            "properties": {
                                              "kind": {
                                                "description": "Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.",
                                                "type": "string",
                                                "enum": [
                                                  "CiliumEnvoyConfig",
                                                  "CiliumClusterwideEnvoyConfig"
                                                ]
                                              },
                                              "name": {
                                                "description": "Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where the listener is defined in.",
                                                "type": "string",
                                                "minLength": 1
                                              }
                                            }
                                          },
                                          "name": {
                                            "description": "Name is the name of the listener.",
                                            "type": "string",
                                            "minLength": 1
                                          }
                                        }
                                      },
                                      "originatingTLS": {
                                        "description": "OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.",
                                        "type": "object",
                                        "required": [
                                          "secret"
                                        ],
                                        "properties": {
                                          "certificate": {
                                            "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                            "type": "string"
                                          },
                                          "privateKey": {
                                            "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                            "type": "string"
                                          },
                                          "secret": {
                                            "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                            "type": "object",
                                            "required": [
                                              "name"
                                            ],
                                            "properties": {
                                              "name": {
                                                "description": "Name is the name of the secret.",
                                                "type": "string"
                                              },
                                              "namespace": {
                                                "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                                "type": "string"
                                              }
                                            }
                                          },
                                          "trustedCA": {
                                            "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                            "type": "string"
                                          }
                                        }
                                      },
                                      "ports": {
                                        "description": "Ports is a list of L4 port/protocol",
                                        "type": "array",
                                        "items": {
                                          "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                                          "type": "object",
                                          "required": [
                                            "port"
                                          ],
                                          "properties": {
                                            "port": {
                                              "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                              "type": "string",
                                              "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                            },
                                            "protocol": {
                                              "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                              "type": "string",
                                              "enum": [
                                                "TCP",
                                                "UDP",
                                                "SCTP",
                                                "ANY"
                                              ]
                                            }
                                          }
                                        }
                                      },
                                      "rules": {
                                        "description": "Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.",
                                        "type": "object",
                                        "properties": {
                                          "dns": {
                                            "description": "DNS-specific rules.",
                                            "type": "array",
                                            "items": {
                                              "description": "PortRuleDNS is a list of allowed DNS lookups.",
                                              "type": "object",
                                              "properties": {
                                                "matchName": {
                                                  "description": "MatchName matches literal DNS names. A trailing \".\" is automatically added when missing.",
                                                  "type": "string",
                                                  "pattern": "^([-a-zA-Z0-9_]+[.]?)+$"
                                                },
                                                "matchPattern": {
                                                  "description": "MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"*\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"*\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: `*.cilium.io` matches subomains of cilium at that level   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with \"cilium.io\"   except those containing \".\" separator, subcilium.io and sub-cilium.io match,   www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\"   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,   blog.cilium.io, cilium.io and google.com do not",
                                                  "type": "string",
                                                  "pattern": "^([-a-zA-Z0-9_*]+[.]?)+$"
                                                }
                                              }
                                            }
                                          },
                                          "http": {
                                            "description": "HTTP specific rules.",
                                            "type": "array",
                                            "items": {
                                              "description": "PortRuleHTTP is a list of HTTP protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect. \n All fields of this type are extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986.",
                                              "type": "object",
                                              "properties": {
                                                "headerMatches": {
                                                  "description": "HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match.",
                                                  "type": "array",
                                                  "items": {
                                                    "description": "HeaderMatch extends the HeaderValue for matching requirement of a named header field against an immediate string, a secret value, or a regex.  If none of the optional fields is present, then the header value is not matched, only presence of the header is enough.",
                                                    "type": "object",
                                                    "required": [
                                                      "name"
                                                    ],
                                                    "properties": {
                                                      "mismatch": {
                                                        "description": "Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.",
                                                        "type": "string",
                                                        "enum": [
                                                          "LOG",
                                                          "ADD",
                                                          "DELETE",
                                                          "REPLACE"
                                                        ]
                                                      },
                                                      "name": {
                                                        "description": "Name identifies the header.",
                                                        "type": "string"
                                                      },
                                                      "secret": {
                                                        "description": "Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no \"Value\" specified, the match will fail.",
                                                        "type": "object",
                                                        "required": [
                                                          "name"
                                                        ],
                                                        "properties": {
                                                          "name": {
                                                            "description": "Name is the name of the secret.",
                                                            "type": "string"
                                                          },
                                                          "namespace": {
                                                            "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                                            "type": "string"
                                                          }
                                                        }
                                                      },
                                                      "value": {
                                                        "description": "Value matches the exact value of the header. Can be specified either alone or together with \"Secret\"; will be used as the header value if the secret can not be found in the latter case.",
                                                        "type": "string"
                                                      }
                                                    }
                                                  }
                                                },
                                                "headers": {
                                                  "description": "Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present.",
                                                  "type": "array",
                                                  "items": {
                                                    "type": "string"
                                                  }
                                                },
                                                "host": {
                                                  "description": "Host is an extended POSIX regex matched against the host header of a request, e.g. \"foo.com\" \n If omitted or empty, the value of the host header is ignored.",
                                                  "type": "string",
                                                  "format": "idn-hostname"
                                                },
                                                "method": {
                                                  "description": "Method is an extended POSIX regex matched against the method of a request, e.g. \"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\", ... \n If omitted or empty, all methods are allowed.",
                                                  "type": "string"
                                                },
                                                "path": {
                                                  "description": "Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986. \n If omitted or empty, all paths are all allowed.",
                                                  "type": "string"
                                                }
                                              }
                                            }
                                          },
                                          "kafka": {
                                            "description": "Kafka-specific rules.",
                                            "type": "array",
                                            "items": {
                                              "description": "PortRule is a list of Kafka protocol constraints. All fields are optional, if all fields are empty or missing, the rule will match all Kafka messages.",
                                              "type": "object",
                                              "properties": {
                                                "apiKey": {
                                                  "description": "APIKey is a case-insensitive string matched against the key of a request, e.g. \"produce\", \"fetch\", \"createtopic\", \"deletetopic\", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys \n If omitted or empty, and if Role is not specified, then all keys are allowed.",
                                                  "type": "string"
                                                },
                                                "apiVersion": {
                                                  "description": "APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer. \n If omitted or empty, all versions are allowed.",
                                                  "type": "string"
                                                },
                                                "clientID": {
                                                  "description": "ClientID is the client identifier as provided in the request. \n From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client. \n If omitted or empty, all client identifiers are allowed.",
                                                  "type": "string"
                                                },
                                                "role": {
                                                  "description": "Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as \"produce\" or \"consume\". A Role automatically expands into all APIKeys required to perform the specified higher-level operation. \n The following values are supported:  - \"produce\": Allow producing to the topics specified in the rule  - \"consume\": Allow consuming from the topics specified in the rule \n This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule. \n If omitted or empty, and if APIKey is not specified, then all keys are allowed.",
                                                  "type": "string",
                                                  "enum": [
                                                    "produce",
                                                    "consume"
                                                  ]
                                                },
                                                "topic": {
                                                  "description": "Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected. \n This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _. \n Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255. \n If omitted or empty, all topics are allowed.",
                                                  "type": "string",
                                                  "maxLength": 255
                                                }
                                              }
                                            }
                                          },
                                          "l7": {
                                            "description": "Key-value pair rules.",
                                            "type": "array",
                                            "items": {
                                              "description": "PortRuleL7 is a list of key-value pairs interpreted by a L7 protocol as protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect.",
                                              "type": "object",
                                              "additionalProperties": {
                                                "type": "string"
                                              }
                                            }
                                          },
                                          "l7proto": {
                                            "description": "Name of the L7 protocol for which the Key-value pair rules apply.",
                                            "type": "string"
                                          }
                                        }
                                      },
                                      "serverNames": {
                                        "description": "ServerNames is a list of allowed TLS SNI values. If not empty, then TLS must be present and one of the provided SNIs must be indicated in the TLS handshake.",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        }
                                      },
                                      "terminatingTLS": {
                                        "description": "TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.",
                                        "type": "object",
                                        "required": [
                                          "secret"
                                        ],
                                        "properties": {
                                          "certificate": {
                                            "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                            "type": "string"
                                          },
                                          "privateKey": {
                                            "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                            "type": "string"
                                          },
                                          "secret": {
                                            "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                            "type": "object",
                                            "required": [
                                              "name"
                                            ],
                                            "properties": {
                                              "name": {
                                                "description": "Name is the name of the secret.",
                                                "type": "string"
                                              },
                                              "namespace": {
                                                "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                                "type": "string"
                                              }
                                            }
                                          },
                                          "trustedCA": {
                                            "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                "toRequires": {
                                  "description": "ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\".",
                                  "type": "array",
                                  "items": {
                                    "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string",
                                              "enum": [
                                                "In",
                                                "NotIn",
                                                "Exists",
                                                "DoesNotExist"
                                              ]
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                          "type": "string",
                                          "maxLength": 63,
                                          "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                        }
                                      }
                                    }
                                  }
                                },
                                "toServices": {
                                  "description": "ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service",
                                  "type": "array",
                                  "items": {
                                    "description": "Service wraps around selectors for services",
                                    "type": "object",
                                    "properties": {
                                      "k8sService": {
                                        "description": "K8sService selects service by name and namespace pair",
                                        "type": "object",
                                        "properties": {
                                          "namespace": {
                                            "type": "string"
                                          },
                                          "serviceName": {
                                            "type": "string"
                                          }
                                        }
                                      },
                                      "k8sServiceSelector": {
                                        "description": "K8sServiceSelector selects services by k8s labels and namespace",
                                        "type": "object",
                                        "required": [
                                          "selector"
                                        ],
                                        "properties": {
                                          "namespace": {
                                            "type": "string"
                                          },
                                          "selector": {
                                            "description": "ServiceSelector is a label selector for k8s services",
                                            "type": "object",
                                            "properties": {
                                              "matchExpressions": {
                                                "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                                "type": "array",
                                                "items": {
                                                  "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                                  "type": "object",
                                                  "required": [
                                                    "key",
                                                    "operator"
                                                  ],
                                                  "properties": {
                                                    "key": {
                                                      "description": "key is the label key that the selector applies to.",
                                                      "type": "string"
                                                    },
                                                    "operator": {
                                                      "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                                      "type": "string",
                                                      "enum": [
                                                        "In",
                                                        "NotIn",
                                                        "Exists",
                                                        "DoesNotExist"
                                                      ]
                                                    },
                                                    "values": {
                                                      "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                                      "type": "array",
                                                      "items": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  }
                                                }
                                              },
                                              "matchLabels": {
                                                "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                                "type": "object",
                                                "additionalProperties": {
                                                  "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                                  "type": "string",
                                                  "maxLength": 63,
                                                  "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          "egressDeny": {
                            "description": "EgressDeny is a list of EgressDenyRule which are enforced at egress. Any rule inserted here will be denied regardless of the allowed egress rules in the 'egress' field. If omitted or empty, this rule does not apply at egress.",
                            "type": "array",
                            "items": {
                              "description": "EgressDenyRule contains all rule types which can be applied at egress, i.e. network traffic that originates inside the endpoint and exits the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members of the structure are specified, then all members     must match in order for the rule to take effect. The exception to this     rule is the ToRequires member; the effects of any Requires field in any     rule will apply to all other rules as well. \n   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are     mutually exclusive. Only one of these members may be present within an     individual rule.",
                              "type": "object",
                              "properties": {
                                "icmps": {
                                  "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is not allowed to initiate type 8 ICMP connections.",
                                  "type": "array",
                                  "items": {
                                    "description": "ICMPRule is a list of ICMP fields.",
                                    "type": "object",
                                    "properties": {
                                      "fields": {
                                        "description": "Fields is a list of ICMP fields.",
                                        "type": "array",
                                        "items": {
                                          "description": "ICMPField is a ICMP field.",
                                          "type": "object",
                                          "required": [
                                            "type"
                                          ],
                                          "properties": {
                                            "family": {
                                              "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                              "type": "string",
                                              "default": "IPv4",
                                              "enum": [
                                                "IPv4",
                                                "IPv6"
                                              ]
                                            },
                                            "type": {
                                              "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                              "type": "integer",
                                              "maximum": 255,
                                              "minimum": 0
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                "toCIDR": {
                                  "description": "ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules.  This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24",
                                  "type": "array",
                                  "items": {
                                    "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                    "type": "string",
                                    "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                  }
                                },
                                "toCIDRSet": {
                                  "description": "ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.",
                                  "type": "array",
                                  "items": {
                                    "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                                    "type": "object",
                                    "oneOf": [
                                      {
                                        "required": [
                                          "cidr"
                                        ],
                                        "properties": {
                                          "cidr": {}
                                        }
                                      },
                                      {
                                        "required": [
                                          "cidrGroupRef"
                                        ],
                                        "properties": {
                                          "cidrGroupRef": {}
                                        }
                                      }
                                    ],
                                    "properties": {
                                      "cidr": {
                                        "description": "CIDR is a CIDR prefix / IP Block.",
                                        "type": "string",
                                        "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                      },
                                      "cidrGroupRef": {
                                        "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                                        "type": "string",
                                        "maxLength": 253,
                                        "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                                      },
                                      "except": {
                                        "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                                        "type": "array",
                                        "items": {
                                          "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                          "type": "string",
                                          "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                        }
                                      }
                                    }
                                  }
                                },
                                "toEndpoints": {
                                  "description": "ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\".",
                                  "type": "array",
                                  "items": {
                                    "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string",
                                              "enum": [
                                                "In",
                                                "NotIn",
                                                "Exists",
                                                "DoesNotExist"
                                              ]
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                          "type": "string",
                                          "maxLength": 63,
                                          "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                        }
                                      }
                                    }
                                  }
                                },
                                "toEntities": {
                                  "description": "ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`, `health`,`unmanaged` and `all`.",
                                  "type": "array",
                                  "items": {
                                    "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                                    "type": "string",
                                    "enum": [
                                      "all",
                                      "world",
                                      "cluster",
                                      "host",
                                      "init",
                                      "ingress",
                                      "unmanaged",
                                      "remote-node",
                                      "health",
                                      "none",
                                      "kube-apiserver"
                                    ]
                                  }
                                },
                                "toGroups": {
                                  "description": "ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws:     securityGroupsIds:     - 'sg-XXXXXXXXXXXXX'",
                                  "type": "array",
                                  "items": {
                                    "description": "ToGroups structure to store all kinds of new integrations that needs a new derivative policy.",
                                    "type": "object",
                                    "properties": {
                                      "aws": {
                                        "description": "AWSGroup is an structure that can be used to whitelisting information from AWS integration",
                                        "type": "object",
                                        "properties": {
                                          "labels": {
                                            "type": "object",
                                            "additionalProperties": {
                                              "type": "string"
                                            }
                                          },
                                          "region": {
                                            "type": "string"
                                          },
                                          "securityGroupsIds": {
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          },
                                          "securityGroupsNames": {
                                            "type": "array",
                                            "items": {
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                "toPorts": {
                                  "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is not allowed to initiate connections to destination port 8080/tcp",
                                  "type": "array",
                                  "items": {
                                    "description": "PortDenyRule is a list of ports/protocol that should be used for deny policies. This structure lacks the L7Rules since it's not supported in deny policies.",
                                    "type": "object",
                                    "properties": {
                                      "ports": {
                                        "description": "Ports is a list of L4 port/protocol",
                                        "type": "array",
                                        "items": {
                                          "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                                          "type": "object",
                                          "required": [
                                            "port"
                                          ],
                                          "properties": {
                                            "port": {
                                              "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                              "type": "string",
                                              "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                            },
                                            "protocol": {
                                              "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                              "type": "string",
                                              "enum": [
                                                "TCP",
                                                "UDP",
                                                "SCTP",
                                                "ANY"
                                              ]
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                "toRequires": {
                                  "description": "ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\".",
                                  "type": "array",
                                  "items": {
                                    "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string",
                                              "enum": [
                                                "In",
                                                "NotIn",
                                                "Exists",
                                                "DoesNotExist"
                                              ]
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                          "type": "string",
                                          "maxLength": 63,
                                          "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                        }
                                      }
                                    }
                                  }
                                },
                                "toServices": {
                                  "description": "ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service",
                                  "type": "array",
                                  "items": {
                                    "description": "Service wraps around selectors for services",
                                    "type": "object",
                                    "properties": {
                                      "k8sService": {
                                        "description": "K8sService selects service by name and namespace pair",
                                        "type": "object",
                                        "properties": {
                                          "namespace": {
                                            "type": "string"
                                          },
                                          "serviceName": {
                                            "type": "string"
                                          }
                                        }
                                      },
                                      "k8sServiceSelector": {
                                        "description": "K8sServiceSelector selects services by k8s labels and namespace",
                                        "type": "object",
                                        "required": [
                                          "selector"
                                        ],
                                        "properties": {
                                          "namespace": {
                                            "type": "string"
                                          },
                                          "selector": {
                                            "description": "ServiceSelector is a label selector for k8s services",
                                            "type": "object",
                                            "properties": {
                                              "matchExpressions": {
                                                "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                                "type": "array",
                                                "items": {
                                                  "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                                  "type": "object",
                                                  "required": [
                                                    "key",
                                                    "operator"
                                                  ],
                                                  "properties": {
                                                    "key": {
                                                      "description": "key is the label key that the selector applies to.",
                                                      "type": "string"
                                                    },
                                                    "operator": {
                                                      "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                                      "type": "string",
                                                      "enum": [
                                                        "In",
                                                        "NotIn",
                                                        "Exists",
                                                        "DoesNotExist"
                                                      ]
                                                    },
                                                    "values": {
                                                      "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                                      "type": "array",
                                                      "items": {
                                                        "type": "string"
                                                      }
                                                    }
                                                  }
                                                }
                                              },
                                              "matchLabels": {
                                                "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                                "type": "object",
                                                "additionalProperties": {
                                                  "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                                  "type": "string",
                                                  "maxLength": 63,
                                                  "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          "endpointSelector": {
                            "description": "EndpointSelector selects all endpoints which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive.",
                            "type": "object",
                            "properties": {
                              "matchExpressions": {
                                "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                "type": "array",
                                "items": {
                                  "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                  "type": "object",
                                  "required": [
                                    "key",
                                    "operator"
                                  ],
                                  "properties": {
                                    "key": {
                                      "description": "key is the label key that the selector applies to.",
                                      "type": "string"
                                    },
                                    "operator": {
                                      "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                      "type": "string",
                                      "enum": [
                                        "In",
                                        "NotIn",
                                        "Exists",
                                        "DoesNotExist"
                                      ]
                                    },
                                    "values": {
                                      "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                      "type": "array",
                                      "items": {
                                        "type": "string"
                                      }
                                    }
                                  }
                                }
                              },
                              "matchLabels": {
                                "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                "type": "object",
                                "additionalProperties": {
                                  "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                  "type": "string",
                                  "maxLength": 63,
                                  "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                }
                              }
                            }
                          },
                          "ingress": {
                            "description": "Ingress is a list of IngressRule which are enforced at ingress. If omitted or empty, this rule does not apply at ingress.",
                            "type": "array",
                            "items": {
                              "description": "IngressRule contains all rule types which can be applied at ingress, i.e. network traffic that originates outside of the endpoint and is entering the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members are set, all of them need to match in order for     the rule to take effect. The exception to this rule is FromRequires field;     the effects of any Requires field in any rule will apply to all other     rules as well. \n   - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually     exclusive. Only one of these members may be present within an individual     rule.",
                              "type": "object",
                              "properties": {
                                "authentication": {
                                  "description": "Authentication is the required authentication type for the allowed traffic, if any.",
                                  "type": "object",
                                  "required": [
                                    "mode"
                                  ],
                                  "properties": {
                                    "mode": {
                                      "description": "Mode is the required authentication mode for the allowed traffic, if any.",
                                      "type": "string",
                                      "enum": [
                                        "disabled",
                                        "required",
                                        "test-always-fail"
                                      ]
                                    }
                                  }
                                },
                                "fromCIDR": {
                                  "description": "FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do *not* originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field.  This will match on the source IP address of incoming connections. Adding  a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.3.9.1",
                                  "type": "array",
                                  "items": {
                                    "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                    "type": "string",
                                    "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                  }
                                },
                                "fromCIDRSet": {
                                  "description": "FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.",
                                  "type": "array",
                                  "items": {
                                    "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                                    "type": "object",
                                    "oneOf": [
                                      {
                                        "required": [
                                          "cidr"
                                        ],
                                        "properties": {
                                          "cidr": {}
                                        }
                                      },
                                      {
                                        "required": [
                                          "cidrGroupRef"
                                        ],
                                        "properties": {
                                          "cidrGroupRef": {}
                                        }
                                      }
                                    ],
                                    "properties": {
                                      "cidr": {
                                        "description": "CIDR is a CIDR prefix / IP Block.",
                                        "type": "string",
                                        "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                      },
                                      "cidrGroupRef": {
                                        "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                                        "type": "string",
                                        "maxLength": 253,
                                        "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                                      },
                                      "except": {
                                        "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                                        "type": "array",
                                        "items": {
                                          "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                          "type": "string",
                                          "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                        }
                                      }
                                    }
                                  }
                                },
                                "fromEndpoints": {
                                  "description": "FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\".",
                                  "type": "array",
                                  "items": {
                                    "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string",
                                              "enum": [
                                                "In",
                                                "NotIn",
                                                "Exists",
                                                "DoesNotExist"
                                              ]
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                          "type": "string",
                                          "maxLength": 63,
                                          "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                        }
                                      }
                                    }
                                  }
                                },
                                "fromEntities": {
                                  "description": "FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are `world`, `cluster` and `host`",
                                  "type": "array",
                                  "items": {
                                    "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                                    "type": "string",
                                    "enum": [
                                      "all",
                                      "world",
                                      "cluster",
                                      "host",
                                      "init",
                                      "ingress",
                                      "unmanaged",
                                      "remote-node",
                                      "health",
                                      "none",
                                      "kube-apiserver"
                                    ]
                                  }
                                },
                                "fromRequires": {
                                  "description": "FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\".",
                                  "type": "array",
                                  "items": {
                                    "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string",
                                              "enum": [
                                                "In",
                                                "NotIn",
                                                "Exists",
                                                "DoesNotExist"
                                              ]
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                          "type": "string",
                                          "maxLength": 63,
                                          "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                        }
                                      }
                                    }
                                  }
                                },
                                "icmps": {
                                  "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming type 8 ICMP connections.",
                                  "type": "array",
                                  "items": {
                                    "description": "ICMPRule is a list of ICMP fields.",
                                    "type": "object",
                                    "properties": {
                                      "fields": {
                                        "description": "Fields is a list of ICMP fields.",
                                        "type": "array",
                                        "items": {
                                          "description": "ICMPField is a ICMP field.",
                                          "type": "object",
                                          "required": [
                                            "type"
                                          ],
                                          "properties": {
                                            "family": {
                                              "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                              "type": "string",
                                              "default": "IPv4",
                                              "enum": [
                                                "IPv4",
                                                "IPv6"
                                              ]
                                            },
                                            "type": {
                                              "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                              "type": "integer",
                                              "maximum": 255,
                                              "minimum": 0
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                "toPorts": {
                                  "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming connections on port 80/tcp.",
                                  "type": "array",
                                  "items": {
                                    "description": "PortRule is a list of ports/protocol combinations with optional Layer 7 rules which must be met.",
                                    "type": "object",
                                    "properties": {
                                      "listener": {
                                        "description": "listener specifies the name of a custom Envoy listener to which this traffic should be redirected to.",
                                        "type": "object",
                                        "required": [
                                          "envoyConfig",
                                          "name"
                                        ],
                                        "properties": {
                                          "envoyConfig": {
                                            "description": "EnvoyConfig is a reference to the CEC or CCNP resource in which the listener is defined.",
                                            "type": "object",
                                            "required": [
                                              "name"
                                            ],
                                            "properties": {
                                              "kind": {
                                                "description": "Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy, respectively. The only case this is currently explicitly needed is when referring to a CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener from a cluster scoped policy is not allowed.",
                                                "type": "string",
                                                "enum": [
                                                  "CiliumEnvoyConfig",
                                                  "CiliumClusterwideEnvoyConfig"
                                                ]
                                              },
                                              "name": {
                                                "description": "Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where the listener is defined in.",
                                                "type": "string",
                                                "minLength": 1
                                              }
                                            }
                                          },
                                          "name": {
                                            "description": "Name is the name of the listener.",
                                            "type": "string",
                                            "minLength": 1
                                          }
                                        }
                                      },
                                      "originatingTLS": {
                                        "description": "OriginatingTLS is the TLS context for the connections originated by the L7 proxy.  For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint.",
                                        "type": "object",
                                        "required": [
                                          "secret"
                                        ],
                                        "properties": {
                                          "certificate": {
                                            "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                            "type": "string"
                                          },
                                          "privateKey": {
                                            "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                            "type": "string"
                                          },
                                          "secret": {
                                            "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                            "type": "object",
                                            "required": [
                                              "name"
                                            ],
                                            "properties": {
                                              "name": {
                                                "description": "Name is the name of the secret.",
                                                "type": "string"
                                              },
                                              "namespace": {
                                                "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                                "type": "string"
                                              }
                                            }
                                          },
                                          "trustedCA": {
                                            "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                            "type": "string"
                                          }
                                        }
                                      },
                                      "ports": {
                                        "description": "Ports is a list of L4 port/protocol",
                                        "type": "array",
                                        "items": {
                                          "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                                          "type": "object",
                                          "required": [
                                            "port"
                                          ],
                                          "properties": {
                                            "port": {
                                              "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                              "type": "string",
                                              "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                            },
                                            "protocol": {
                                              "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                              "type": "string",
                                              "enum": [
                                                "TCP",
                                                "UDP",
                                                "SCTP",
                                                "ANY"
                                              ]
                                            }
                                          }
                                        }
                                      },
                                      "rules": {
                                        "description": "Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced.",
                                        "type": "object",
                                        "properties": {
                                          "dns": {
                                            "description": "DNS-specific rules.",
                                            "type": "array",
                                            "items": {
                                              "description": "PortRuleDNS is a list of allowed DNS lookups.",
                                              "type": "object",
                                              "properties": {
                                                "matchName": {
                                                  "description": "MatchName matches literal DNS names. A trailing \".\" is automatically added when missing.",
                                                  "type": "string",
                                                  "pattern": "^([-a-zA-Z0-9_]+[.]?)+$"
                                                },
                                                "matchPattern": {
                                                  "description": "MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"*\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"*\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: `*.cilium.io` matches subomains of cilium at that level   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not `*cilium.io` matches cilium.io and all subdomains ends with \"cilium.io\"   except those containing \".\" separator, subcilium.io and sub-cilium.io match,   www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\"   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,   blog.cilium.io, cilium.io and google.com do not",
                                                  "type": "string",
                                                  "pattern": "^([-a-zA-Z0-9_*]+[.]?)+$"
                                                }
                                              }
                                            }
                                          },
                                          "http": {
                                            "description": "HTTP specific rules.",
                                            "type": "array",
                                            "items": {
                                              "description": "PortRuleHTTP is a list of HTTP protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect. \n All fields of this type are extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986.",
                                              "type": "object",
                                              "properties": {
                                                "headerMatches": {
                                                  "description": "HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match.",
                                                  "type": "array",
                                                  "items": {
                                                    "description": "HeaderMatch extends the HeaderValue for matching requirement of a named header field against an immediate string, a secret value, or a regex.  If none of the optional fields is present, then the header value is not matched, only presence of the header is enough.",
                                                    "type": "object",
                                                    "required": [
                                                      "name"
                                                    ],
                                                    "properties": {
                                                      "mismatch": {
                                                        "description": "Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log.",
                                                        "type": "string",
                                                        "enum": [
                                                          "LOG",
                                                          "ADD",
                                                          "DELETE",
                                                          "REPLACE"
                                                        ]
                                                      },
                                                      "name": {
                                                        "description": "Name identifies the header.",
                                                        "type": "string"
                                                      },
                                                      "secret": {
                                                        "description": "Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no \"Value\" specified, the match will fail.",
                                                        "type": "object",
                                                        "required": [
                                                          "name"
                                                        ],
                                                        "properties": {
                                                          "name": {
                                                            "description": "Name is the name of the secret.",
                                                            "type": "string"
                                                          },
                                                          "namespace": {
                                                            "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                                            "type": "string"
                                                          }
                                                        }
                                                      },
                                                      "value": {
                                                        "description": "Value matches the exact value of the header. Can be specified either alone or together with \"Secret\"; will be used as the header value if the secret can not be found in the latter case.",
                                                        "type": "string"
                                                      }
                                                    }
                                                  }
                                                },
                                                "headers": {
                                                  "description": "Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present.",
                                                  "type": "array",
                                                  "items": {
                                                    "type": "string"
                                                  }
                                                },
                                                "host": {
                                                  "description": "Host is an extended POSIX regex matched against the host header of a request, e.g. \"foo.com\" \n If omitted or empty, the value of the host header is ignored.",
                                                  "type": "string",
                                                  "format": "idn-hostname"
                                                },
                                                "method": {
                                                  "description": "Method is an extended POSIX regex matched against the method of a request, e.g. \"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\", ... \n If omitted or empty, all methods are allowed.",
                                                  "type": "string"
                                                },
                                                "path": {
                                                  "description": "Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986. \n If omitted or empty, all paths are all allowed.",
                                                  "type": "string"
                                                }
                                              }
                                            }
                                          },
                                          "kafka": {
                                            "description": "Kafka-specific rules.",
                                            "type": "array",
                                            "items": {
                                              "description": "PortRule is a list of Kafka protocol constraints. All fields are optional, if all fields are empty or missing, the rule will match all Kafka messages.",
                                              "type": "object",
                                              "properties": {
                                                "apiKey": {
                                                  "description": "APIKey is a case-insensitive string matched against the key of a request, e.g. \"produce\", \"fetch\", \"createtopic\", \"deletetopic\", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys \n If omitted or empty, and if Role is not specified, then all keys are allowed.",
                                                  "type": "string"
                                                },
                                                "apiVersion": {
                                                  "description": "APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer. \n If omitted or empty, all versions are allowed.",
                                                  "type": "string"
                                                },
                                                "clientID": {
                                                  "description": "ClientID is the client identifier as provided in the request. \n From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client. \n If omitted or empty, all client identifiers are allowed.",
                                                  "type": "string"
                                                },
                                                "role": {
                                                  "description": "Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as \"produce\" or \"consume\". A Role automatically expands into all APIKeys required to perform the specified higher-level operation. \n The following values are supported:  - \"produce\": Allow producing to the topics specified in the rule  - \"consume\": Allow consuming from the topics specified in the rule \n This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule. \n If omitted or empty, and if APIKey is not specified, then all keys are allowed.",
                                                  "type": "string",
                                                  "enum": [
                                                    "produce",
                                                    "consume"
                                                  ]
                                                },
                                                "topic": {
                                                  "description": "Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected. \n This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _. \n Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255. \n If omitted or empty, all topics are allowed.",
                                                  "type": "string",
                                                  "maxLength": 255
                                                }
                                              }
                                            }
                                          },
                                          "l7": {
                                            "description": "Key-value pair rules.",
                                            "type": "array",
                                            "items": {
                                              "description": "PortRuleL7 is a list of key-value pairs interpreted by a L7 protocol as protocol constraints. All fields are optional, if all fields are empty or missing, the rule does not have any effect.",
                                              "type": "object",
                                              "additionalProperties": {
                                                "type": "string"
                                              }
                                            }
                                          },
                                          "l7proto": {
                                            "description": "Name of the L7 protocol for which the Key-value pair rules apply.",
                                            "type": "string"
                                          }
                                        }
                                      },
                                      "serverNames": {
                                        "description": "ServerNames is a list of allowed TLS SNI values. If not empty, then TLS must be present and one of the provided SNIs must be indicated in the TLS handshake.",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        }
                                      },
                                      "terminatingTLS": {
                                        "description": "TerminatingTLS is the TLS context for the connection terminated by the L7 proxy.  For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy.",
                                        "type": "object",
                                        "required": [
                                          "secret"
                                        ],
                                        "properties": {
                                          "certificate": {
                                            "description": "Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist.",
                                            "type": "string"
                                          },
                                          "privateKey": {
                                            "description": "PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist.",
                                            "type": "string"
                                          },
                                          "secret": {
                                            "description": "Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items:  - 'ca.crt'  - Which represents the trusted CA to verify remote source.  - 'tls.crt' - Which represents the public key certificate.  - 'tls.key' - Which represents the private key matching the public key                certificate.",
                                            "type": "object",
                                            "required": [
                                              "name"
                                            ],
                                            "properties": {
                                              "name": {
                                                "description": "Name is the name of the secret.",
                                                "type": "string"
                                              },
                                              "namespace": {
                                                "description": "Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\").",
                                                "type": "string"
                                              }
                                            }
                                          },
                                          "trustedCA": {
                                            "description": "TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist.",
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          "ingressDeny": {
                            "description": "IngressDeny is a list of IngressDenyRule which are enforced at ingress. Any rule inserted here will be denied regardless of the allowed ingress rules in the 'ingress' field. If omitted or empty, this rule does not apply at ingress.",
                            "type": "array",
                            "items": {
                              "description": "IngressDenyRule contains all rule types which can be applied at ingress, i.e. network traffic that originates outside of the endpoint and is entering the endpoint selected by the endpointSelector. \n   - All members of this structure are optional. If omitted or empty, the     member will have no effect on the rule. \n   - If multiple members are set, all of them need to match in order for     the rule to take effect. The exception to this rule is FromRequires field;     the effects of any Requires field in any rule will apply to all other     rules as well. \n   - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually     exclusive. Only one of these members may be present within an individual     rule.",
                              "type": "object",
                              "properties": {
                                "fromCIDR": {
                                  "description": "FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do *not* originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field.  This will match on the source IP address of incoming connections. Adding  a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.3.9.1",
                                  "type": "array",
                                  "items": {
                                    "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                    "type": "string",
                                    "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                  }
                                },
                                "fromCIDRSet": {
                                  "description": "FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.",
                                  "type": "array",
                                  "items": {
                                    "description": "CIDRRule is a rule that specifies a CIDR prefix to/from which outside communication  is allowed, along with an optional list of subnets within that CIDR prefix to/from which outside communication is not allowed.",
                                    "type": "object",
                                    "oneOf": [
                                      {
                                        "required": [
                                          "cidr"
                                        ],
                                        "properties": {
                                          "cidr": {}
                                        }
                                      },
                                      {
                                        "required": [
                                          "cidrGroupRef"
                                        ],
                                        "properties": {
                                          "cidrGroupRef": {}
                                        }
                                      }
                                    ],
                                    "properties": {
                                      "cidr": {
                                        "description": "CIDR is a CIDR prefix / IP Block.",
                                        "type": "string",
                                        "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                      },
                                      "cidrGroupRef": {
                                        "description": "CIDRGroupRef is a reference to a CiliumCIDRGroup object. A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to the rule, can (Ingress) or cannot (IngressDeny) receive connections from.",
                                        "type": "string",
                                        "maxLength": 253,
                                        "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                                      },
                                      "except": {
                                        "description": "ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not supported yet. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules.",
                                        "type": "array",
                                        "items": {
                                          "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                                          "type": "string",
                                          "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                                        }
                                      }
                                    }
                                  }
                                },
                                "fromEndpoints": {
                                  "description": "FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\".",
                                  "type": "array",
                                  "items": {
                                    "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string",
                                              "enum": [
                                                "In",
                                                "NotIn",
                                                "Exists",
                                                "DoesNotExist"
                                              ]
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                          "type": "string",
                                          "maxLength": 63,
                                          "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                        }
                                      }
                                    }
                                  }
                                },
                                "fromEntities": {
                                  "description": "FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are `world`, `cluster` and `host`",
                                  "type": "array",
                                  "items": {
                                    "description": "Entity specifies the class of receiver/sender endpoints that do not have individual identities.  Entities are used to describe \"outside of cluster\", \"host\", etc.",
                                    "type": "string",
                                    "enum": [
                                      "all",
                                      "world",
                                      "cluster",
                                      "host",
                                      "init",
                                      "ingress",
                                      "unmanaged",
                                      "remote-node",
                                      "health",
                                      "none",
                                      "kube-apiserver"
                                    ]
                                  }
                                },
                                "fromRequires": {
                                  "description": "FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\".",
                                  "type": "array",
                                  "items": {
                                    "description": "EndpointSelector is a wrapper for k8s LabelSelector.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string",
                                              "enum": [
                                                "In",
                                                "NotIn",
                                                "Exists",
                                                "DoesNotExist"
                                              ]
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              }
                                            }
                                          }
                                        }
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                          "type": "string",
                                          "maxLength": 63,
                                          "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                        }
                                      }
                                    }
                                  }
                                },
                                "icmps": {
                                  "description": "ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming type 8 ICMP connections.",
                                  "type": "array",
                                  "items": {
                                    "description": "ICMPRule is a list of ICMP fields.",
                                    "type": "object",
                                    "properties": {
                                      "fields": {
                                        "description": "Fields is a list of ICMP fields.",
                                        "type": "array",
                                        "items": {
                                          "description": "ICMPField is a ICMP field.",
                                          "type": "object",
                                          "required": [
                                            "type"
                                          ],
                                          "properties": {
                                            "family": {
                                              "description": "Family is a IP address version. Currently, we support `IPv4` and `IPv6`. `IPv4` is set as default.",
                                              "type": "string",
                                              "default": "IPv4",
                                              "enum": [
                                                "IPv4",
                                                "IPv6"
                                              ]
                                            },
                                            "type": {
                                              "description": "Type is a ICMP-type. It should be 0-255 (8bit).",
                                              "type": "integer",
                                              "maximum": 255,
                                              "minimum": 0
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                },
                                "toPorts": {
                                  "description": "ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming connections on port 80/tcp.",
                                  "type": "array",
                                  "items": {
                                    "description": "PortDenyRule is a list of ports/protocol that should be used for deny policies. This structure lacks the L7Rules since it's not supported in deny policies.",
                                    "type": "object",
                                    "properties": {
                                      "ports": {
                                        "description": "Ports is a list of L4 port/protocol",
                                        "type": "array",
                                        "items": {
                                          "description": "PortProtocol specifies an L4 port with an optional transport protocol",
                                          "type": "object",
                                          "required": [
                                            "port"
                                          ],
                                          "properties": {
                                            "port": {
                                              "description": "Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end.",
                                              "type": "string",
                                              "pattern": "^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$"
                                            },
                                            "protocol": {
                                              "description": "Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"SCTP\", \"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this.",
                                              "type": "string",
                                              "enum": [
                                                "TCP",
                                                "UDP",
                                                "SCTP",
                                                "ANY"
                                              ]
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          "labels": {
                            "description": "Labels is a list of optional strings which can be used to re-identify the rule or to store metadata. It is possible to lookup or delete strings based on labels. Labels are not required to be unique, multiple rules can have overlapping or identical labels.",
                            "type": "array",
                            "items": {
                              "description": "Label is the Cilium's representation of a container label.",
                              "type": "object",
                              "required": [
                                "key"
                              ],
                              "properties": {
                                "key": {
                                  "type": "string"
                                },
                                "source": {
                                  "description": "Source can be one of the above values (e.g.: LabelSourceContainer).",
                                  "type": "string"
                                },
                                "value": {
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "nodeSelector": {
                            "description": "NodeSelector selects all nodes which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive. Can only be used in CiliumClusterwideNetworkPolicies.",
                            "type": "object",
                            "properties": {
                              "matchExpressions": {
                                "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                "type": "array",
                                "items": {
                                  "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                  "type": "object",
                                  "required": [
                                    "key",
                                    "operator"
                                  ],
                                  "properties": {
                                    "key": {
                                      "description": "key is the label key that the selector applies to.",
                                      "type": "string"
                                    },
                                    "operator": {
                                      "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                      "type": "string",
                                      "enum": [
                                        "In",
                                        "NotIn",
                                        "Exists",
                                        "DoesNotExist"
                                      ]
                                    },
                                    "values": {
                                      "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                      "type": "array",
                                      "items": {
                                        "type": "string"
                                      }
                                    }
                                  }
                                }
                              },
                              "matchLabels": {
                                "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                "type": "object",
                                "additionalProperties": {
                                  "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                  "type": "string",
                                  "maxLength": 63,
                                  "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "status": {
                      "description": "Status is the status of the Cilium policy rule",
                      "type": "object",
                      "properties": {
                        "derivativePolicies": {
                          "description": "DerivativePolicies is the status of all policies derived from the Cilium policy",
                          "type": "object",
                          "additionalProperties": {
                            "description": "CiliumNetworkPolicyNodeStatus is the status of a Cilium policy rule for a specific node.",
                            "type": "object",
                            "properties": {
                              "annotations": {
                                "description": "Annotations corresponds to the Annotations in the ObjectMeta of the CNP that have been realized on the node for CNP. That is, if a CNP has been imported and has been assigned annotation X=Y by the user, Annotations in CiliumNetworkPolicyNodeStatus will be X=Y once the CNP that was imported corresponding to Annotation X=Y has been realized on the node.",
                                "type": "object",
                                "additionalProperties": {
                                  "type": "string"
                                }
                              },
                              "enforcing": {
                                "description": "Enforcing is set to true once all endpoints present at the time the policy has been imported are enforcing this policy.",
                                "type": "boolean"
                              },
                              "error": {
                                "description": "Error describes any error that occurred when parsing or importing the policy, or realizing the policy for the endpoints to which it applies on the node.",
                                "type": "string"
                              },
                              "lastUpdated": {
                                "description": "LastUpdated contains the last time this status was updated",
                                "type": "string",
                                "format": "date-time"
                              },
                              "localPolicyRevision": {
                                "description": "Revision is the policy revision of the repository which first implemented this policy.",
                                "type": "integer",
                                "format": "int64"
                              },
                              "ok": {
                                "description": "OK is true when the policy has been parsed and imported successfully into the in-memory policy repository on the node.",
                                "type": "boolean"
                              }
                            }
                          }
                        },
                        "nodes": {
                          "description": "Nodes is the Cilium policy status for each node",
                          "type": "object",
                          "additionalProperties": {
                            "description": "CiliumNetworkPolicyNodeStatus is the status of a Cilium policy rule for a specific node.",
                            "type": "object",
                            "properties": {
                              "annotations": {
                                "description": "Annotations corresponds to the Annotations in the ObjectMeta of the CNP that have been realized on the node for CNP. That is, if a CNP has been imported and has been assigned annotation X=Y by the user, Annotations in CiliumNetworkPolicyNodeStatus will be X=Y once the CNP that was imported corresponding to Annotation X=Y has been realized on the node.",
                                "type": "object",
                                "additionalProperties": {
                                  "type": "string"
                                }
                              },
                              "enforcing": {
                                "description": "Enforcing is set to true once all endpoints present at the time the policy has been imported are enforcing this policy.",
                                "type": "boolean"
                              },
                              "error": {
                                "description": "Error describes any error that occurred when parsing or importing the policy, or realizing the policy for the endpoints to which it applies on the node.",
                                "type": "string"
                              },
                              "lastUpdated": {
                                "description": "LastUpdated contains the last time this status was updated",
                                "type": "string",
                                "format": "date-time"
                              },
                              "localPolicyRevision": {
                                "description": "Revision is the policy revision of the repository which first implemented this policy.",
                                "type": "integer",
                                "format": "int64"
                              },
                              "ok": {
                                "description": "OK is true when the policy has been parsed and imported successfully into the in-memory policy repository on the node.",
                                "type": "boolean"
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              },
              "subresources": {
                "status": {}
              },
              "additionalPrinterColumns": [
                {
                  "name": "Age",
                  "type": "date",
                  "jsonPath": ".metadata.creationTimestamp"
                }
              ]
            }
          ],
          "conversion": {
            "strategy": "None"
          }
        },
        "status": {
          "conditions": [
            {
              "type": "NamesAccepted",
              "status": "True",
              "lastTransitionTime": "2023-11-21T10:47:06Z",
              "reason": "NoConflicts",
              "message": "no conflicts found"
            },
            {
              "type": "Established",
              "status": "True",
              "lastTransitionTime": "2023-11-21T10:47:07Z",
              "reason": "InitialNamesAccepted",
              "message": "the initial names have been accepted"
            }
          ],
          "acceptedNames": {
            "plural": "ciliumnetworkpolicies",
            "singular": "ciliumnetworkpolicy",
            "shortNames": [
              "cnp",
              "ciliumnp"
            ],
            "kind": "CiliumNetworkPolicy",
            "listKind": "CiliumNetworkPolicyList"
          },
          "storedVersions": [
            "v2"
          ]
        }
      },
      "additionalColumns": [
        {
          "name": "Age",
          "type": "date",
          "jsonPath": ".metadata.creationTimestamp"
        }
      ],
      "short": "CiliumNetworkPolicy",
      "apiGroup": "cilium.io",
      "apiKind": "CiliumNetworkPolicy",
      "apiVersion": "v2",
      "readProperties": {
        "spec": "spec",
        "specs": "specs",
        "status": "status"
      },
      "writeProperties": {
        "spec": "spec",
        "specs": "specs"
      },
      "group": "cilium",
      "sub": "cilium",
      "listExcludes": [],
      "readExcludes": [],
      "simpleExcludes": [],
      "gqlDefs": {
        "metadata": "metadata!",
        "spec": "JSONObject",
        "specs": "[JSONObject]",
        "status": "JSONObject"
      },
      "namespaced": true
    },
    {
      "alternatives": [],
      "name": "io.cilium.v2.CiliumNode",
      "definition": {
        "description": "CiliumNode represents a node managed by Cilium. It contains a specification to control various node specific configuration aspects and a status section to represent the status of the node.",
        "type": "object",
        "required": [
          "metadata",
          "spec"
        ],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "spec": {
            "description": "Spec defines the desired specification/configuration of the node.",
            "type": "object",
            "properties": {
              "addresses": {
                "description": "Addresses is the list of all node addresses.",
                "type": "array",
                "items": {
                  "description": "NodeAddress is a node address.",
                  "type": "object",
                  "properties": {
                    "ip": {
                      "description": "IP is an IP of a node",
                      "type": "string"
                    },
                    "type": {
                      "description": "Type is the type of the node address",
                      "type": "string"
                    }
                  }
                }
              },
              "alibaba-cloud": {
                "description": "AlibabaCloud is the AlibabaCloud IPAM specific configuration.",
                "type": "object",
                "properties": {
                  "availability-zone": {
                    "description": "AvailabilityZone is the availability zone to use when allocating ENIs.",
                    "type": "string"
                  },
                  "cidr-block": {
                    "description": "CIDRBlock is vpc ipv4 CIDR",
                    "type": "string"
                  },
                  "instance-type": {
                    "description": "InstanceType is the ECS instance type, e.g. \"ecs.g6.2xlarge\"",
                    "type": "string"
                  },
                  "security-group-tags": {
                    "description": "SecurityGroupTags is the list of tags to use when evaluating which security groups to use for the ENI.",
                    "type": "object",
                    "additionalProperties": {
                      "type": "string"
                    }
                  },
                  "security-groups": {
                    "description": "SecurityGroups is the list of security groups to attach to any ENI that is created and attached to the instance.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "vpc-id": {
                    "description": "VPCID is the VPC ID to use when allocating ENIs.",
                    "type": "string"
                  },
                  "vswitch-tags": {
                    "description": "VSwitchTags is the list of tags to use when evaluating which vSwitch to use for the ENI.",
                    "type": "object",
                    "additionalProperties": {
                      "type": "string"
                    }
                  },
                  "vswitches": {
                    "description": "VSwitches is the ID of vSwitch available for ENI",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              },
              "azure": {
                "description": "Azure is the Azure IPAM specific configuration.",
                "type": "object",
                "properties": {
                  "interface-name": {
                    "description": "InterfaceName is the name of the interface the cilium-operator will use to allocate all the IPs on",
                    "type": "string"
                  }
                }
              },
              "encryption": {
                "description": "Encryption is the encryption configuration of the node.",
                "type": "object",
                "properties": {
                  "key": {
                    "description": "Key is the index to the key to use for encryption or 0 if encryption is disabled.",
                    "type": "integer"
                  }
                }
              },
              "eni": {
                "description": "ENI is the AWS ENI specific configuration.",
                "type": "object",
                "properties": {
                  "availability-zone": {
                    "description": "AvailabilityZone is the availability zone to use when allocating ENIs.",
                    "type": "string"
                  },
                  "delete-on-termination": {
                    "description": "DeleteOnTermination defines that the ENI should be deleted when the associated instance is terminated. If the parameter is not set the default behavior is to delete the ENI on instance termination.",
                    "type": "boolean"
                  },
                  "disable-prefix-delegation": {
                    "description": "DisablePrefixDelegation determines whether ENI prefix delegation should be disabled on this node.",
                    "type": "boolean"
                  },
                  "exclude-interface-tags": {
                    "description": "ExcludeInterfaceTags is the list of tags to use when excluding ENIs for Cilium IP allocation. Any interface matching this set of tags will not be managed by Cilium.",
                    "type": "object",
                    "additionalProperties": {
                      "type": "string"
                    }
                  },
                  "first-interface-index": {
                    "description": "FirstInterfaceIndex is the index of the first ENI to use for IP allocation, e.g. if the node has eth0, eth1, eth2 and FirstInterfaceIndex is set to 1, then only eth1 and eth2 will be used for IP allocation, eth0 will be ignored for PodIP allocation.",
                    "type": "integer",
                    "minimum": 0
                  },
                  "instance-id": {
                    "description": "InstanceID is the AWS InstanceId of the node. The InstanceID is used to retrieve AWS metadata for the node. \n OBSOLETE: This field is obsolete, please use Spec.InstanceID",
                    "type": "string"
                  },
                  "instance-type": {
                    "description": "InstanceType is the AWS EC2 instance type, e.g. \"m5.large\"",
                    "type": "string"
                  },
                  "max-above-watermark": {
                    "description": "MaxAboveWatermark is the maximum number of addresses to allocate beyond the addresses needed to reach the PreAllocate watermark. Going above the watermark can help reduce the number of API calls to allocate IPs, e.g. when a new ENI is allocated, as many secondary IPs as possible are allocated. Limiting the amount can help reduce waste of IPs. \n OBSOLETE: This field is obsolete, please use Spec.IPAM.MaxAboveWatermark",
                    "type": "integer",
                    "minimum": 0
                  },
                  "min-allocate": {
                    "description": "MinAllocate is the minimum number of IPs that must be allocated when the node is first bootstrapped. It defines the minimum base socket of addresses that must be available. After reaching this watermark, the PreAllocate and MaxAboveWatermark logic takes over to continue allocating IPs. \n OBSOLETE: This field is obsolete, please use Spec.IPAM.MinAllocate",
                    "type": "integer",
                    "minimum": 0
                  },
                  "node-subnet-id": {
                    "description": "NodeSubnetID is the subnet of the primary ENI the instance was brought up with. It is used as a sensible default subnet to create ENIs in.",
                    "type": "string"
                  },
                  "pre-allocate": {
                    "description": "PreAllocate defines the number of IP addresses that must be available for allocation in the IPAMspec. It defines the buffer of addresses available immediately without requiring cilium-operator to get involved. \n OBSOLETE: This field is obsolete, please use Spec.IPAM.PreAllocate",
                    "type": "integer",
                    "minimum": 0
                  },
                  "security-group-tags": {
                    "description": "SecurityGroupTags is the list of tags to use when evaliating what AWS security groups to use for the ENI.",
                    "type": "object",
                    "additionalProperties": {
                      "type": "string"
                    }
                  },
                  "security-groups": {
                    "description": "SecurityGroups is the list of security groups to attach to any ENI that is created and attached to the instance.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "subnet-ids": {
                    "description": "SubnetIDs is the list of subnet ids to use when evaluating what AWS subnets to use for ENI and IP allocation.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "subnet-tags": {
                    "description": "SubnetTags is the list of tags to use when evaluating what AWS subnets to use for ENI and IP allocation.",
                    "type": "object",
                    "additionalProperties": {
                      "type": "string"
                    }
                  },
                  "use-primary-address": {
                    "description": "UsePrimaryAddress determines whether an ENI's primary address should be available for allocations on the node",
                    "type": "boolean"
                  },
                  "vpc-id": {
                    "description": "VpcID is the VPC ID to use when allocating ENIs.",
                    "type": "string"
                  }
                }
              },
              "health": {
                "description": "HealthAddressing is the addressing information for health connectivity checking.",
                "type": "object",
                "properties": {
                  "ipv4": {
                    "description": "IPv4 is the IPv4 address of the IPv4 health endpoint.",
                    "type": "string"
                  },
                  "ipv6": {
                    "description": "IPv6 is the IPv6 address of the IPv4 health endpoint.",
                    "type": "string"
                  }
                }
              },
              "ingress": {
                "description": "IngressAddressing is the addressing information for Ingress listener.",
                "type": "object",
                "properties": {
                  "ipv4": {
                    "type": "string"
                  },
                  "ipv6": {
                    "type": "string"
                  }
                }
              },
              "instance-id": {
                "description": "InstanceID is the identifier of the node. This is different from the node name which is typically the FQDN of the node. The InstanceID typically refers to the identifier used by the cloud provider or some other means of identification.",
                "type": "string"
              },
              "ipam": {
                "description": "IPAM is the address management specification. This section can be populated by a user or it can be automatically populated by an IPAM operator.",
                "type": "object",
                "properties": {
                  "max-above-watermark": {
                    "description": "MaxAboveWatermark is the maximum number of addresses to allocate beyond the addresses needed to reach the PreAllocate watermark. Going above the watermark can help reduce the number of API calls to allocate IPs, e.g. when a new ENI is allocated, as many secondary IPs as possible are allocated. Limiting the amount can help reduce waste of IPs.",
                    "type": "integer",
                    "minimum": 0
                  },
                  "max-allocate": {
                    "description": "MaxAllocate is the maximum number of IPs that can be allocated to the node. When the current amount of allocated IPs will approach this value, the considered value for PreAllocate will decrease down to 0 in order to not attempt to allocate more addresses than defined.",
                    "type": "integer",
                    "minimum": 0
                  },
                  "min-allocate": {
                    "description": "MinAllocate is the minimum number of IPs that must be allocated when the node is first bootstrapped. It defines the minimum base socket of addresses that must be available. After reaching this watermark, the PreAllocate and MaxAboveWatermark logic takes over to continue allocating IPs.",
                    "type": "integer",
                    "minimum": 0
                  },
                  "pod-cidr-allocation-threshold": {
                    "description": "PodCIDRAllocationThreshold defines the minimum number of free IPs which must be available to this node via its pod CIDR pool. If the total number of IP addresses in the pod CIDR pool is less than this value, the pod CIDRs currently in-use by this node will be marked as depleted and cilium-operator will allocate a new pod CIDR to this node. This value effectively defines the buffer of IP addresses available immediately without requiring cilium-operator to get involved.",
                    "type": "integer",
                    "minimum": 0
                  },
                  "pod-cidr-release-threshold": {
                    "description": "PodCIDRReleaseThreshold defines the maximum number of free IPs which may be available to this node via its pod CIDR pool. While the total number of free IP addresses in the pod CIDR pool is larger than this value, cilium-agent will attempt to release currently unused pod CIDRs.",
                    "type": "integer",
                    "minimum": 0
                  },
                  "podCIDRs": {
                    "description": "PodCIDRs is the list of CIDRs available to the node for allocation. When an IP is used, the IP will be added to Status.IPAM.Used",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "pool": {
                    "description": "Pool is the list of IPs available to the node for allocation. When an IP is used, the IP will remain on this list but will be added to Status.IPAM.Used",
                    "type": "object",
                    "additionalProperties": {
                      "description": "AllocationIP is an IP which is available for allocation, or already has been allocated",
                      "type": "object",
                      "properties": {
                        "owner": {
                          "description": "Owner is the owner of the IP. This field is set if the IP has been allocated. It will be set to the pod name or another identifier representing the usage of the IP \n The owner field is left blank for an entry in Spec.IPAM.Pool and filled out as the IP is used and also added to Status.IPAM.Used.",
                          "type": "string"
                        },
                        "resource": {
                          "description": "Resource is set for both available and allocated IPs, it represents what resource the IP is associated with, e.g. in combination with AWS ENI, this will refer to the ID of the ENI",
                          "type": "string"
                        }
                      }
                    }
                  },
                  "pools": {
                    "description": "Pools contains the list of assigned IPAM pools for this node.",
                    "type": "object",
                    "properties": {
                      "allocated": {
                        "description": "Allocated contains the list of pooled CIDR assigned to this node. The operator will add new pod CIDRs to this field, whereas the agent will remove CIDRs it has released.",
                        "type": "array",
                        "items": {
                          "description": "IPAMPoolAllocation describes an allocation of an IPAM pool from the operator to the node. It contains the assigned PodCIDRs allocated from this pool",
                          "type": "object",
                          "required": [
                            "pool"
                          ],
                          "properties": {
                            "cidrs": {
                              "description": "CIDRs contains a list of pod CIDRs currently allocated from this pool",
                              "type": "array",
                              "items": {
                                "description": "IPAMPodCIDR is a pod CIDR",
                                "type": "string",
                                "format": "cidr"
                              }
                            },
                            "pool": {
                              "description": "Pool is the name of the IPAM pool backing this allocation",
                              "type": "string",
                              "minLength": 1
                            }
                          }
                        }
                      },
                      "requested": {
                        "description": "Requested contains a list of IPAM pool requests, i.e. indicates how many addresses this node requests out of each pool listed here. This field is owned and written to by cilium-agent and read by the operator.",
                        "type": "array",
                        "items": {
                          "type": "object",
                          "required": [
                            "pool"
                          ],
                          "properties": {
                            "needed": {
                              "description": "Needed indicates how many IPs out of the above Pool this node requests from the operator. The operator runs a reconciliation loop to ensure each node always has enough PodCIDRs allocated in each pool to fulfill the requested number of IPs here.",
                              "type": "object",
                              "properties": {
                                "ipv4-addrs": {
                                  "description": "IPv4Addrs contains the number of requested IPv4 addresses out of a given pool",
                                  "type": "integer"
                                },
                                "ipv6-addrs": {
                                  "description": "IPv6Addrs contains the number of requested IPv6 addresses out of a given pool",
                                  "type": "integer"
                                }
                              }
                            },
                            "pool": {
                              "description": "Pool is the name of the IPAM pool backing this request",
                              "type": "string",
                              "minLength": 1
                            }
                          }
                        }
                      }
                    }
                  },
                  "pre-allocate": {
                    "description": "PreAllocate defines the number of IP addresses that must be available for allocation in the IPAMspec. It defines the buffer of addresses available immediately without requiring cilium-operator to get involved.",
                    "type": "integer",
                    "minimum": 0
                  }
                }
              },
              "nodeidentity": {
                "description": "NodeIdentity is the Cilium numeric identity allocated for the node, if any.",
                "type": "integer",
                "format": "int64"
              }
            }
          },
          "status": {
            "description": "Status defines the realized specification/configuration and status of the node.",
            "type": "object",
            "properties": {
              "alibaba-cloud": {
                "description": "AlibabaCloud is the AlibabaCloud specific status of the node.",
                "type": "object",
                "properties": {
                  "enis": {
                    "description": "ENIs is the list of ENIs on the node",
                    "type": "object",
                    "additionalProperties": {
                      "description": "ENI represents an AlibabaCloud Elastic Network Interface",
                      "type": "object",
                      "properties": {
                        "instance-id": {
                          "description": "InstanceID is the InstanceID using this ENI",
                          "type": "string"
                        },
                        "mac-address": {
                          "description": "MACAddress is the mac address of the ENI",
                          "type": "string"
                        },
                        "network-interface-id": {
                          "description": "NetworkInterfaceID is the ENI id",
                          "type": "string"
                        },
                        "primary-ip-address": {
                          "description": "PrimaryIPAddress is the primary IP on ENI",
                          "type": "string"
                        },
                        "private-ipsets": {
                          "description": "PrivateIPSets is the list of all IPs on the ENI, including PrimaryIPAddress",
                          "type": "array",
                          "items": {
                            "description": "PrivateIPSet is a nested struct in ecs response",
                            "type": "object",
                            "properties": {
                              "primary": {
                                "type": "boolean"
                              },
                              "private-ip-address": {
                                "type": "string"
                              }
                            }
                          }
                        },
                        "security-groupids": {
                          "description": "SecurityGroupIDs is the security group ids used by this ENI",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        },
                        "tags": {
                          "description": "Tags is the tags on this ENI",
                          "type": "object",
                          "additionalProperties": {
                            "type": "string"
                          }
                        },
                        "type": {
                          "description": "Type is the ENI type Primary or Secondary",
                          "type": "string"
                        },
                        "vpc": {
                          "description": "VPC is the vpc to which the ENI belongs",
                          "type": "object",
                          "properties": {
                            "cidr": {
                              "description": "CIDRBlock is the VPC IPv4 CIDR",
                              "type": "string"
                            },
                            "ipv6-cidr": {
                              "description": "IPv6CIDRBlock is the VPC IPv6 CIDR",
                              "type": "string"
                            },
                            "vpc-id": {
                              "description": "VPCID is the vpc to which the ENI belongs",
                              "type": "string"
                            }
                          }
                        },
                        "vswitch": {
                          "description": "VSwitch is the vSwitch the ENI is using",
                          "type": "object",
                          "properties": {
                            "cidr": {
                              "description": "CIDRBlock is the vSwitch IPv4 CIDR",
                              "type": "string"
                            },
                            "ipv6-cidr": {
                              "description": "IPv6CIDRBlock is the vSwitch IPv6 CIDR",
                              "type": "string"
                            },
                            "vswitch-id": {
                              "description": "VSwitchID is the vSwitch to which the ENI belongs",
                              "type": "string"
                            }
                          }
                        },
                        "zone-id": {
                          "description": "ZoneID is the zone to which the ENI belongs",
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              },
              "azure": {
                "description": "Azure is the Azure specific status of the node.",
                "type": "object",
                "properties": {
                  "interfaces": {
                    "description": "Interfaces is the list of interfaces on the node",
                    "type": "array",
                    "items": {
                      "description": "AzureInterface represents an Azure Interface",
                      "type": "object",
                      "properties": {
                        "GatewayIP": {
                          "description": "GatewayIP is the interface's subnet's default route \n OBSOLETE: This field is obsolete, please use Gateway field instead.",
                          "type": "string"
                        },
                        "addresses": {
                          "description": "Addresses is the list of all IPs associated with the interface, including all secondary addresses",
                          "type": "array",
                          "items": {
                            "description": "AzureAddress is an IP address assigned to an AzureInterface",
                            "type": "object",
                            "properties": {
                              "ip": {
                                "description": "IP is the ip address of the address",
                                "type": "string"
                              },
                              "state": {
                                "description": "State is the provisioning state of the address",
                                "type": "string"
                              },
                              "subnet": {
                                "description": "Subnet is the subnet the address belongs to",
                                "type": "string"
                              }
                            }
                          }
                        },
                        "cidr": {
                          "description": "CIDR is the range that the interface belongs to.",
                          "type": "string"
                        },
                        "gateway": {
                          "description": "Gateway is the interface's subnet's default route",
                          "type": "string"
                        },
                        "id": {
                          "description": "ID is the identifier",
                          "type": "string"
                        },
                        "mac": {
                          "description": "MAC is the mac address",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name is the name of the interface",
                          "type": "string"
                        },
                        "security-group": {
                          "description": "SecurityGroup is the security group associated with the interface",
                          "type": "string"
                        },
                        "state": {
                          "description": "State is the provisioning state",
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              },
              "eni": {
                "description": "ENI is the AWS ENI specific status of the node.",
                "type": "object",
                "properties": {
                  "enis": {
                    "description": "ENIs is the list of ENIs on the node",
                    "type": "object",
                    "additionalProperties": {
                      "description": "ENI represents an AWS Elastic Network Interface \n More details: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html",
                      "type": "object",
                      "properties": {
                        "addresses": {
                          "description": "Addresses is the list of all secondary IPs associated with the ENI",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        },
                        "availability-zone": {
                          "description": "AvailabilityZone is the availability zone of the ENI",
                          "type": "string"
                        },
                        "description": {
                          "description": "Description is the description field of the ENI",
                          "type": "string"
                        },
                        "id": {
                          "description": "ID is the ENI ID",
                          "type": "string"
                        },
                        "ip": {
                          "description": "IP is the primary IP of the ENI",
                          "type": "string"
                        },
                        "mac": {
                          "description": "MAC is the mac address of the ENI",
                          "type": "string"
                        },
                        "number": {
                          "description": "Number is the interface index, it used in combination with FirstInterfaceIndex",
                          "type": "integer"
                        },
                        "prefixes": {
                          "description": "Prefixes is the list of all /28 prefixes associated with the ENI",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        },
                        "security-groups": {
                          "description": "SecurityGroups are the security groups associated with the ENI",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        },
                        "subnet": {
                          "description": "Subnet is the subnet the ENI is associated with",
                          "type": "object",
                          "properties": {
                            "cidr": {
                              "description": "CIDR is the CIDR range associated with the subnet",
                              "type": "string"
                            },
                            "id": {
                              "description": "ID is the ID of the subnet",
                              "type": "string"
                            }
                          }
                        },
                        "tags": {
                          "description": "Tags is the set of tags of the ENI. Used to detect ENIs which should not be managed by Cilium",
                          "type": "object",
                          "additionalProperties": {
                            "type": "string"
                          }
                        },
                        "vpc": {
                          "description": "VPC is the VPC information to which the ENI is attached to",
                          "type": "object",
                          "properties": {
                            "cidrs": {
                              "description": "CIDRs is the list of CIDR ranges associated with the VPC",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            },
                            "id": {
                              "description": "/ ID is the ID of a VPC",
                              "type": "string"
                            },
                            "primary-cidr": {
                              "description": "PrimaryCIDR is the primary CIDR of the VPC",
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  }
                }
              },
              "ipam": {
                "description": "IPAM is the IPAM status of the node.",
                "type": "object",
                "properties": {
                  "operator-status": {
                    "description": "Operator is the Operator status of the node",
                    "type": "object",
                    "properties": {
                      "error": {
                        "description": "Error is the error message set by cilium-operator.",
                        "type": "string"
                      }
                    }
                  },
                  "pod-cidrs": {
                    "description": "PodCIDRs lists the status of each pod CIDR allocated to this node.",
                    "type": "object",
                    "additionalProperties": {
                      "type": "object",
                      "properties": {
                        "status": {
                          "description": "Status describes the status of a pod CIDR",
                          "type": "string",
                          "enum": [
                            "released",
                            "depleted",
                            "in-use"
                          ]
                        }
                      }
                    }
                  },
                  "release-ips": {
                    "description": "ReleaseIPs tracks the state for every IP considered for release. value can be one of the following string : * marked-for-release : Set by operator as possible candidate for IP * ready-for-release  : Acknowledged as safe to release by agent * do-not-release     : IP already in use / not owned by the node. Set by agent * released           : IP successfully released. Set by operator",
                    "type": "object",
                    "additionalProperties": {
                      "description": "IPReleaseStatus  defines the valid states in IP release handshake",
                      "type": "string",
                      "enum": [
                        "marked-for-release",
                        "ready-for-release",
                        "do-not-release",
                        "released"
                      ]
                    }
                  },
                  "used": {
                    "description": "Used lists all IPs out of Spec.IPAM.Pool which have been allocated and are in use.",
                    "type": "object",
                    "additionalProperties": {
                      "description": "AllocationIP is an IP which is available for allocation, or already has been allocated",
                      "type": "object",
                      "properties": {
                        "owner": {
                          "description": "Owner is the owner of the IP. This field is set if the IP has been allocated. It will be set to the pod name or another identifier representing the usage of the IP \n The owner field is left blank for an entry in Spec.IPAM.Pool and filled out as the IP is used and also added to Status.IPAM.Used.",
                          "type": "string"
                        },
                        "resource": {
                          "description": "Resource is set for both available and allocated IPs, it represents what resource the IP is associated with, e.g. in combination with AWS ENI, this will refer to the ID of the ENI",
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "cilium.io",
            "kind": "CiliumNode",
            "version": "v2"
          }
        ]
      },
      "crd": {
        "metadata": {
          "name": "ciliumnodes.cilium.io",
          "uid": "e63e4483-99aa-4126-b039-1dcb7939570a",
          "resourceVersion": "25877238085",
          "generation": 1,
          "creationTimestamp": "2023-11-21T10:47:04Z",
          "labels": {
            "io.cilium.k8s.crd.schema.version": "1.26.11"
          },
          "managedFields": [
            {
              "manager": "cilium-operator-generic",
              "operation": "Update",
              "apiVersion": "apiextensions.k8s.io/v1",
              "time": "2023-11-21T10:47:04Z",
              "fieldsType": "FieldsV1",
              "fieldsV1": {
                "f:metadata": {
                  "f:labels": {
                    ".": {},
                    "f:io.cilium.k8s.crd.schema.version": {}
                  }
                },
                "f:spec": {
                  "f:conversion": {
                    ".": {},
                    "f:strategy": {}
                  },
                  "f:group": {},
                  "f:names": {
                    "f:kind": {},
                    "f:listKind": {},
                    "f:plural": {},
                    "f:shortNames": {},
                    "f:singular": {}
                  },
                  "f:scope": {},
                  "f:versions": {}
                }
              }
            },
            {
              "manager": "kube-apiserver",
              "operation": "Update",
              "apiVersion": "apiextensions.k8s.io/v1",
              "time": "2023-11-21T10:47:04Z",
              "fieldsType": "FieldsV1",
              "fieldsV1": {
                "f:status": {
                  "f:acceptedNames": {
                    "f:kind": {},
                    "f:listKind": {},
                    "f:plural": {},
                    "f:shortNames": {},
                    "f:singular": {}
                  },
                  "f:conditions": {
                    "k:{\"type\":\"Established\"}": {
                      ".": {},
                      "f:lastTransitionTime": {},
                      "f:message": {},
                      "f:reason": {},
                      "f:status": {},
                      "f:type": {}
                    },
                    "k:{\"type\":\"NamesAccepted\"}": {
                      ".": {},
                      "f:lastTransitionTime": {},
                      "f:message": {},
                      "f:reason": {},
                      "f:status": {},
                      "f:type": {}
                    }
                  }
                }
              },
              "subresource": "status"
            }
          ]
        },
        "spec": {
          "group": "cilium.io",
          "names": {
            "plural": "ciliumnodes",
            "singular": "ciliumnode",
            "shortNames": [
              "cn",
              "ciliumn"
            ],
            "kind": "CiliumNode",
            "listKind": "CiliumNodeList"
          },
          "scope": "Cluster",
          "versions": [
            {
              "name": "v2",
              "served": true,
              "storage": true,
              "schema": {
                "openAPIV3Schema": {
                  "description": "CiliumNode represents a node managed by Cilium. It contains a specification to control various node specific configuration aspects and a status section to represent the status of the node.",
                  "type": "object",
                  "required": [
                    "metadata",
                    "spec"
                  ],
                  "properties": {
                    "apiVersion": {
                      "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                      "type": "string"
                    },
                    "kind": {
                      "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                      "type": "string"
                    },
                    "metadata": {
                      "type": "object"
                    },
                    "spec": {
                      "description": "Spec defines the desired specification/configuration of the node.",
                      "type": "object",
                      "properties": {
                        "addresses": {
                          "description": "Addresses is the list of all node addresses.",
                          "type": "array",
                          "items": {
                            "description": "NodeAddress is a node address.",
                            "type": "object",
                            "properties": {
                              "ip": {
                                "description": "IP is an IP of a node",
                                "type": "string"
                              },
                              "type": {
                                "description": "Type is the type of the node address",
                                "type": "string"
                              }
                            }
                          }
                        },
                        "alibaba-cloud": {
                          "description": "AlibabaCloud is the AlibabaCloud IPAM specific configuration.",
                          "type": "object",
                          "properties": {
                            "availability-zone": {
                              "description": "AvailabilityZone is the availability zone to use when allocating ENIs.",
                              "type": "string"
                            },
                            "cidr-block": {
                              "description": "CIDRBlock is vpc ipv4 CIDR",
                              "type": "string"
                            },
                            "instance-type": {
                              "description": "InstanceType is the ECS instance type, e.g. \"ecs.g6.2xlarge\"",
                              "type": "string"
                            },
                            "security-group-tags": {
                              "description": "SecurityGroupTags is the list of tags to use when evaluating which security groups to use for the ENI.",
                              "type": "object",
                              "additionalProperties": {
                                "type": "string"
                              }
                            },
                            "security-groups": {
                              "description": "SecurityGroups is the list of security groups to attach to any ENI that is created and attached to the instance.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            },
                            "vpc-id": {
                              "description": "VPCID is the VPC ID to use when allocating ENIs.",
                              "type": "string"
                            },
                            "vswitch-tags": {
                              "description": "VSwitchTags is the list of tags to use when evaluating which vSwitch to use for the ENI.",
                              "type": "object",
                              "additionalProperties": {
                                "type": "string"
                              }
                            },
                            "vswitches": {
                              "description": "VSwitches is the ID of vSwitch available for ENI",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            }
                          }
                        },
                        "azure": {
                          "description": "Azure is the Azure IPAM specific configuration.",
                          "type": "object",
                          "properties": {
                            "interface-name": {
                              "description": "InterfaceName is the name of the interface the cilium-operator will use to allocate all the IPs on",
                              "type": "string"
                            }
                          }
                        },
                        "encryption": {
                          "description": "Encryption is the encryption configuration of the node.",
                          "type": "object",
                          "properties": {
                            "key": {
                              "description": "Key is the index to the key to use for encryption or 0 if encryption is disabled.",
                              "type": "integer"
                            }
                          }
                        },
                        "eni": {
                          "description": "ENI is the AWS ENI specific configuration.",
                          "type": "object",
                          "properties": {
                            "availability-zone": {
                              "description": "AvailabilityZone is the availability zone to use when allocating ENIs.",
                              "type": "string"
                            },
                            "delete-on-termination": {
                              "description": "DeleteOnTermination defines that the ENI should be deleted when the associated instance is terminated. If the parameter is not set the default behavior is to delete the ENI on instance termination.",
                              "type": "boolean"
                            },
                            "disable-prefix-delegation": {
                              "description": "DisablePrefixDelegation determines whether ENI prefix delegation should be disabled on this node.",
                              "type": "boolean"
                            },
                            "exclude-interface-tags": {
                              "description": "ExcludeInterfaceTags is the list of tags to use when excluding ENIs for Cilium IP allocation. Any interface matching this set of tags will not be managed by Cilium.",
                              "type": "object",
                              "additionalProperties": {
                                "type": "string"
                              }
                            },
                            "first-interface-index": {
                              "description": "FirstInterfaceIndex is the index of the first ENI to use for IP allocation, e.g. if the node has eth0, eth1, eth2 and FirstInterfaceIndex is set to 1, then only eth1 and eth2 will be used for IP allocation, eth0 will be ignored for PodIP allocation.",
                              "type": "integer",
                              "minimum": 0
                            },
                            "instance-id": {
                              "description": "InstanceID is the AWS InstanceId of the node. The InstanceID is used to retrieve AWS metadata for the node. \n OBSOLETE: This field is obsolete, please use Spec.InstanceID",
                              "type": "string"
                            },
                            "instance-type": {
                              "description": "InstanceType is the AWS EC2 instance type, e.g. \"m5.large\"",
                              "type": "string"
                            },
                            "max-above-watermark": {
                              "description": "MaxAboveWatermark is the maximum number of addresses to allocate beyond the addresses needed to reach the PreAllocate watermark. Going above the watermark can help reduce the number of API calls to allocate IPs, e.g. when a new ENI is allocated, as many secondary IPs as possible are allocated. Limiting the amount can help reduce waste of IPs. \n OBSOLETE: This field is obsolete, please use Spec.IPAM.MaxAboveWatermark",
                              "type": "integer",
                              "minimum": 0
                            },
                            "min-allocate": {
                              "description": "MinAllocate is the minimum number of IPs that must be allocated when the node is first bootstrapped. It defines the minimum base socket of addresses that must be available. After reaching this watermark, the PreAllocate and MaxAboveWatermark logic takes over to continue allocating IPs. \n OBSOLETE: This field is obsolete, please use Spec.IPAM.MinAllocate",
                              "type": "integer",
                              "minimum": 0
                            },
                            "node-subnet-id": {
                              "description": "NodeSubnetID is the subnet of the primary ENI the instance was brought up with. It is used as a sensible default subnet to create ENIs in.",
                              "type": "string"
                            },
                            "pre-allocate": {
                              "description": "PreAllocate defines the number of IP addresses that must be available for allocation in the IPAMspec. It defines the buffer of addresses available immediately without requiring cilium-operator to get involved. \n OBSOLETE: This field is obsolete, please use Spec.IPAM.PreAllocate",
                              "type": "integer",
                              "minimum": 0
                            },
                            "security-group-tags": {
                              "description": "SecurityGroupTags is the list of tags to use when evaliating what AWS security groups to use for the ENI.",
                              "type": "object",
                              "additionalProperties": {
                                "type": "string"
                              }
                            },
                            "security-groups": {
                              "description": "SecurityGroups is the list of security groups to attach to any ENI that is created and attached to the instance.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            },
                            "subnet-ids": {
                              "description": "SubnetIDs is the list of subnet ids to use when evaluating what AWS subnets to use for ENI and IP allocation.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            },
                            "subnet-tags": {
                              "description": "SubnetTags is the list of tags to use when evaluating what AWS subnets to use for ENI and IP allocation.",
                              "type": "object",
                              "additionalProperties": {
                                "type": "string"
                              }
                            },
                            "use-primary-address": {
                              "description": "UsePrimaryAddress determines whether an ENI's primary address should be available for allocations on the node",
                              "type": "boolean"
                            },
                            "vpc-id": {
                              "description": "VpcID is the VPC ID to use when allocating ENIs.",
                              "type": "string"
                            }
                          }
                        },
                        "health": {
                          "description": "HealthAddressing is the addressing information for health connectivity checking.",
                          "type": "object",
                          "properties": {
                            "ipv4": {
                              "description": "IPv4 is the IPv4 address of the IPv4 health endpoint.",
                              "type": "string"
                            },
                            "ipv6": {
                              "description": "IPv6 is the IPv6 address of the IPv4 health endpoint.",
                              "type": "string"
                            }
                          }
                        },
                        "ingress": {
                          "description": "IngressAddressing is the addressing information for Ingress listener.",
                          "type": "object",
                          "properties": {
                            "ipv4": {
                              "type": "string"
                            },
                            "ipv6": {
                              "type": "string"
                            }
                          }
                        },
                        "instance-id": {
                          "description": "InstanceID is the identifier of the node. This is different from the node name which is typically the FQDN of the node. The InstanceID typically refers to the identifier used by the cloud provider or some other means of identification.",
                          "type": "string"
                        },
                        "ipam": {
                          "description": "IPAM is the address management specification. This section can be populated by a user or it can be automatically populated by an IPAM operator.",
                          "type": "object",
                          "properties": {
                            "max-above-watermark": {
                              "description": "MaxAboveWatermark is the maximum number of addresses to allocate beyond the addresses needed to reach the PreAllocate watermark. Going above the watermark can help reduce the number of API calls to allocate IPs, e.g. when a new ENI is allocated, as many secondary IPs as possible are allocated. Limiting the amount can help reduce waste of IPs.",
                              "type": "integer",
                              "minimum": 0
                            },
                            "max-allocate": {
                              "description": "MaxAllocate is the maximum number of IPs that can be allocated to the node. When the current amount of allocated IPs will approach this value, the considered value for PreAllocate will decrease down to 0 in order to not attempt to allocate more addresses than defined.",
                              "type": "integer",
                              "minimum": 0
                            },
                            "min-allocate": {
                              "description": "MinAllocate is the minimum number of IPs that must be allocated when the node is first bootstrapped. It defines the minimum base socket of addresses that must be available. After reaching this watermark, the PreAllocate and MaxAboveWatermark logic takes over to continue allocating IPs.",
                              "type": "integer",
                              "minimum": 0
                            },
                            "pod-cidr-allocation-threshold": {
                              "description": "PodCIDRAllocationThreshold defines the minimum number of free IPs which must be available to this node via its pod CIDR pool. If the total number of IP addresses in the pod CIDR pool is less than this value, the pod CIDRs currently in-use by this node will be marked as depleted and cilium-operator will allocate a new pod CIDR to this node. This value effectively defines the buffer of IP addresses available immediately without requiring cilium-operator to get involved.",
                              "type": "integer",
                              "minimum": 0
                            },
                            "pod-cidr-release-threshold": {
                              "description": "PodCIDRReleaseThreshold defines the maximum number of free IPs which may be available to this node via its pod CIDR pool. While the total number of free IP addresses in the pod CIDR pool is larger than this value, cilium-agent will attempt to release currently unused pod CIDRs.",
                              "type": "integer",
                              "minimum": 0
                            },
                            "podCIDRs": {
                              "description": "PodCIDRs is the list of CIDRs available to the node for allocation. When an IP is used, the IP will be added to Status.IPAM.Used",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            },
                            "pool": {
                              "description": "Pool is the list of IPs available to the node for allocation. When an IP is used, the IP will remain on this list but will be added to Status.IPAM.Used",
                              "type": "object",
                              "additionalProperties": {
                                "description": "AllocationIP is an IP which is available for allocation, or already has been allocated",
                                "type": "object",
                                "properties": {
                                  "owner": {
                                    "description": "Owner is the owner of the IP. This field is set if the IP has been allocated. It will be set to the pod name or another identifier representing the usage of the IP \n The owner field is left blank for an entry in Spec.IPAM.Pool and filled out as the IP is used and also added to Status.IPAM.Used.",
                                    "type": "string"
                                  },
                                  "resource": {
                                    "description": "Resource is set for both available and allocated IPs, it represents what resource the IP is associated with, e.g. in combination with AWS ENI, this will refer to the ID of the ENI",
                                    "type": "string"
                                  }
                                }
                              }
                            },
                            "pools": {
                              "description": "Pools contains the list of assigned IPAM pools for this node.",
                              "type": "object",
                              "properties": {
                                "allocated": {
                                  "description": "Allocated contains the list of pooled CIDR assigned to this node. The operator will add new pod CIDRs to this field, whereas the agent will remove CIDRs it has released.",
                                  "type": "array",
                                  "items": {
                                    "description": "IPAMPoolAllocation describes an allocation of an IPAM pool from the operator to the node. It contains the assigned PodCIDRs allocated from this pool",
                                    "type": "object",
                                    "required": [
                                      "pool"
                                    ],
                                    "properties": {
                                      "cidrs": {
                                        "description": "CIDRs contains a list of pod CIDRs currently allocated from this pool",
                                        "type": "array",
                                        "items": {
                                          "description": "IPAMPodCIDR is a pod CIDR",
                                          "type": "string",
                                          "format": "cidr"
                                        }
                                      },
                                      "pool": {
                                        "description": "Pool is the name of the IPAM pool backing this allocation",
                                        "type": "string",
                                        "minLength": 1
                                      }
                                    }
                                  }
                                },
                                "requested": {
                                  "description": "Requested contains a list of IPAM pool requests, i.e. indicates how many addresses this node requests out of each pool listed here. This field is owned and written to by cilium-agent and read by the operator.",
                                  "type": "array",
                                  "items": {
                                    "type": "object",
                                    "required": [
                                      "pool"
                                    ],
                                    "properties": {
                                      "needed": {
                                        "description": "Needed indicates how many IPs out of the above Pool this node requests from the operator. The operator runs a reconciliation loop to ensure each node always has enough PodCIDRs allocated in each pool to fulfill the requested number of IPs here.",
                                        "type": "object",
                                        "properties": {
                                          "ipv4-addrs": {
                                            "description": "IPv4Addrs contains the number of requested IPv4 addresses out of a given pool",
                                            "type": "integer"
                                          },
                                          "ipv6-addrs": {
                                            "description": "IPv6Addrs contains the number of requested IPv6 addresses out of a given pool",
                                            "type": "integer"
                                          }
                                        }
                                      },
                                      "pool": {
                                        "description": "Pool is the name of the IPAM pool backing this request",
                                        "type": "string",
                                        "minLength": 1
                                      }
                                    }
                                  }
                                }
                              }
                            },
                            "pre-allocate": {
                              "description": "PreAllocate defines the number of IP addresses that must be available for allocation in the IPAMspec. It defines the buffer of addresses available immediately without requiring cilium-operator to get involved.",
                              "type": "integer",
                              "minimum": 0
                            }
                          }
                        },
                        "nodeidentity": {
                          "description": "NodeIdentity is the Cilium numeric identity allocated for the node, if any.",
                          "type": "integer",
                          "format": "int64"
                        }
                      }
                    },
                    "status": {
                      "description": "Status defines the realized specification/configuration and status of the node.",
                      "type": "object",
                      "properties": {
                        "alibaba-cloud": {
                          "description": "AlibabaCloud is the AlibabaCloud specific status of the node.",
                          "type": "object",
                          "properties": {
                            "enis": {
                              "description": "ENIs is the list of ENIs on the node",
                              "type": "object",
                              "additionalProperties": {
                                "description": "ENI represents an AlibabaCloud Elastic Network Interface",
                                "type": "object",
                                "properties": {
                                  "instance-id": {
                                    "description": "InstanceID is the InstanceID using this ENI",
                                    "type": "string"
                                  },
                                  "mac-address": {
                                    "description": "MACAddress is the mac address of the ENI",
                                    "type": "string"
                                  },
                                  "network-interface-id": {
                                    "description": "NetworkInterfaceID is the ENI id",
                                    "type": "string"
                                  },
                                  "primary-ip-address": {
                                    "description": "PrimaryIPAddress is the primary IP on ENI",
                                    "type": "string"
                                  },
                                  "private-ipsets": {
                                    "description": "PrivateIPSets is the list of all IPs on the ENI, including PrimaryIPAddress",
                                    "type": "array",
                                    "items": {
                                      "description": "PrivateIPSet is a nested struct in ecs response",
                                      "type": "object",
                                      "properties": {
                                        "primary": {
                                          "type": "boolean"
                                        },
                                        "private-ip-address": {
                                          "type": "string"
                                        }
                                      }
                                    }
                                  },
                                  "security-groupids": {
                                    "description": "SecurityGroupIDs is the security group ids used by this ENI",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  },
                                  "tags": {
                                    "description": "Tags is the tags on this ENI",
                                    "type": "object",
                                    "additionalProperties": {
                                      "type": "string"
                                    }
                                  },
                                  "type": {
                                    "description": "Type is the ENI type Primary or Secondary",
                                    "type": "string"
                                  },
                                  "vpc": {
                                    "description": "VPC is the vpc to which the ENI belongs",
                                    "type": "object",
                                    "properties": {
                                      "cidr": {
                                        "description": "CIDRBlock is the VPC IPv4 CIDR",
                                        "type": "string"
                                      },
                                      "ipv6-cidr": {
                                        "description": "IPv6CIDRBlock is the VPC IPv6 CIDR",
                                        "type": "string"
                                      },
                                      "vpc-id": {
                                        "description": "VPCID is the vpc to which the ENI belongs",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "vswitch": {
                                    "description": "VSwitch is the vSwitch the ENI is using",
                                    "type": "object",
                                    "properties": {
                                      "cidr": {
                                        "description": "CIDRBlock is the vSwitch IPv4 CIDR",
                                        "type": "string"
                                      },
                                      "ipv6-cidr": {
                                        "description": "IPv6CIDRBlock is the vSwitch IPv6 CIDR",
                                        "type": "string"
                                      },
                                      "vswitch-id": {
                                        "description": "VSwitchID is the vSwitch to which the ENI belongs",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "zone-id": {
                                    "description": "ZoneID is the zone to which the ENI belongs",
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          }
                        },
                        "azure": {
                          "description": "Azure is the Azure specific status of the node.",
                          "type": "object",
                          "properties": {
                            "interfaces": {
                              "description": "Interfaces is the list of interfaces on the node",
                              "type": "array",
                              "items": {
                                "description": "AzureInterface represents an Azure Interface",
                                "type": "object",
                                "properties": {
                                  "GatewayIP": {
                                    "description": "GatewayIP is the interface's subnet's default route \n OBSOLETE: This field is obsolete, please use Gateway field instead.",
                                    "type": "string"
                                  },
                                  "addresses": {
                                    "description": "Addresses is the list of all IPs associated with the interface, including all secondary addresses",
                                    "type": "array",
                                    "items": {
                                      "description": "AzureAddress is an IP address assigned to an AzureInterface",
                                      "type": "object",
                                      "properties": {
                                        "ip": {
                                          "description": "IP is the ip address of the address",
                                          "type": "string"
                                        },
                                        "state": {
                                          "description": "State is the provisioning state of the address",
                                          "type": "string"
                                        },
                                        "subnet": {
                                          "description": "Subnet is the subnet the address belongs to",
                                          "type": "string"
                                        }
                                      }
                                    }
                                  },
                                  "cidr": {
                                    "description": "CIDR is the range that the interface belongs to.",
                                    "type": "string"
                                  },
                                  "gateway": {
                                    "description": "Gateway is the interface's subnet's default route",
                                    "type": "string"
                                  },
                                  "id": {
                                    "description": "ID is the identifier",
                                    "type": "string"
                                  },
                                  "mac": {
                                    "description": "MAC is the mac address",
                                    "type": "string"
                                  },
                                  "name": {
                                    "description": "Name is the name of the interface",
                                    "type": "string"
                                  },
                                  "security-group": {
                                    "description": "SecurityGroup is the security group associated with the interface",
                                    "type": "string"
                                  },
                                  "state": {
                                    "description": "State is the provisioning state",
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          }
                        },
                        "eni": {
                          "description": "ENI is the AWS ENI specific status of the node.",
                          "type": "object",
                          "properties": {
                            "enis": {
                              "description": "ENIs is the list of ENIs on the node",
                              "type": "object",
                              "additionalProperties": {
                                "description": "ENI represents an AWS Elastic Network Interface \n More details: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html",
                                "type": "object",
                                "properties": {
                                  "addresses": {
                                    "description": "Addresses is the list of all secondary IPs associated with the ENI",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  },
                                  "availability-zone": {
                                    "description": "AvailabilityZone is the availability zone of the ENI",
                                    "type": "string"
                                  },
                                  "description": {
                                    "description": "Description is the description field of the ENI",
                                    "type": "string"
                                  },
                                  "id": {
                                    "description": "ID is the ENI ID",
                                    "type": "string"
                                  },
                                  "ip": {
                                    "description": "IP is the primary IP of the ENI",
                                    "type": "string"
                                  },
                                  "mac": {
                                    "description": "MAC is the mac address of the ENI",
                                    "type": "string"
                                  },
                                  "number": {
                                    "description": "Number is the interface index, it used in combination with FirstInterfaceIndex",
                                    "type": "integer"
                                  },
                                  "prefixes": {
                                    "description": "Prefixes is the list of all /28 prefixes associated with the ENI",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  },
                                  "security-groups": {
                                    "description": "SecurityGroups are the security groups associated with the ENI",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  },
                                  "subnet": {
                                    "description": "Subnet is the subnet the ENI is associated with",
                                    "type": "object",
                                    "properties": {
                                      "cidr": {
                                        "description": "CIDR is the CIDR range associated with the subnet",
                                        "type": "string"
                                      },
                                      "id": {
                                        "description": "ID is the ID of the subnet",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "tags": {
                                    "description": "Tags is the set of tags of the ENI. Used to detect ENIs which should not be managed by Cilium",
                                    "type": "object",
                                    "additionalProperties": {
                                      "type": "string"
                                    }
                                  },
                                  "vpc": {
                                    "description": "VPC is the VPC information to which the ENI is attached to",
                                    "type": "object",
                                    "properties": {
                                      "cidrs": {
                                        "description": "CIDRs is the list of CIDR ranges associated with the VPC",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        }
                                      },
                                      "id": {
                                        "description": "/ ID is the ID of a VPC",
                                        "type": "string"
                                      },
                                      "primary-cidr": {
                                        "description": "PrimaryCIDR is the primary CIDR of the VPC",
                                        "type": "string"
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        "ipam": {
                          "description": "IPAM is the IPAM status of the node.",
                          "type": "object",
                          "properties": {
                            "operator-status": {
                              "description": "Operator is the Operator status of the node",
                              "type": "object",
                              "properties": {
                                "error": {
                                  "description": "Error is the error message set by cilium-operator.",
                                  "type": "string"
                                }
                              }
                            },
                            "pod-cidrs": {
                              "description": "PodCIDRs lists the status of each pod CIDR allocated to this node.",
                              "type": "object",
                              "additionalProperties": {
                                "type": "object",
                                "properties": {
                                  "status": {
                                    "description": "Status describes the status of a pod CIDR",
                                    "type": "string",
                                    "enum": [
                                      "released",
                                      "depleted",
                                      "in-use"
                                    ]
                                  }
                                }
                              }
                            },
                            "release-ips": {
                              "description": "ReleaseIPs tracks the state for every IP considered for release. value can be one of the following string : * marked-for-release : Set by operator as possible candidate for IP * ready-for-release  : Acknowledged as safe to release by agent * do-not-release     : IP already in use / not owned by the node. Set by agent * released           : IP successfully released. Set by operator",
                              "type": "object",
                              "additionalProperties": {
                                "description": "IPReleaseStatus  defines the valid states in IP release handshake",
                                "type": "string",
                                "enum": [
                                  "marked-for-release",
                                  "ready-for-release",
                                  "do-not-release",
                                  "released"
                                ]
                              }
                            },
                            "used": {
                              "description": "Used lists all IPs out of Spec.IPAM.Pool which have been allocated and are in use.",
                              "type": "object",
                              "additionalProperties": {
                                "description": "AllocationIP is an IP which is available for allocation, or already has been allocated",
                                "type": "object",
                                "properties": {
                                  "owner": {
                                    "description": "Owner is the owner of the IP. This field is set if the IP has been allocated. It will be set to the pod name or another identifier representing the usage of the IP \n The owner field is left blank for an entry in Spec.IPAM.Pool and filled out as the IP is used and also added to Status.IPAM.Used.",
                                    "type": "string"
                                  },
                                  "resource": {
                                    "description": "Resource is set for both available and allocated IPs, it represents what resource the IP is associated with, e.g. in combination with AWS ENI, this will refer to the ID of the ENI",
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              },
              "subresources": {
                "status": {}
              },
              "additionalPrinterColumns": [
                {
                  "name": "CiliumInternalIP",
                  "type": "string",
                  "description": "Cilium internal IP for this node",
                  "jsonPath": ".spec.addresses[?(@.type==\"CiliumInternalIP\")].ip"
                },
                {
                  "name": "InternalIP",
                  "type": "string",
                  "description": "IP of the node",
                  "jsonPath": ".spec.addresses[?(@.type==\"InternalIP\")].ip"
                },
                {
                  "name": "Age",
                  "type": "date",
                  "description": "Time duration since creation of Ciliumnode",
                  "jsonPath": ".metadata.creationTimestamp"
                }
              ]
            }
          ],
          "conversion": {
            "strategy": "None"
          }
        },
        "status": {
          "conditions": [
            {
              "type": "NamesAccepted",
              "status": "True",
              "lastTransitionTime": "2023-11-21T10:47:04Z",
              "reason": "NoConflicts",
              "message": "no conflicts found"
            },
            {
              "type": "Established",
              "status": "True",
              "lastTransitionTime": "2023-11-21T10:47:04Z",
              "reason": "InitialNamesAccepted",
              "message": "the initial names have been accepted"
            }
          ],
          "acceptedNames": {
            "plural": "ciliumnodes",
            "singular": "ciliumnode",
            "shortNames": [
              "cn",
              "ciliumn"
            ],
            "kind": "CiliumNode",
            "listKind": "CiliumNodeList"
          },
          "storedVersions": [
            "v2"
          ]
        }
      },
      "additionalColumns": [
        {
          "name": "CiliumInternalIP",
          "type": "string",
          "description": "Cilium internal IP for this node",
          "jsonPath": ".spec.addresses[?(@.type==\"CiliumInternalIP\")].ip"
        },
        {
          "name": "InternalIP",
          "type": "string",
          "description": "IP of the node",
          "jsonPath": ".spec.addresses[?(@.type==\"InternalIP\")].ip"
        },
        {
          "name": "Age",
          "type": "date",
          "description": "Time duration since creation of Ciliumnode",
          "jsonPath": ".metadata.creationTimestamp"
        }
      ],
      "short": "CiliumNode",
      "apiGroup": "cilium.io",
      "apiKind": "CiliumNode",
      "apiVersion": "v2",
      "readProperties": {
        "spec": "spec",
        "status": "status"
      },
      "writeProperties": {
        "spec": "spec"
      },
      "group": "cilium",
      "sub": "cilium",
      "listExcludes": [],
      "readExcludes": [],
      "simpleExcludes": [],
      "gqlDefs": {
        "metadata": "metadata!",
        "spec": "JSONObject",
        "status": "JSONObject"
      },
      "namespaced": false
    },
    {
      "alternatives": [],
      "name": "io.cilium.v2alpha1.CiliumCIDRGroup",
      "definition": {
        "description": "CiliumCIDRGroup is a list of external CIDRs (i.e: CIDRs selecting peers outside the clusters) that can be referenced as a single entity from CiliumNetworkPolicies.",
        "type": "object",
        "required": [
          "spec"
        ],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "spec": {
            "type": "object",
            "required": [
              "externalCIDRs"
            ],
            "properties": {
              "externalCIDRs": {
                "description": "ExternalCIDRs is a list of CIDRs selecting peers outside the clusters.",
                "type": "array",
                "minItems": 0,
                "items": {
                  "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                  "type": "string",
                  "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                }
              }
            }
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "cilium.io",
            "kind": "CiliumCIDRGroup",
            "version": "v2alpha1"
          }
        ]
      },
      "crd": {
        "metadata": {
          "name": "ciliumcidrgroups.cilium.io",
          "uid": "237adbd4-29f3-4e58-bb3d-27553dbdf045",
          "resourceVersion": "25877237674",
          "generation": 1,
          "creationTimestamp": "2023-11-21T10:47:03Z",
          "labels": {
            "io.cilium.k8s.crd.schema.version": "1.26.11"
          },
          "managedFields": [
            {
              "manager": "cilium-operator-generic",
              "operation": "Update",
              "apiVersion": "apiextensions.k8s.io/v1",
              "time": "2023-11-21T10:47:03Z",
              "fieldsType": "FieldsV1",
              "fieldsV1": {
                "f:metadata": {
                  "f:labels": {
                    ".": {},
                    "f:io.cilium.k8s.crd.schema.version": {}
                  }
                },
                "f:spec": {
                  "f:conversion": {
                    ".": {},
                    "f:strategy": {}
                  },
                  "f:group": {},
                  "f:names": {
                    "f:kind": {},
                    "f:listKind": {},
                    "f:plural": {},
                    "f:shortNames": {},
                    "f:singular": {}
                  },
                  "f:scope": {},
                  "f:versions": {}
                }
              }
            },
            {
              "manager": "kube-apiserver",
              "operation": "Update",
              "apiVersion": "apiextensions.k8s.io/v1",
              "time": "2023-11-21T10:47:03Z",
              "fieldsType": "FieldsV1",
              "fieldsV1": {
                "f:status": {
                  "f:acceptedNames": {
                    "f:kind": {},
                    "f:listKind": {},
                    "f:plural": {},
                    "f:shortNames": {},
                    "f:singular": {}
                  },
                  "f:conditions": {
                    "k:{\"type\":\"Established\"}": {
                      ".": {},
                      "f:lastTransitionTime": {},
                      "f:message": {},
                      "f:reason": {},
                      "f:status": {},
                      "f:type": {}
                    },
                    "k:{\"type\":\"NamesAccepted\"}": {
                      ".": {},
                      "f:lastTransitionTime": {},
                      "f:message": {},
                      "f:reason": {},
                      "f:status": {},
                      "f:type": {}
                    }
                  }
                }
              },
              "subresource": "status"
            }
          ]
        },
        "spec": {
          "group": "cilium.io",
          "names": {
            "plural": "ciliumcidrgroups",
            "singular": "ciliumcidrgroup",
            "shortNames": [
              "ccg"
            ],
            "kind": "CiliumCIDRGroup",
            "listKind": "CiliumCIDRGroupList"
          },
          "scope": "Cluster",
          "versions": [
            {
              "name": "v2alpha1",
              "served": true,
              "storage": true,
              "schema": {
                "openAPIV3Schema": {
                  "description": "CiliumCIDRGroup is a list of external CIDRs (i.e: CIDRs selecting peers outside the clusters) that can be referenced as a single entity from CiliumNetworkPolicies.",
                  "type": "object",
                  "required": [
                    "spec"
                  ],
                  "properties": {
                    "apiVersion": {
                      "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                      "type": "string"
                    },
                    "kind": {
                      "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                      "type": "string"
                    },
                    "metadata": {
                      "type": "object"
                    },
                    "spec": {
                      "type": "object",
                      "required": [
                        "externalCIDRs"
                      ],
                      "properties": {
                        "externalCIDRs": {
                          "description": "ExternalCIDRs is a list of CIDRs selecting peers outside the clusters.",
                          "type": "array",
                          "minItems": 0,
                          "items": {
                            "description": "CIDR specifies a block of IP addresses. Example: 192.0.2.1/32",
                            "type": "string",
                            "pattern": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\/([0-9]|[1-2][0-9]|3[0-2])$|^s*((([0-9A-Fa-f]{1,4}:){7}(:|([0-9A-Fa-f]{1,4})))|(([0-9A-Fa-f]{1,4}:){6}:([0-9A-Fa-f]{1,4})?)|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){0,1}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){0,2}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){0,3}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){0,4}):([0-9A-Fa-f]{1,4})?))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){0,5}):([0-9A-Fa-f]{1,4})?))|(:(:|((:[0-9A-Fa-f]{1,4}){1,7}))))(%.+)?s*/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          ],
          "conversion": {
            "strategy": "None"
          }
        },
        "status": {
          "conditions": [
            {
              "type": "NamesAccepted",
              "status": "True",
              "lastTransitionTime": "2023-11-21T10:47:03Z",
              "reason": "NoConflicts",
              "message": "no conflicts found"
            },
            {
              "type": "Established",
              "status": "True",
              "lastTransitionTime": "2023-11-21T10:47:03Z",
              "reason": "InitialNamesAccepted",
              "message": "the initial names have been accepted"
            }
          ],
          "acceptedNames": {
            "plural": "ciliumcidrgroups",
            "singular": "ciliumcidrgroup",
            "shortNames": [
              "ccg"
            ],
            "kind": "CiliumCIDRGroup",
            "listKind": "CiliumCIDRGroupList"
          },
          "storedVersions": [
            "v2alpha1"
          ]
        }
      },
      "short": "CiliumCIDRGroup",
      "apiGroup": "cilium.io",
      "apiKind": "CiliumCIDRGroup",
      "apiVersion": "v2alpha1",
      "readProperties": {
        "spec": "spec"
      },
      "writeProperties": {
        "spec": "spec"
      },
      "group": "cilium",
      "sub": "cilium",
      "listExcludes": [],
      "readExcludes": [],
      "simpleExcludes": [],
      "gqlDefs": {
        "metadata": "metadata!",
        "spec": "JSONObject"
      },
      "namespaced": false
    },
    {
      "alternatives": [],
      "name": "io.cilium.v2alpha1.CiliumL2AnnouncementPolicy",
      "definition": {
        "description": "CiliumL2AnnouncementPolicy is a Kubernetes third-party resource which is used to defined which nodes should announce what services on the L2 network.",
        "type": "object",
        "required": [
          "metadata"
        ],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "spec": {
            "description": "Spec is a human readable description of a L2 announcement policy",
            "type": "object",
            "properties": {
              "externalIPs": {
                "description": "If true, the external IPs of the services are announced",
                "type": "boolean"
              },
              "interfaces": {
                "description": "A list of regular expressions that express which network interface(s) should be used to announce the services over. If nil, all network interfaces are used.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "loadBalancerIPs": {
                "description": "If true, the loadbalancer IPs of the services are announced \n If nil this policy applies to all services.",
                "type": "boolean"
              },
              "nodeSelector": {
                "description": "NodeSelector selects a group of nodes which will announce the IPs for the services selected by the service selector. \n If nil this policy applies to all nodes.",
                "type": "object",
                "properties": {
                  "matchExpressions": {
                    "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                    "type": "array",
                    "items": {
                      "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                      "type": "object",
                      "required": [
                        "key",
                        "operator"
                      ],
                      "properties": {
                        "key": {
                          "description": "key is the label key that the selector applies to.",
                          "type": "string"
                        },
                        "operator": {
                          "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                          "type": "string",
                          "enum": [
                            "In",
                            "NotIn",
                            "Exists",
                            "DoesNotExist"
                          ]
                        },
                        "values": {
                          "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        }
                      }
                    }
                  },
                  "matchLabels": {
                    "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                    "type": "object",
                    "additionalProperties": {
                      "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                      "type": "string",
                      "maxLength": 63,
                      "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                    }
                  }
                }
              },
              "serviceSelector": {
                "description": "ServiceSelector selects a set of services which will be announced over L2 networks \n If nil this policy applies to all services.",
                "type": "object",
                "properties": {
                  "matchExpressions": {
                    "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                    "type": "array",
                    "items": {
                      "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                      "type": "object",
                      "required": [
                        "key",
                        "operator"
                      ],
                      "properties": {
                        "key": {
                          "description": "key is the label key that the selector applies to.",
                          "type": "string"
                        },
                        "operator": {
                          "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                          "type": "string",
                          "enum": [
                            "In",
                            "NotIn",
                            "Exists",
                            "DoesNotExist"
                          ]
                        },
                        "values": {
                          "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        }
                      }
                    }
                  },
                  "matchLabels": {
                    "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                    "type": "object",
                    "additionalProperties": {
                      "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                      "type": "string",
                      "maxLength": 63,
                      "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                    }
                  }
                }
              }
            }
          },
          "status": {
            "description": "Status is the status of the policy.",
            "type": "object",
            "properties": {
              "conditions": {
                "description": "Current service state",
                "type": "array",
                "items": {
                  "description": "Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, \n \ttype FooStatus struct{ \t    // Represents the observations of a foo's current state. \t    // Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\" \t    // +patchMergeKey=type \t    // +patchStrategy=merge \t    // +listType=map \t    // +listMapKey=type \t    Conditions []metav1.Condition `json:\"conditions,omitempty\" patchStrategy:\"merge\" patchMergeKey:\"type\" protobuf:\"bytes,1,rep,name=conditions\"` \n \t    // other fields \t}",
                  "type": "object",
                  "required": [
                    "lastTransitionTime",
                    "message",
                    "reason",
                    "status",
                    "type"
                  ],
                  "properties": {
                    "lastTransitionTime": {
                      "description": "lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
                      "type": "string",
                      "format": "date-time"
                    },
                    "message": {
                      "description": "message is a human readable message indicating details about the transition. This may be an empty string.",
                      "type": "string",
                      "maxLength": 32768
                    },
                    "observedGeneration": {
                      "description": "observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.",
                      "type": "integer",
                      "format": "int64",
                      "minimum": 0
                    },
                    "reason": {
                      "description": "reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.",
                      "type": "string",
                      "maxLength": 1024,
                      "minLength": 1,
                      "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
                    },
                    "status": {
                      "description": "status of the condition, one of True, False, Unknown.",
                      "type": "string",
                      "enum": [
                        "True",
                        "False",
                        "Unknown"
                      ]
                    },
                    "type": {
                      "description": "type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)",
                      "type": "string",
                      "maxLength": 316,
                      "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
                    }
                  }
                },
                "x-kubernetes-list-map-keys": [
                  "type"
                ],
                "x-kubernetes-list-type": "map"
              }
            }
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "cilium.io",
            "kind": "CiliumL2AnnouncementPolicy",
            "version": "v2alpha1"
          }
        ]
      },
      "crd": {
        "metadata": {
          "name": "ciliuml2announcementpolicies.cilium.io",
          "uid": "045b0f4b-4aa5-4b83-8498-e19a8ca2d17b",
          "resourceVersion": "25877237891",
          "generation": 1,
          "creationTimestamp": "2023-11-21T10:47:03Z",
          "labels": {
            "io.cilium.k8s.crd.schema.version": "1.26.11"
          },
          "managedFields": [
            {
              "manager": "cilium-operator-generic",
              "operation": "Update",
              "apiVersion": "apiextensions.k8s.io/v1",
              "time": "2023-11-21T10:47:03Z",
              "fieldsType": "FieldsV1",
              "fieldsV1": {
                "f:metadata": {
                  "f:labels": {
                    ".": {},
                    "f:io.cilium.k8s.crd.schema.version": {}
                  }
                },
                "f:spec": {
                  "f:conversion": {
                    ".": {},
                    "f:strategy": {}
                  },
                  "f:group": {},
                  "f:names": {
                    "f:kind": {},
                    "f:listKind": {},
                    "f:plural": {},
                    "f:shortNames": {},
                    "f:singular": {}
                  },
                  "f:scope": {},
                  "f:versions": {}
                }
              }
            },
            {
              "manager": "kube-apiserver",
              "operation": "Update",
              "apiVersion": "apiextensions.k8s.io/v1",
              "time": "2023-11-21T10:47:03Z",
              "fieldsType": "FieldsV1",
              "fieldsV1": {
                "f:status": {
                  "f:acceptedNames": {
                    "f:kind": {},
                    "f:listKind": {},
                    "f:plural": {},
                    "f:shortNames": {},
                    "f:singular": {}
                  },
                  "f:conditions": {
                    "k:{\"type\":\"Established\"}": {
                      ".": {},
                      "f:lastTransitionTime": {},
                      "f:message": {},
                      "f:reason": {},
                      "f:status": {},
                      "f:type": {}
                    },
                    "k:{\"type\":\"NamesAccepted\"}": {
                      ".": {},
                      "f:lastTransitionTime": {},
                      "f:message": {},
                      "f:reason": {},
                      "f:status": {},
                      "f:type": {}
                    }
                  }
                }
              },
              "subresource": "status"
            }
          ]
        },
        "spec": {
          "group": "cilium.io",
          "names": {
            "plural": "ciliuml2announcementpolicies",
            "singular": "ciliuml2announcementpolicy",
            "shortNames": [
              "l2announcement"
            ],
            "kind": "CiliumL2AnnouncementPolicy",
            "listKind": "CiliumL2AnnouncementPolicyList"
          },
          "scope": "Cluster",
          "versions": [
            {
              "name": "v2alpha1",
              "served": true,
              "storage": true,
              "schema": {
                "openAPIV3Schema": {
                  "description": "CiliumL2AnnouncementPolicy is a Kubernetes third-party resource which is used to defined which nodes should announce what services on the L2 network.",
                  "type": "object",
                  "required": [
                    "metadata"
                  ],
                  "properties": {
                    "apiVersion": {
                      "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                      "type": "string"
                    },
                    "kind": {
                      "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                      "type": "string"
                    },
                    "metadata": {
                      "type": "object"
                    },
                    "spec": {
                      "description": "Spec is a human readable description of a L2 announcement policy",
                      "type": "object",
                      "properties": {
                        "externalIPs": {
                          "description": "If true, the external IPs of the services are announced",
                          "type": "boolean"
                        },
                        "interfaces": {
                          "description": "A list of regular expressions that express which network interface(s) should be used to announce the services over. If nil, all network interfaces are used.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        },
                        "loadBalancerIPs": {
                          "description": "If true, the loadbalancer IPs of the services are announced \n If nil this policy applies to all services.",
                          "type": "boolean"
                        },
                        "nodeSelector": {
                          "description": "NodeSelector selects a group of nodes which will announce the IPs for the services selected by the service selector. \n If nil this policy applies to all nodes.",
                          "type": "object",
                          "properties": {
                            "matchExpressions": {
                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                              "type": "array",
                              "items": {
                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "key is the label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                    "type": "string",
                                    "enum": [
                                      "In",
                                      "NotIn",
                                      "Exists",
                                      "DoesNotExist"
                                    ]
                                  },
                                  "values": {
                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "matchLabels": {
                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                              "type": "object",
                              "additionalProperties": {
                                "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                "type": "string",
                                "maxLength": 63,
                                "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                              }
                            }
                          }
                        },
                        "serviceSelector": {
                          "description": "ServiceSelector selects a set of services which will be announced over L2 networks \n If nil this policy applies to all services.",
                          "type": "object",
                          "properties": {
                            "matchExpressions": {
                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                              "type": "array",
                              "items": {
                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "key is the label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                    "type": "string",
                                    "enum": [
                                      "In",
                                      "NotIn",
                                      "Exists",
                                      "DoesNotExist"
                                    ]
                                  },
                                  "values": {
                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "matchLabels": {
                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                              "type": "object",
                              "additionalProperties": {
                                "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                "type": "string",
                                "maxLength": 63,
                                "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                              }
                            }
                          }
                        }
                      }
                    },
                    "status": {
                      "description": "Status is the status of the policy.",
                      "type": "object",
                      "properties": {
                        "conditions": {
                          "description": "Current service state",
                          "type": "array",
                          "items": {
                            "description": "Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, \n \ttype FooStatus struct{ \t    // Represents the observations of a foo's current state. \t    // Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\" \t    // +patchMergeKey=type \t    // +patchStrategy=merge \t    // +listType=map \t    // +listMapKey=type \t    Conditions []metav1.Condition `json:\"conditions,omitempty\" patchStrategy:\"merge\" patchMergeKey:\"type\" protobuf:\"bytes,1,rep,name=conditions\"` \n \t    // other fields \t}",
                            "type": "object",
                            "required": [
                              "lastTransitionTime",
                              "message",
                              "reason",
                              "status",
                              "type"
                            ],
                            "properties": {
                              "lastTransitionTime": {
                                "description": "lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
                                "type": "string",
                                "format": "date-time"
                              },
                              "message": {
                                "description": "message is a human readable message indicating details about the transition. This may be an empty string.",
                                "type": "string",
                                "maxLength": 32768
                              },
                              "observedGeneration": {
                                "description": "observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.",
                                "type": "integer",
                                "format": "int64",
                                "minimum": 0
                              },
                              "reason": {
                                "description": "reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.",
                                "type": "string",
                                "maxLength": 1024,
                                "minLength": 1,
                                "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
                              },
                              "status": {
                                "description": "status of the condition, one of True, False, Unknown.",
                                "type": "string",
                                "enum": [
                                  "True",
                                  "False",
                                  "Unknown"
                                ]
                              },
                              "type": {
                                "description": "type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)",
                                "type": "string",
                                "maxLength": 316,
                                "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
                              }
                            }
                          },
                          "x-kubernetes-list-map-keys": [
                            "type"
                          ],
                          "x-kubernetes-list-type": "map"
                        }
                      }
                    }
                  }
                }
              },
              "subresources": {
                "status": {}
              },
              "additionalPrinterColumns": [
                {
                  "name": "Age",
                  "type": "date",
                  "jsonPath": ".metadata.creationTimestamp"
                }
              ]
            }
          ],
          "conversion": {
            "strategy": "None"
          }
        },
        "status": {
          "conditions": [
            {
              "type": "NamesAccepted",
              "status": "True",
              "lastTransitionTime": "2023-11-21T10:47:03Z",
              "reason": "NoConflicts",
              "message": "no conflicts found"
            },
            {
              "type": "Established",
              "status": "True",
              "lastTransitionTime": "2023-11-21T10:47:03Z",
              "reason": "InitialNamesAccepted",
              "message": "the initial names have been accepted"
            }
          ],
          "acceptedNames": {
            "plural": "ciliuml2announcementpolicies",
            "singular": "ciliuml2announcementpolicy",
            "shortNames": [
              "l2announcement"
            ],
            "kind": "CiliumL2AnnouncementPolicy",
            "listKind": "CiliumL2AnnouncementPolicyList"
          },
          "storedVersions": [
            "v2alpha1"
          ]
        }
      },
      "additionalColumns": [
        {
          "name": "Age",
          "type": "date",
          "jsonPath": ".metadata.creationTimestamp"
        }
      ],
      "short": "CiliumL2AnnouncementPolicy",
      "apiGroup": "cilium.io",
      "apiKind": "CiliumL2AnnouncementPolicy",
      "apiVersion": "v2alpha1",
      "readProperties": {
        "spec": "spec",
        "status": "status"
      },
      "writeProperties": {
        "spec": "spec"
      },
      "group": "cilium",
      "sub": "cilium",
      "listExcludes": [],
      "readExcludes": [],
      "simpleExcludes": [],
      "gqlDefs": {
        "metadata": "metadata!",
        "spec": "JSONObject",
        "status": "JSONObject"
      },
      "namespaced": false
    },
    {
      "alternatives": [],
      "name": "io.cilium.v2alpha1.CiliumLoadBalancerIPPool",
      "definition": {
        "description": "CiliumLoadBalancerIPPool is a Kubernetes third-party resource which is used to defined pools of IPs which the operator can use to to allocate and advertise IPs for Services of type LoadBalancer.",
        "type": "object",
        "required": [
          "metadata"
        ],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "spec": {
            "description": "Spec is a human readable description for a BGP load balancer ip pool.",
            "type": "object",
            "required": [
              "cidrs"
            ],
            "properties": {
              "cidrs": {
                "description": "CiliumLoadBalancerIPPoolCIDRBlock is a list of CIDRs comprising this IP Pool",
                "type": "array",
                "minItems": 1,
                "items": {
                  "description": "CiliumLoadBalancerIPPoolCIDRBlock describes a single CIDR block.",
                  "type": "object",
                  "required": [
                    "cidr"
                  ],
                  "properties": {
                    "cidr": {
                      "type": "string",
                      "format": "cidr"
                    }
                  }
                }
              },
              "disabled": {
                "description": "Disabled, if set to true means that no new IPs will be allocated from this pool. Existing allocations will not be removed from services.",
                "type": "boolean"
              },
              "serviceSelector": {
                "description": "ServiceSelector selects a set of services which are eligible to receive IPs from this",
                "type": "object",
                "properties": {
                  "matchExpressions": {
                    "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                    "type": "array",
                    "items": {
                      "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                      "type": "object",
                      "required": [
                        "key",
                        "operator"
                      ],
                      "properties": {
                        "key": {
                          "description": "key is the label key that the selector applies to.",
                          "type": "string"
                        },
                        "operator": {
                          "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                          "type": "string",
                          "enum": [
                            "In",
                            "NotIn",
                            "Exists",
                            "DoesNotExist"
                          ]
                        },
                        "values": {
                          "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        }
                      }
                    }
                  },
                  "matchLabels": {
                    "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                    "type": "object",
                    "additionalProperties": {
                      "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                      "type": "string",
                      "maxLength": 63,
                      "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                    }
                  }
                }
              }
            }
          },
          "status": {
            "description": "Status is the status of the IP Pool. \n It might be possible for users to define overlapping IP Pools, we can't validate or enforce non-overlapping pools during object creation. The Cilium operator will do this validation and update the status to reflect the ability to allocate IPs from this pool.",
            "type": "object",
            "properties": {
              "conditions": {
                "description": "Current service state",
                "type": "array",
                "items": {
                  "description": "Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, \n \ttype FooStatus struct{ \t    // Represents the observations of a foo's current state. \t    // Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\" \t    // +patchMergeKey=type \t    // +patchStrategy=merge \t    // +listType=map \t    // +listMapKey=type \t    Conditions []metav1.Condition `json:\"conditions,omitempty\" patchStrategy:\"merge\" patchMergeKey:\"type\" protobuf:\"bytes,1,rep,name=conditions\"` \n \t    // other fields \t}",
                  "type": "object",
                  "required": [
                    "lastTransitionTime",
                    "message",
                    "reason",
                    "status",
                    "type"
                  ],
                  "properties": {
                    "lastTransitionTime": {
                      "description": "lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
                      "type": "string",
                      "format": "date-time"
                    },
                    "message": {
                      "description": "message is a human readable message indicating details about the transition. This may be an empty string.",
                      "type": "string",
                      "maxLength": 32768
                    },
                    "observedGeneration": {
                      "description": "observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.",
                      "type": "integer",
                      "format": "int64",
                      "minimum": 0
                    },
                    "reason": {
                      "description": "reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.",
                      "type": "string",
                      "maxLength": 1024,
                      "minLength": 1,
                      "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
                    },
                    "status": {
                      "description": "status of the condition, one of True, False, Unknown.",
                      "type": "string",
                      "enum": [
                        "True",
                        "False",
                        "Unknown"
                      ]
                    },
                    "type": {
                      "description": "type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)",
                      "type": "string",
                      "maxLength": 316,
                      "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
                    }
                  }
                },
                "x-kubernetes-list-map-keys": [
                  "type"
                ],
                "x-kubernetes-list-type": "map"
              }
            }
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "cilium.io",
            "kind": "CiliumLoadBalancerIPPool",
            "version": "v2alpha1"
          }
        ]
      },
      "crd": {
        "metadata": {
          "name": "ciliumloadbalancerippools.cilium.io",
          "uid": "4dec27d7-9d0d-4cc6-8c15-21013ad8c13f",
          "resourceVersion": "25877237733",
          "generation": 1,
          "creationTimestamp": "2023-11-21T10:47:03Z",
          "labels": {
            "io.cilium.k8s.crd.schema.version": "1.26.11"
          },
          "managedFields": [
            {
              "manager": "cilium-operator-generic",
              "operation": "Update",
              "apiVersion": "apiextensions.k8s.io/v1",
              "time": "2023-11-21T10:47:03Z",
              "fieldsType": "FieldsV1",
              "fieldsV1": {
                "f:metadata": {
                  "f:labels": {
                    ".": {},
                    "f:io.cilium.k8s.crd.schema.version": {}
                  }
                },
                "f:spec": {
                  "f:conversion": {
                    ".": {},
                    "f:strategy": {}
                  },
                  "f:group": {},
                  "f:names": {
                    "f:kind": {},
                    "f:listKind": {},
                    "f:plural": {},
                    "f:shortNames": {},
                    "f:singular": {}
                  },
                  "f:scope": {},
                  "f:versions": {}
                }
              }
            },
            {
              "manager": "kube-apiserver",
              "operation": "Update",
              "apiVersion": "apiextensions.k8s.io/v1",
              "time": "2023-11-21T10:47:03Z",
              "fieldsType": "FieldsV1",
              "fieldsV1": {
                "f:status": {
                  "f:acceptedNames": {
                    "f:kind": {},
                    "f:listKind": {},
                    "f:plural": {},
                    "f:shortNames": {},
                    "f:singular": {}
                  },
                  "f:conditions": {
                    "k:{\"type\":\"Established\"}": {
                      ".": {},
                      "f:lastTransitionTime": {},
                      "f:message": {},
                      "f:reason": {},
                      "f:status": {},
                      "f:type": {}
                    },
                    "k:{\"type\":\"NamesAccepted\"}": {
                      ".": {},
                      "f:lastTransitionTime": {},
                      "f:message": {},
                      "f:reason": {},
                      "f:status": {},
                      "f:type": {}
                    }
                  }
                }
              },
              "subresource": "status"
            }
          ]
        },
        "spec": {
          "group": "cilium.io",
          "names": {
            "plural": "ciliumloadbalancerippools",
            "singular": "ciliumloadbalancerippool",
            "shortNames": [
              "ippools",
              "ippool",
              "lbippool",
              "lbippools"
            ],
            "kind": "CiliumLoadBalancerIPPool",
            "listKind": "CiliumLoadBalancerIPPoolList"
          },
          "scope": "Cluster",
          "versions": [
            {
              "name": "v2alpha1",
              "served": true,
              "storage": true,
              "schema": {
                "openAPIV3Schema": {
                  "description": "CiliumLoadBalancerIPPool is a Kubernetes third-party resource which is used to defined pools of IPs which the operator can use to to allocate and advertise IPs for Services of type LoadBalancer.",
                  "type": "object",
                  "required": [
                    "metadata"
                  ],
                  "properties": {
                    "apiVersion": {
                      "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                      "type": "string"
                    },
                    "kind": {
                      "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                      "type": "string"
                    },
                    "metadata": {
                      "type": "object"
                    },
                    "spec": {
                      "description": "Spec is a human readable description for a BGP load balancer ip pool.",
                      "type": "object",
                      "required": [
                        "cidrs"
                      ],
                      "properties": {
                        "cidrs": {
                          "description": "CiliumLoadBalancerIPPoolCIDRBlock is a list of CIDRs comprising this IP Pool",
                          "type": "array",
                          "minItems": 1,
                          "items": {
                            "description": "CiliumLoadBalancerIPPoolCIDRBlock describes a single CIDR block.",
                            "type": "object",
                            "required": [
                              "cidr"
                            ],
                            "properties": {
                              "cidr": {
                                "type": "string",
                                "format": "cidr"
                              }
                            }
                          }
                        },
                        "disabled": {
                          "description": "Disabled, if set to true means that no new IPs will be allocated from this pool. Existing allocations will not be removed from services.",
                          "type": "boolean",
                          "default": false
                        },
                        "serviceSelector": {
                          "description": "ServiceSelector selects a set of services which are eligible to receive IPs from this",
                          "type": "object",
                          "properties": {
                            "matchExpressions": {
                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                              "type": "array",
                              "items": {
                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "key is the label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                    "type": "string",
                                    "enum": [
                                      "In",
                                      "NotIn",
                                      "Exists",
                                      "DoesNotExist"
                                    ]
                                  },
                                  "values": {
                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "matchLabels": {
                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                              "type": "object",
                              "additionalProperties": {
                                "description": "MatchLabelsValue represents the value from the MatchLabels {key,value} pair.",
                                "type": "string",
                                "maxLength": 63,
                                "pattern": "^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$"
                              }
                            }
                          }
                        }
                      }
                    },
                    "status": {
                      "description": "Status is the status of the IP Pool. \n It might be possible for users to define overlapping IP Pools, we can't validate or enforce non-overlapping pools during object creation. The Cilium operator will do this validation and update the status to reflect the ability to allocate IPs from this pool.",
                      "type": "object",
                      "properties": {
                        "conditions": {
                          "description": "Current service state",
                          "type": "array",
                          "items": {
                            "description": "Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, \n \ttype FooStatus struct{ \t    // Represents the observations of a foo's current state. \t    // Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\" \t    // +patchMergeKey=type \t    // +patchStrategy=merge \t    // +listType=map \t    // +listMapKey=type \t    Conditions []metav1.Condition `json:\"conditions,omitempty\" patchStrategy:\"merge\" patchMergeKey:\"type\" protobuf:\"bytes,1,rep,name=conditions\"` \n \t    // other fields \t}",
                            "type": "object",
                            "required": [
                              "lastTransitionTime",
                              "message",
                              "reason",
                              "status",
                              "type"
                            ],
                            "properties": {
                              "lastTransitionTime": {
                                "description": "lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
                                "type": "string",
                                "format": "date-time"
                              },
                              "message": {
                                "description": "message is a human readable message indicating details about the transition. This may be an empty string.",
                                "type": "string",
                                "maxLength": 32768
                              },
                              "observedGeneration": {
                                "description": "observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.",
                                "type": "integer",
                                "format": "int64",
                                "minimum": 0
                              },
                              "reason": {
                                "description": "reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.",
                                "type": "string",
                                "maxLength": 1024,
                                "minLength": 1,
                                "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
                              },
                              "status": {
                                "description": "status of the condition, one of True, False, Unknown.",
                                "type": "string",
                                "enum": [
                                  "True",
                                  "False",
                                  "Unknown"
                                ]
                              },
                              "type": {
                                "description": "type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)",
                                "type": "string",
                                "maxLength": 316,
                                "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
                              }
                            }
                          },
                          "x-kubernetes-list-map-keys": [
                            "type"
                          ],
                          "x-kubernetes-list-type": "map"
                        }
                      }
                    }
                  }
                }
              },
              "subresources": {
                "status": {}
              },
              "additionalPrinterColumns": [
                {
                  "name": "Disabled",
                  "type": "boolean",
                  "jsonPath": ".spec.disabled"
                },
                {
                  "name": "Conflicting",
                  "type": "string",
                  "jsonPath": ".status.conditions[?(@.type==\"io.cilium/conflict\")].status"
                },
                {
                  "name": "IPs Available",
                  "type": "string",
                  "jsonPath": ".status.conditions[?(@.type==\"io.cilium/ips-available\")].message"
                },
                {
                  "name": "Age",
                  "type": "date",
                  "jsonPath": ".metadata.creationTimestamp"
                }
              ]
            }
          ],
          "conversion": {
            "strategy": "None"
          }
        },
        "status": {
          "conditions": [
            {
              "type": "NamesAccepted",
              "status": "True",
              "lastTransitionTime": "2023-11-21T10:47:03Z",
              "reason": "NoConflicts",
              "message": "no conflicts found"
            },
            {
              "type": "Established",
              "status": "True",
              "lastTransitionTime": "2023-11-21T10:47:03Z",
              "reason": "InitialNamesAccepted",
              "message": "the initial names have been accepted"
            }
          ],
          "acceptedNames": {
            "plural": "ciliumloadbalancerippools",
            "singular": "ciliumloadbalancerippool",
            "shortNames": [
              "ippools",
              "ippool",
              "lbippool",
              "lbippools"
            ],
            "kind": "CiliumLoadBalancerIPPool",
            "listKind": "CiliumLoadBalancerIPPoolList"
          },
          "storedVersions": [
            "v2alpha1"
          ]
        }
      },
      "additionalColumns": [
        {
          "name": "Disabled",
          "type": "boolean",
          "jsonPath": ".spec.disabled"
        },
        {
          "name": "Conflicting",
          "type": "string",
          "jsonPath": ".status.conditions[?(@.type==\"io.cilium/conflict\")].status"
        },
        {
          "name": "IPs Available",
          "type": "string",
          "jsonPath": ".status.conditions[?(@.type==\"io.cilium/ips-available\")].message"
        },
        {
          "name": "Age",
          "type": "date",
          "jsonPath": ".metadata.creationTimestamp"
        }
      ],
      "short": "CiliumLoadBalancerIPPool",
      "apiGroup": "cilium.io",
      "apiKind": "CiliumLoadBalancerIPPool",
      "apiVersion": "v2alpha1",
      "readProperties": {
        "spec": "spec",
        "status": "status"
      },
      "writeProperties": {
        "spec": "spec"
      },
      "group": "cilium",
      "sub": "cilium",
      "listExcludes": [],
      "readExcludes": [],
      "simpleExcludes": [],
      "gqlDefs": {
        "metadata": "metadata!",
        "spec": "JSONObject",
        "status": "JSONObject"
      },
      "namespaced": false
    },
    {
      "alternatives": [],
      "name": "io.cilium.v2alpha1.CiliumNodeConfig",
      "definition": {
        "description": "CiliumNodeConfig is a list of configuration key-value pairs. It is applied to nodes indicated by a label selector. \n If multiple overrides apply to the same node, they will be ordered by name with later Overrides overwriting any conflicting keys.",
        "type": "object",
        "required": [
          "spec"
        ],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "spec": {
            "description": "Spec is the desired Cilium configuration overrides for a given node",
            "type": "object",
            "required": [
              "defaults",
              "nodeSelector"
            ],
            "properties": {
              "defaults": {
                "description": "Defaults is treated the same as the cilium-config ConfigMap - a set of key-value pairs parsed by the agent and operator processes. Each key must be a valid config-map data field (i.e. a-z, A-Z, -, _, and .)",
                "type": "object",
                "additionalProperties": {
                  "type": "string"
                }
              },
              "nodeSelector": {
                "description": "NodeSelector is a label selector that determines to which nodes this configuration applies. If not supplied, then this config applies to no nodes. If empty, then it applies to all nodes.",
                "type": "object",
                "properties": {
                  "matchExpressions": {
                    "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                    "type": "array",
                    "items": {
                      "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                      "type": "object",
                      "required": [
                        "key",
                        "operator"
                      ],
                      "properties": {
                        "key": {
                          "description": "key is the label key that the selector applies to.",
                          "type": "string"
                        },
                        "operator": {
                          "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                          "type": "string"
                        },
                        "values": {
                          "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        }
                      }
                    }
                  },
                  "matchLabels": {
                    "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                    "type": "object",
                    "additionalProperties": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "cilium.io",
            "kind": "CiliumNodeConfig",
            "version": "v2alpha1"
          }
        ]
      },
      "crd": {
        "metadata": {
          "name": "ciliumnodeconfigs.cilium.io",
          "uid": "95118eb5-6732-4646-b7dc-7148916cddba",
          "resourceVersion": "25877237845",
          "generation": 1,
          "creationTimestamp": "2023-11-21T10:47:03Z",
          "labels": {
            "io.cilium.k8s.crd.schema.version": "1.26.11"
          },
          "managedFields": [
            {
              "manager": "cilium-operator-generic",
              "operation": "Update",
              "apiVersion": "apiextensions.k8s.io/v1",
              "time": "2023-11-21T10:47:03Z",
              "fieldsType": "FieldsV1",
              "fieldsV1": {
                "f:metadata": {
                  "f:labels": {
                    ".": {},
                    "f:io.cilium.k8s.crd.schema.version": {}
                  }
                },
                "f:spec": {
                  "f:conversion": {
                    ".": {},
                    "f:strategy": {}
                  },
                  "f:group": {},
                  "f:names": {
                    "f:kind": {},
                    "f:listKind": {},
                    "f:plural": {},
                    "f:singular": {}
                  },
                  "f:scope": {},
                  "f:versions": {}
                }
              }
            },
            {
              "manager": "kube-apiserver",
              "operation": "Update",
              "apiVersion": "apiextensions.k8s.io/v1",
              "time": "2023-11-21T10:47:03Z",
              "fieldsType": "FieldsV1",
              "fieldsV1": {
                "f:status": {
                  "f:acceptedNames": {
                    "f:kind": {},
                    "f:listKind": {},
                    "f:plural": {},
                    "f:singular": {}
                  },
                  "f:conditions": {
                    "k:{\"type\":\"Established\"}": {
                      ".": {},
                      "f:lastTransitionTime": {},
                      "f:message": {},
                      "f:reason": {},
                      "f:status": {},
                      "f:type": {}
                    },
                    "k:{\"type\":\"NamesAccepted\"}": {
                      ".": {},
                      "f:lastTransitionTime": {},
                      "f:message": {},
                      "f:reason": {},
                      "f:status": {},
                      "f:type": {}
                    }
                  }
                }
              },
              "subresource": "status"
            }
          ]
        },
        "spec": {
          "group": "cilium.io",
          "names": {
            "plural": "ciliumnodeconfigs",
            "singular": "ciliumnodeconfig",
            "kind": "CiliumNodeConfig",
            "listKind": "CiliumNodeConfigList"
          },
          "scope": "Namespaced",
          "versions": [
            {
              "name": "v2alpha1",
              "served": true,
              "storage": true,
              "schema": {
                "openAPIV3Schema": {
                  "description": "CiliumNodeConfig is a list of configuration key-value pairs. It is applied to nodes indicated by a label selector. \n If multiple overrides apply to the same node, they will be ordered by name with later Overrides overwriting any conflicting keys.",
                  "type": "object",
                  "required": [
                    "spec"
                  ],
                  "properties": {
                    "apiVersion": {
                      "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                      "type": "string"
                    },
                    "kind": {
                      "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                      "type": "string"
                    },
                    "metadata": {
                      "type": "object"
                    },
                    "spec": {
                      "description": "Spec is the desired Cilium configuration overrides for a given node",
                      "type": "object",
                      "required": [
                        "defaults",
                        "nodeSelector"
                      ],
                      "properties": {
                        "defaults": {
                          "description": "Defaults is treated the same as the cilium-config ConfigMap - a set of key-value pairs parsed by the agent and operator processes. Each key must be a valid config-map data field (i.e. a-z, A-Z, -, _, and .)",
                          "type": "object",
                          "additionalProperties": {
                            "type": "string"
                          }
                        },
                        "nodeSelector": {
                          "description": "NodeSelector is a label selector that determines to which nodes this configuration applies. If not supplied, then this config applies to no nodes. If empty, then it applies to all nodes.",
                          "type": "object",
                          "properties": {
                            "matchExpressions": {
                              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                              "type": "array",
                              "items": {
                                "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                "type": "object",
                                "required": [
                                  "key",
                                  "operator"
                                ],
                                "properties": {
                                  "key": {
                                    "description": "key is the label key that the selector applies to.",
                                    "type": "string"
                                  },
                                  "operator": {
                                    "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                    "type": "string"
                                  },
                                  "values": {
                                    "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "matchLabels": {
                              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                              "type": "object",
                              "additionalProperties": {
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          ],
          "conversion": {
            "strategy": "None"
          }
        },
        "status": {
          "conditions": [
            {
              "type": "NamesAccepted",
              "status": "True",
              "lastTransitionTime": "2023-11-21T10:47:03Z",
              "reason": "NoConflicts",
              "message": "no conflicts found"
            },
            {
              "type": "Established",
              "status": "True",
              "lastTransitionTime": "2023-11-21T10:47:03Z",
              "reason": "InitialNamesAccepted",
              "message": "the initial names have been accepted"
            }
          ],
          "acceptedNames": {
            "plural": "ciliumnodeconfigs",
            "singular": "ciliumnodeconfig",
            "kind": "CiliumNodeConfig",
            "listKind": "CiliumNodeConfigList"
          },
          "storedVersions": [
            "v2alpha1"
          ]
        }
      },
      "short": "CiliumNodeConfig",
      "apiGroup": "cilium.io",
      "apiKind": "CiliumNodeConfig",
      "apiVersion": "v2alpha1",
      "readProperties": {
        "spec": "spec"
      },
      "writeProperties": {
        "spec": "spec"
      },
      "group": "cilium",
      "sub": "cilium",
      "listExcludes": [],
      "readExcludes": [],
      "simpleExcludes": [],
      "gqlDefs": {
        "metadata": "metadata!",
        "spec": "JSONObject"
      },
      "namespaced": true
    },
    {
      "alternatives": [],
      "name": "io.cilium.v2alpha1.CiliumPodIPPool",
      "definition": {
        "description": "CiliumPodIPPool defines an IP pool that can be used for pooled IPAM (i.e. the multi-pool IPAM mode).",
        "type": "object",
        "required": [
          "spec"
        ],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "spec": {
            "type": "object",
            "properties": {
              "ipv4": {
                "description": "IPv4 specifies the IPv4 CIDRs and mask sizes of the pool",
                "type": "object",
                "required": [
                  "cidrs",
                  "maskSize"
                ],
                "properties": {
                  "cidrs": {
                    "description": "CIDRs is a list of IPv4 CIDRs that are part of the pool.",
                    "type": "array",
                    "minItems": 1,
                    "items": {
                      "description": "PoolCIDR is an IP pool CIDR.",
                      "type": "string",
                      "format": "cidr"
                    }
                  },
                  "maskSize": {
                    "description": "MaskSize is the mask size of the pool.",
                    "type": "integer",
                    "maximum": 32,
                    "minimum": 1
                  }
                }
              },
              "ipv6": {
                "description": "IPv6 specifies the IPv6 CIDRs and mask sizes of the pool",
                "type": "object",
                "required": [
                  "cidrs",
                  "maskSize"
                ],
                "properties": {
                  "cidrs": {
                    "description": "CIDRs is a list of IPv6 CIDRs that are part of the pool.",
                    "type": "array",
                    "minItems": 1,
                    "items": {
                      "description": "PoolCIDR is an IP pool CIDR.",
                      "type": "string",
                      "format": "cidr"
                    }
                  },
                  "maskSize": {
                    "description": "MaskSize is the mask size of the pool.",
                    "type": "integer",
                    "maximum": 128,
                    "minimum": 1
                  }
                }
              }
            }
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "cilium.io",
            "kind": "CiliumPodIPPool",
            "version": "v2alpha1"
          }
        ]
      },
      "crd": {
        "metadata": {
          "name": "ciliumpodippools.cilium.io",
          "uid": "b997fc8f-e8ad-480e-8b86-f4404c882320",
          "resourceVersion": "25877237972",
          "generation": 1,
          "creationTimestamp": "2023-11-21T10:47:04Z",
          "labels": {
            "io.cilium.k8s.crd.schema.version": "1.26.11"
          },
          "managedFields": [
            {
              "manager": "cilium-operator-generic",
              "operation": "Update",
              "apiVersion": "apiextensions.k8s.io/v1",
              "time": "2023-11-21T10:47:04Z",
              "fieldsType": "FieldsV1",
              "fieldsV1": {
                "f:metadata": {
                  "f:labels": {
                    ".": {},
                    "f:io.cilium.k8s.crd.schema.version": {}
                  }
                },
                "f:spec": {
                  "f:conversion": {
                    ".": {},
                    "f:strategy": {}
                  },
                  "f:group": {},
                  "f:names": {
                    "f:kind": {},
                    "f:listKind": {},
                    "f:plural": {},
                    "f:shortNames": {},
                    "f:singular": {}
                  },
                  "f:scope": {},
                  "f:versions": {}
                }
              }
            },
            {
              "manager": "kube-apiserver",
              "operation": "Update",
              "apiVersion": "apiextensions.k8s.io/v1",
              "time": "2023-11-21T10:47:04Z",
              "fieldsType": "FieldsV1",
              "fieldsV1": {
                "f:status": {
                  "f:acceptedNames": {
                    "f:kind": {},
                    "f:listKind": {},
                    "f:plural": {},
                    "f:shortNames": {},
                    "f:singular": {}
                  },
                  "f:conditions": {
                    "k:{\"type\":\"Established\"}": {
                      ".": {},
                      "f:lastTransitionTime": {},
                      "f:message": {},
                      "f:reason": {},
                      "f:status": {},
                      "f:type": {}
                    },
                    "k:{\"type\":\"NamesAccepted\"}": {
                      ".": {},
                      "f:lastTransitionTime": {},
                      "f:message": {},
                      "f:reason": {},
                      "f:status": {},
                      "f:type": {}
                    }
                  }
                }
              },
              "subresource": "status"
            }
          ]
        },
        "spec": {
          "group": "cilium.io",
          "names": {
            "plural": "ciliumpodippools",
            "singular": "ciliumpodippool",
            "shortNames": [
              "cpip"
            ],
            "kind": "CiliumPodIPPool",
            "listKind": "CiliumPodIPPoolList"
          },
          "scope": "Cluster",
          "versions": [
            {
              "name": "v2alpha1",
              "served": true,
              "storage": true,
              "schema": {
                "openAPIV3Schema": {
                  "description": "CiliumPodIPPool defines an IP pool that can be used for pooled IPAM (i.e. the multi-pool IPAM mode).",
                  "type": "object",
                  "required": [
                    "spec"
                  ],
                  "properties": {
                    "apiVersion": {
                      "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                      "type": "string"
                    },
                    "kind": {
                      "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                      "type": "string"
                    },
                    "metadata": {
                      "type": "object"
                    },
                    "spec": {
                      "type": "object",
                      "properties": {
                        "ipv4": {
                          "description": "IPv4 specifies the IPv4 CIDRs and mask sizes of the pool",
                          "type": "object",
                          "required": [
                            "cidrs",
                            "maskSize"
                          ],
                          "properties": {
                            "cidrs": {
                              "description": "CIDRs is a list of IPv4 CIDRs that are part of the pool.",
                              "type": "array",
                              "minItems": 1,
                              "items": {
                                "description": "PoolCIDR is an IP pool CIDR.",
                                "type": "string",
                                "format": "cidr"
                              }
                            },
                            "maskSize": {
                              "description": "MaskSize is the mask size of the pool.",
                              "type": "integer",
                              "maximum": 32,
                              "minimum": 1
                            }
                          }
                        },
                        "ipv6": {
                          "description": "IPv6 specifies the IPv6 CIDRs and mask sizes of the pool",
                          "type": "object",
                          "required": [
                            "cidrs",
                            "maskSize"
                          ],
                          "properties": {
                            "cidrs": {
                              "description": "CIDRs is a list of IPv6 CIDRs that are part of the pool.",
                              "type": "array",
                              "minItems": 1,
                              "items": {
                                "description": "PoolCIDR is an IP pool CIDR.",
                                "type": "string",
                                "format": "cidr"
                              }
                            },
                            "maskSize": {
                              "description": "MaskSize is the mask size of the pool.",
                              "type": "integer",
                              "maximum": 128,
                              "minimum": 1
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          ],
          "conversion": {
            "strategy": "None"
          }
        },
        "status": {
          "conditions": [
            {
              "type": "NamesAccepted",
              "status": "True",
              "lastTransitionTime": "2023-11-21T10:47:04Z",
              "reason": "NoConflicts",
              "message": "no conflicts found"
            },
            {
              "type": "Established",
              "status": "True",
              "lastTransitionTime": "2023-11-21T10:47:04Z",
              "reason": "InitialNamesAccepted",
              "message": "the initial names have been accepted"
            }
          ],
          "acceptedNames": {
            "plural": "ciliumpodippools",
            "singular": "ciliumpodippool",
            "shortNames": [
              "cpip"
            ],
            "kind": "CiliumPodIPPool",
            "listKind": "CiliumPodIPPoolList"
          },
          "storedVersions": [
            "v2alpha1"
          ]
        }
      },
      "short": "CiliumPodIPPool",
      "apiGroup": "cilium.io",
      "apiKind": "CiliumPodIPPool",
      "apiVersion": "v2alpha1",
      "readProperties": {
        "spec": "spec"
      },
      "writeProperties": {
        "spec": "spec"
      },
      "group": "cilium",
      "sub": "cilium",
      "listExcludes": [],
      "readExcludes": [],
      "simpleExcludes": [],
      "gqlDefs": {
        "metadata": "metadata!",
        "spec": "JSONObject"
      },
      "namespaced": false
    }
  ]
}